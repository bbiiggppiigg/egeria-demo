{% extends "opencl/base.html" %} 
 {% block sitenav %}
<nav id="site-nav">
 <div class="category" state="0">
  <a href="http://{{host}}:{{port}}/{{docname}}/raw">
   Optimization Guide
  </a>
 </div>
 <div class="category" state="0">
  <a href="http://{{host}}:{{port}}/{{docname}}/summary">
   Optimization Guide Summary
  </a>
 </div>
 <ul>
  <li>
   <div class="section-link" state="1">
    <a href="#50401315_pgfId-542099">
     Chapter 1 OpenCL Performance and Optimization
    </a>
   </div>
   <ul>
    <li>
     <div class="section-link" state="2">
      <a href="#50401315_pgfId-444709">
       1.1 CodeXL GPU Profiler 1-1
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-535338">
         1.1.1 Collecting OpenCL Application Traces 1-1
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-535633">
         1.1.2 Timeline View 1-2
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-535800">
         1.1.3 Summary Pages View 1-3
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-536178">
         1.1.4 API Trace View 1-4
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-536185">
         1.1.5 Collecting OpenCL GPU Kernel Performance Counters 1-5
        </a>
       </div>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#50401315_pgfId-537554">
       1.2 AMD APP KernelAnalyzer2 1-6
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-538360">
         1.2.1 Start KernelAnalyzer2 1-6
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-538414">
         1.2.2 Open Kernel Source 1-7
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-539373">
         1.2.3 Build Options – Choosing Target ASICS 1-8
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-538453">
         1.2.4 Build Options – Defining Kernel Compilation Options 1-9
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-538468">
         1.2.5 Analysis Input Tab 1-9
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-538477">
         1.2.6 Build the Kernel 1-9
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-538494">
         1.2.7 Build Statistics Tab 1-10
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-538501">
         1.2.8 The Analysis Tab 1-10
        </a>
       </div>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#50401315_pgfId-537927">
       1.3 Analyzing Processor Kernels 1-11
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-446463">
         1.3.1 Intermediate Language and GPU Disassembly 1-11
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-446467">
         1.3.2 Generating IL and ISA Code 1-11
        </a>
       </div>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#50401315_pgfId-495738">
       1.4 Estimating Performance 1-12
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-446474">
         1.4.1 Measuring Execution Time 1-12
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-451445">
         1.4.2 Using the OpenCL timer with Other System Timers 1-13
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-446494">
         1.4.3 Estimating Memory Bandwidth 1-14
        </a>
       </div>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#50401315_pgfId-495909">
       1.5 OpenCL Memory Objects 1-15
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-502813">
         1.5.1 Types of Memory Used by the Runtime 1-15
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#50401315_pgfId-532479">
           Host Memory 1-16
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401315_pgfId-502946">
           Pinned Host Memory 1-16
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401315_pgfId-503174">
           Device-Visible Host Memory 1-17
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401315_pgfId-503307">
           Device Memory 1-17
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401315_pgfId-503175">
           Host-Visible Device Memory 1-18
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-503627">
         1.5.2 Placement 1-18
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-503571">
         1.5.3 Memory Allocation 1-19
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#50401315_pgfId-520796">
           Using the CPU 1-19
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401315_pgfId-520798">
           Using Both CPU and GPU Devices, or using an APU Device 1-20
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401315_pgfId-520800">
           Buffers vs Images 1-20
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401315_pgfId-521010">
           Choosing Execution Dimensions 1-20
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-520762">
         1.5.4 Mapping 1-20
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#50401315_pgfId-503784">
           Zero Copy Memory Objects 1-20
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401315_pgfId-504154">
           Copy Memory Objects 1-21
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-504422">
         1.5.5 Reading, Writing, and Copying 1-23
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-504431">
         1.5.6 Command Queue 1-23
        </a>
       </div>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#50401315_pgfId-502559">
       1.6 OpenCL Data Transfer Optimization 1-23
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-525051">
         1.6.1 Definitions 1-24
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-501699">
         1.6.2 Buffers 1-24
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#50401315_pgfId-496787">
           Regular Device Buffers 1-24
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401315_pgfId-497032">
           Zero Copy Buffers 1-25
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401315_pgfId-518336">
           Pre-pinned Buffers 1-26
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401315_pgfId-517669">
           Application Scenarios and Recommended OpenCL Paths 1-27
          </a>
         </div>
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#50401315_pgfId-531115">
       1.7 Using Multiple OpenCL Devices 1-31
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-531120">
         1.7.1 CPU and GPU Devices 1-31
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-531299">
         1.7.2 When to Use Multiple Devices 1-33
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-531308">
         1.7.3 Partitioning Work for Multiple Devices 1-34
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-531363">
         1.7.4 Synchronization Caveats 1-36
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-531396">
         1.7.5 GPU and CPU Kernels 1-38
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401315_pgfId-531424">
         1.7.6 Contexts and Devices 1-39
        </a>
       </div>
      </li>
     </ul>
    </li>
   </ul>
  </li>
  <li>
   <div class="section-link" state="1">
    <a href="#50401334_pgfId-412605">
     Chapter 2 OpenCL Performance and Optimization for GCN Devices
    </a>
   </div>
   <ul>
    <li>
     <div class="section-link" state="2">
      <a href="#50401334_pgfId-472054">
       2.1 Global Memory Optimization 2-1
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#50401334_pgfId-472173">
         2.1.1 Channel Conflicts 2-3
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#50401334_pgfId-472340">
           Staggered Offsets 2-7
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401334_pgfId-472385">
           Reads Of The Same Address 2-9
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401334_pgfId-472466">
         2.1.2 Coalesced Writes 2-9
        </a>
       </div>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#50401334_pgfId-481974">
       2.2 Local Memory (LDS) Optimization 2-10
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#50401334_pgfId-448213">
       2.3 Constant Memory Optimization 2-12
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#50401334_pgfId-449206">
       2.4 OpenCL Memory Resources: Capacity and Performance 2-14
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#50401334_pgfId-538469">
       2.5 Using LDS or L1 Cache 2-16
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#50401334_pgfId-487709">
       2.6 NDRange and Execution Range Optimization 2-17
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#50401334_pgfId-473708">
         2.6.1 Hiding ALU and Memory Latency 2-17
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401334_pgfId-452280">
         2.6.2 Resource Limits on Active Wavefronts 2-18
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#50401334_pgfId-452285">
           GPU Registers 2-18
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401334_pgfId-458289">
           Specifying the Default Work-Group Size at Compile-Time 2-19
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401334_pgfId-458253">
           Local Memory (LDS) Size 2-19
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401334_pgfId-458820">
         2.6.3 Partitioning the Work 2-20
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#50401334_pgfId-452491">
           Global Work Size 2-21
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401334_pgfId-452494">
           Local Work Size (#Work-Items per Work-Group) 2-21
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401334_pgfId-457158">
           Work-Group Dimensions vs Size 2-22
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401334_pgfId-457368">
         2.6.4 Summary of NDRange Optimizations 2-22
        </a>
       </div>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#50401334_pgfId-451154">
       2.7 Instruction Selection Optimizations 2-24
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#50401334_pgfId-459510">
         2.7.1 Instruction Bandwidths 2-24
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401334_pgfId-459722">
         2.7.2 AMD Media Instructions 2-25
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401334_pgfId-459778">
         2.7.3 Math Libraries 2-25
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401334_pgfId-451159">
         2.7.4 Compiler Optimizations 2-26
        </a>
       </div>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#50401334_pgfId-520751">
       2.8 Additional Performance Guidance 2-26
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#50401334_pgfId-448804">
         2.8.1 Loop Unroll  pragma  2-26
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401334_pgfId-495342">
         2.8.2 Memory Tiling 2-27
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401334_pgfId-446673">
         2.8.3 General Tips 2-28
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401334_pgfId-521164">
         2.8.4 Guidance for CUDA Programmers Using OpenCL 2-30
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401334_pgfId-446698">
         2.8.5 Guidance for CPU Programmers Using OpenCL to Program GPUs 2-30
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401334_pgfId-521316">
         2.8.6 Optimizing Kernel Code 2-31
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#50401334_pgfId-521317">
           Using Vector Data Types 2-31
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401334_pgfId-521255">
           Local Memory 2-31
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401334_pgfId-521257">
           Using Special CPU Instructions 2-31
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401334_pgfId-521264">
           Avoid Barriers When Possible 2-32
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401334_pgfId-521246">
         2.8.7 Optimizing Kernels for Southern Island GPUs 2-32
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#50401334_pgfId-494706">
           Remove Conditional Assignments 2-32
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401334_pgfId-494711">
           Bypass Short-Circuiting 2-32
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401334_pgfId-494717">
           Unroll Small Loops 2-32
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401334_pgfId-494719">
           Avoid Nested  if s 2-32
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401334_pgfId-494721">
           Experiment With  do / while / for Loops 2-33
          </a>
         </div>
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#50401334_pgfId-521515">
       2.9 Specific Guidelines for Southern Islands GPUs 2-33
      </a>
     </div>
    </li>
   </ul>
  </li>
  <li>
   <div class="section-link" state="1">
    <a href="#50401371_pgfId-412605">
     Chapter 3 OpenCL Performance and
Optimization for Evergreen and Northern Islands Devices
    </a>
   </div>
   <ul>
    <li>
     <div class="section-link" state="2">
      <a href="#50401371_pgfId-472054">
       3.1 Global Memory Optimization 3-1
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-472079">
         3.1.1 Two Memory Paths 3-3
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#50401371_pgfId-472083">
           Performance Impact of FastPath and CompletePath 3-3
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401371_pgfId-472136">
           Determining The Used Path 3-4
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-472173">
         3.1.2 Channel Conflicts 3-6
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#50401371_pgfId-472340">
           Staggered Offsets 3-9
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401371_pgfId-472385">
           Reads Of The Same Address 3-10
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-472397">
         3.1.3 Float4 Or Float1 3-11
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-472466">
         3.1.4 Coalesced Writes 3-12
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-472569">
         3.1.5 Alignment 3-14
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-472647">
         3.1.6 Summary of Copy Performance 3-16
        </a>
       </div>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#50401371_pgfId-481974">
       3.2 Local Memory (LDS) Optimization 3-16
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#50401371_pgfId-448213">
       3.3 Constant Memory Optimization 3-19
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#50401371_pgfId-449206">
       3.4 OpenCL Memory Resources: Capacity and Performance 3-20
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#50401371_pgfId-487708">
       3.5 Using LDS or L1 Cache 3-22
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#50401371_pgfId-487709">
       3.6 NDRange and Execution Range Optimization 3-23
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-473708">
         3.6.1 Hiding ALU and Memory Latency 3-23
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-452280">
         3.6.2 Resource Limits on Active Wavefronts 3-24
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#50401371_pgfId-452285">
           GPU Registers 3-25
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401371_pgfId-458289">
           Specifying the Default Work-Group Size at Compile-Time 3-26
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401371_pgfId-458253">
           Local Memory (LDS) Size 3-27
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-458820">
         3.6.3 Partitioning the Work 3-28
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#50401371_pgfId-452491">
           Global Work Size 3-28
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401371_pgfId-452494">
           Local Work Size (#Work-Items per Work-Group) 3-28
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401371_pgfId-452498">
           Moving Work to the Kernel 3-29
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401371_pgfId-457158">
           Work-Group Dimensions vs Size 3-30
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-452785">
         3.6.4 Optimizing for Cedar 3-31
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-457368">
         3.6.5 Summary of NDRange Optimizations 3-32
        </a>
       </div>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#50401371_pgfId-463371">
       3.7 Using Multiple OpenCL Devices 3-32
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-463382">
         3.7.1 CPU and GPU Devices 3-32
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-463540">
         3.7.2 When to Use Multiple Devices 3-35
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-463544">
         3.7.3 Partitioning Work for Multiple Devices 3-35
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-463566">
         3.7.4 Synchronization Caveats 3-37
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-463571">
         3.7.5 GPU and CPU Kernels 3-38
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-463581">
         3.7.6 Contexts and Devices 3-40
        </a>
       </div>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#50401371_pgfId-451154">
       3.8 Instruction Selection Optimizations 3-41
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-459510">
         3.8.1 Instruction Bandwidths 3-41
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-459722">
         3.8.2 AMD Media Instructions 3-42
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-459778">
         3.8.3 Math Libraries 3-42
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-459906">
         3.8.4 VLIW and SSE Packing 3-43
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-451159">
         3.8.5 Compiler Optimizations 3-45
        </a>
       </div>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#50401371_pgfId-517108">
       3.9 Clause Boundaries 3-46
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#50401371_pgfId-520751">
       3.10 Additional Performance Guidance 3-48
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-448804">
         3.10.1 Loop Unroll  pragma  3-48
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-495342">
         3.10.2 Memory Tiling 3-48
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-446673">
         3.10.3 General Tips 3-49
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-521164">
         3.10.4 Guidance for CUDA Programmers Using OpenCL 3-51
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-446698">
         3.10.5 Guidance for CPU Programmers Using OpenCL to Program GPUs 3-52
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-521316">
         3.10.6 Optimizing Kernel Code 3-53
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#50401371_pgfId-521317">
           Using Vector Data Types 3-53
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401371_pgfId-521255">
           Local Memory 3-53
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401371_pgfId-521257">
           Using Special CPU Instructions 3-53
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401371_pgfId-521264">
           Avoid Barriers When Possible 3-53
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#50401371_pgfId-521246">
         3.10.7 Optimizing Kernels for Evergreen and 69XX-Series GPUs 3-53
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#50401371_pgfId-494703">
           Clauses 3-53
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401371_pgfId-494706">
           Remove Conditional Assignments 3-54
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401371_pgfId-494711">
           Bypass Short-Circuiting 3-54
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401371_pgfId-494717">
           Unroll Small Loops 3-54
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401371_pgfId-494719">
           Avoid Nested  if s 3-54
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401371_pgfId-494721">
           Experiment With  do / while / for Loops 3-55
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#50401371_pgfId-494723">
           Do I/O With 4-Word Data 3-55
          </a>
         </div>
        </li>
       </ul>
      </li>
     </ul>
    </li>
   </ul>
  </li>
 </ul>
</nav>
 {% endblock %} 
{% block content %}
<div id="contents-container">
 <article id="contents">
  <div class="topic concept nested1" id="50401315_pgfId-542099" xml:lang="en-US">
   <a name="50401315_pgfId-542099" shape="rect">
   </a>
   <h2 class="title topictitle1">
    <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-542099" name="50401315_pgfId-542099" shape="rect">
     Chapter 1 OpenCL Performance and Optimization
    </a>
   </h2>
   <div class="body conbody">
    <ul class="ul">
     <li class="li">
      This chapter discusses performance and optimization when programming for AMD Accelerated Parallel Processing (APP) GPU compute devices, as well as CPUs and multiple devices.
     </li>
     <li class="li">
      Details specific to the Southern Islands series of GPUs is at the end of the chapter.
     </li>
    </ul>
   </div>
   <div class="topic concept nested2" id="50401315_pgfId-444709" xml:lang="en-US">
    <a name="50401315_pgfId-444709" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-444709" name="50401315_pgfId-444709" shape="rect">
      1.1 CodeXL GPU Profiler 1-1
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       The CodeXL GPU Profiler (hereafter Profiler) is a performance analysis tool that gathers data from the OpenCL run-time and AMD Radeon™ GPUs during the execution of an OpenCL application.
      </li>
      <li class="li">
       This information is used to discover bottlenecks in the application and find ways to optimize the application’s performance for AMD platforms.
      </li>
      <li class="li">
       The following subsections describe the modes of operation supported by the Profiler.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-535338" xml:lang="en-US">
     <a name="50401315_pgfId-535338" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-535338" name="50401315_pgfId-535338" shape="rect">
       1.1.1 Collecting OpenCL Application Traces 1-1
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        This mode requires running an application trace GPU profile sesstion.
       </li>
       <li class="li">
        To do this: Select the GPU: Application Trace Profile Type.
       </li>
       <li class="li">
        Click the Start CodeXL Profiling button, .
       </li>
       <li class="li">
        Pause / Stop the profiled application using the execution toolbar buttons, .
       </li>
       <li class="li">
        When the profiled application execution is done, CodeXL displays the session.
       </li>
       <li class="li">
        See Sample Application Trace API Summary show a sample application trace API summary view.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-535633" xml:lang="en-US">
     <a name="50401315_pgfId-535633" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-535633" name="50401315_pgfId-535633" shape="rect">
       1.1.2 Timeline View 1-2
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The Timeline View (See Sample Timeline View) provides a visual representation of the execution of the application.
       </li>
       <li class="li">
        At the top of the timeline is the time grid; it shows, in milliseconds, the total elapsed time of the application when fully zoomed out.
       </li>
       <li class="li">
        Timing begins when the first OpenCL call is made by the application; it ends when the final OpenCL call is made.
       </li>
       <li class="li">
        Below the time grid is a list of each host (OS) thread that made at least one OpenCL call.
       </li>
       <li class="li">
        For each host thread, the OpenCL API calls are plotted along the time grid, showing the start time and duration of each call.
       </li>
       <li class="li">
        Below the host threads, the OpenCL tree shows all contexts and queues created by the application, along with data transfer operations and kernel execution operations for each queue.
       </li>
       <li class="li">
        You can navigate in the Timeline View by zooming, panning, collapsing/expanding, or selecting a region of interest.
       </li>
       <li class="li">
        From the Timeline View, you also can navigate to the corresponding API call in the API Trace View, and vice versa.
       </li>
       <li class="li">
        The Timeline View can be useful for debugging your OpenCL application.
       </li>
       <li class="li">
        Examples are given below.
       </li>
       <li class="li">
        The Timeline View lets you easily confirm that the high-level structure of your application is correct by verifying that the number of queues and contexts created match your expectations for the application.
       </li>
       <li class="li">
        You can confirm that synchronization has been performed properly in the application.
       </li>
       <li class="li">
        For example, if kernel A execution is dependent on a buffer operation and outputs from kernel B execution, then kernel A execution must appear after the completion of the buffer execution and kernel B execution in the time grid.
       </li>
       <li class="li">
        It can be hard to find this type of synchronization error using traditional debugging techniques.
       </li>
       <li class="li">
        You can confirm that the application has been using the hardware efficiently.
       </li>
       <li class="li">
        For example, the timeline should show that non-dependent kernel executions and data transfer operations occurred simultaneously.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-535800" xml:lang="en-US">
     <a name="50401315_pgfId-535800" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-535800" name="50401315_pgfId-535800" shape="rect">
       1.1.3 Summary Pages View 1-3
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The Summary Pages View (See Sample Summary Pages View) shows various statistics for your OpenCL application.
       </li>
       <li class="li">
        It can give a general idea of the location of the application’s bottlenecks.
       </li>
       <li class="li">
        It also provides useful information, such as the number of buffers and images created on each context, the most expensive kernel call, etc.
       </li>
       <li class="li">
        The Summary Pages View provides access to the following individual pages.
       </li>
       <li class="li">
        Context Summary  Shows the statistics for all the kernel dispatch and data transfer operations for each context.
       </li>
       <li class="li">
        It also shows the number of buffers and images created for each context.
       </li>
       <li class="li">
        Kernel Summary  Shows statistics for all the kernels created in the application.
       </li>
       <li class="li">
        Top 10 Data Transfer Summary  shows a sorted list of the ten most expensive individual data transfer operations.
       </li>
       <li class="li">
        Top 10 Kernel Summary  Shows a sorted list of the ten most expensive individual kernel execution operations.
       </li>
       <li class="li">
        From these summary pages, you can determine if the application is bound by kernel execution or data transfer (Context Summary page).
       </li>
       <li class="li">
        If the application is bound by kernel execution, you can determine which device is the bottleneck.
       </li>
       <li class="li">
        From the Kernel Summary page, you can find the name of the kernel with the highest total execution time.
       </li>
       <li class="li">
        Or, from the Top 10 Kernel Summary page, you can find the individual kernel instance with the highest execution time.
       </li>
       <li class="li">
        If the kernel execution on a GPU device is the bottleneck, the GPU performance counters then can be used to investigate the bottleneck inside the kernel.
       </li>
       <li class="li">
        See See Collecting OpenCL GPU Kernel Performance Counters.
       </li>
       <li class="li">
        Collecting OpenCL GPU Kernel Performance Counters for more details.
       </li>
       <li class="li">
        If the application is bound by the data transfers, it is possible to determine the most expensive data transfer type (read, write, copy, or map) in the application from the Context Summary page.
       </li>
       <li class="li">
        You can see if you can minimize this type of data transfer by modifying the algorithm.
       </li>
       <li class="li">
        With help from the Timeline View, you can investigate whether data transfers have been executed in the most efficient way (concurrently with a kernel execution).
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-536178" xml:lang="en-US">
     <a name="50401315_pgfId-536178" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-536178" name="50401315_pgfId-536178" shape="rect">
       1.1.4 API Trace View 1-4
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The API Trace View (See Sample API Trace View) lists all the OpenCL API calls made by the application.
       </li>
       <li class="li">
        Each host thread that makes at least one OpenCL call is listed in a separate tab.
       </li>
       <li class="li">
        Each tab contains a list of all the API calls made by that particular thread.
       </li>
       <li class="li">
        For each call, the list displays the index of the call (representing execution order), the name of the API function, a semi-colon-delimited list of parameters passed to the function, and the value returned by the function.
       </li>
       <li class="li">
        When displaying parameters, the profiler tries to dereference pointers and decode enumeration values in order to give as much information as possible about the data being passed in, or returned from, the function.
       </li>
       <li class="li">
        Double-clicking an item in the API Trace View displays and zooms into that API call in the Host Thread row in the Timeline View.
       </li>
       <li class="li">
        This view lets you analyze and debug the input parameters and output results for each API call.
       </li>
       <li class="li">
        For example, you easily can check that all the API calls are returning CL_SUCCESS , or that all the buffers are created with the correct flags.
       </li>
       <li class="li">
        This view also lets you identify redundant API calls.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-536185" xml:lang="en-US">
     <a name="50401315_pgfId-536185" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-536185" name="50401315_pgfId-536185" shape="rect">
       1.1.5 Collecting OpenCL GPU Kernel Performance Counters 1-5
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        To collect these counters, run a performance counters GPU profile session using the following steps.
       </li>
       <li class="li">
        Select the GPU: Performance Counters Profile Type.
       </li>
       <li class="li">
        Click the Start CodeXL Profiling toolbar button, , to start profiling.
       </li>
       <li class="li">
        Pause / Stop the profiled application using the execution toolbar buttons: .
       </li>
       <li class="li">
        When the profiled application execution is over, CodeXL displays the session.
       </li>
       <li class="li">
        The GPU kernel performance counters can be used to find possible bottlenecks in the kernel execution.
       </li>
       <li class="li">
        You can find the list of performance counters supported by AMD Radeon™ GPUs in the tool documentation.
       </li>
       <li class="li">
        Once the trace data has been used to discover which kernel is most in need of optimization, you can collect the GPU performance counters to drill down into the kernel execution on a GPU device.
       </li>
       <li class="li">
        Using the performance counters, we can: Find the number of resources (general-purpose registers, local memory size, and flow control stack size) allocated for the kernel.
       </li>
       <li class="li">
        These resources affect the possible number of in-flight wavefronts in the GPU.
       </li>
       <li class="li">
        A higher number hides data latency better.
       </li>
       <li class="li">
        Determine the number of ALU, as well as global and local memory instructions executed by the GPU.
       </li>
       <li class="li">
        Determine the number of bytes fetched from, and written to, the global memory.
       </li>
       <li class="li">
        Determine the use of the SIMD engines and memory units in the system.
       </li>
       <li class="li">
        View the efficiency of the shader compiler in packing ALU instructions into the VLIW instructions used by AMD GPUs.
       </li>
       <li class="li">
        View any local memory (Local Data Share – LDS) bank conflicts.
       </li>
       <li class="li">
        The Session View (See Example Session View – Performance Counters for a Profile Session) shows the performance counters for a profile session.
       </li>
       <li class="li">
        The output data is recorded in a comma-separated variable format.
       </li>
       <li class="li">
        You also can click on the kernel name entry in the “Method” column to view the OpenCL kernel source, AMD Intermediate Language (IL), GPU ISA, or CPU assembly code for that kernel.
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="50401315_pgfId-537554" xml:lang="en-US">
    <a name="50401315_pgfId-537554" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-537554" name="50401315_pgfId-537554" shape="rect">
      1.2 AMD APP KernelAnalyzer2 1-6
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       AMD APP KernelAnalyzer2 analyzes the performance of OpenCL kernels for AMD GPUs.
      </li>
      <li class="li">
       It gives accurate kernel performance estimates and lets you view kernel compilation results and assembly code for multiple GPUs, without requiring actual GPU hardware.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-538360" xml:lang="en-US">
     <a name="50401315_pgfId-538360" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-538360" name="50401315_pgfId-538360" shape="rect">
       1.2.1 Start KernelAnalyzer2 1-6
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        KernelAnalyzer2 is installed along with CodeXL.
       </li>
       <li class="li">
        You also can launch KernelAnalyzer2 directly from the operating system.
       </li>
       <li class="li">
        For Windows: From the Windows program menu, select All Programs ® AMD Developer Tools ® AMD APP KernelAnalyzer2 ® AMD App KernelAnalyzer2.
       </li>
       <li class="li">
        For Linux: Navigate to the KernelAnalyzer2 directory and invoke it: $ cd /opt/AMD/AMDAPPKernelAnalyzerV2/AMDAPP*/x86/ # 32-bit $ cd /opt/AMD/AMDAPPKernelAnalyzerV2/AMDAPP*/x86_64/ # 64-bit $ ./AMDAPPKernelAnalyzer2 Alternatively, you can add the KernelAnalyzer2 directory to your PATH, then invoke it.
       </li>
       <li class="li">
        For Windows or Linux, the KernelAnalyzer2 window appears (See KernelAnalyzer2 Main Window).
       </li>
       <li class="li">
        The window contains three panels: a kernel source panel at top left, a kernel assembly code panel at top right, and a build output/statistics/analysis panel at bottom.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-538414" xml:lang="en-US">
     <a name="50401315_pgfId-538414" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-538414" name="50401315_pgfId-538414" shape="rect">
       1.2.2 Open Kernel Source 1-7
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        To open the kernel source, select File ® Open from the KernelAnalyzer2 toolbar; then, navigate to the kernel source file.
       </li>
       <li class="li">
        For example, you can use the OpenCL source tpAdvectFieldScalar.cl from the Teapot example, which is in: \Program Files (x86)\AMD\CodeXL\Examples\Teapot\res or, in the Linux directory: /opt/AMD/CodeXL/bin/examples/Teapot/AMDTTeaPotLib/AMDTTeaPotLib/res The source file appears in the source panel (See Source Panel With Sample Source File).
       </li>
       <li class="li">
        You also can drag and drop a kernel source into the source panel.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-539373" xml:lang="en-US">
     <a name="50401315_pgfId-539373" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-539373" name="50401315_pgfId-539373" shape="rect">
       1.2.3 Build Options – Choosing Target ASICS 1-8
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The ASICs tab in this window contains a list of devices by series (See KernelAnalyzer2 Build Options).
       </li>
       <li class="li">
        Select the Build Options Window ASICS Tab.
       </li>
       <li class="li">
        Use the checkboxes to select, or deselect, an entire series, or click on a small triangle at left to expand.
       </li>
       <li class="li">
        Click OK to exit from the Build Options window.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-538453" xml:lang="en-US">
     <a name="50401315_pgfId-538453" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-538453" name="50401315_pgfId-538453" shape="rect">
       1.2.4 Build Options – Defining Kernel Compilation Options 1-9
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        You can define specific kernel build options in the source pane (See Specifying Build Options in the Source Pane).
       </li>
       <li class="li">
        For the tpAdvectFieldScalar.cl kernel, enter the following options: -D GRID_NUM_CELLS_X=64 -D GRID_NUM_CELLS_Y=64 -D GRID_NUM_CELLS_Z=64 -D GRID_INV_SPACING=1.000000f -D GRID_SPACING=1.000000f -D GRID_SHIFT_X=6 -D GRID_SHIFT_Y=6 -D GRID_SHIFT_Z=6 -D GRID_STRIDE_Y=64 -D GRID_STRIDE_SHIFT_Y=6 -D GRID_STRIDE_Z=4096 -D GRID_STRIDE_SHIFT_Z=12 -I path_to_example_src Here, path_to_example_src can be: For Windows: \Program Files\AMD\AMD CodeXL\Examples\Teapot\res For Linux: /opt/AMD/CodeXL/bin/examples/Teapot/AMDTTeaPotLib/AMDTTeaPotLib/
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-538468" xml:lang="en-US">
     <a name="50401315_pgfId-538468" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-538468" name="50401315_pgfId-538468" shape="rect">
       1.2.5 Analysis Input Tab 1-9
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The Analysis tab (See Analysis Tab) lets you turn the analysis option on or off.
       </li>
       <li class="li">
        Use this tab to define the input parameters for the analysis.
       </li>
       <li class="li">
        For each kernel, you can set the global and local work size.
       </li>
       <li class="li">
        For a 3D kernel, X, Y, and Z must be supplied.
       </li>
       <li class="li">
        For a 2D kernel, Z must be defined as 1 or 0; for a 1D kernel, both Y and Z must be defined as 0 or 1.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-538477" xml:lang="en-US">
     <a name="50401315_pgfId-538477" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-538477" name="50401315_pgfId-538477" shape="rect">
       1.2.6 Build the Kernel 1-9
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        After setting the build options, press F7 or select Build ® Build, to build the kernel.
       </li>
       <li class="li">
        Compilation output appears in the Output tab.
       </li>
       <li class="li">
        The example in See Sample Compilation Outputshows successful builds (no warnings or errors) for 17 of 17 devices.
       </li>
       <li class="li">
        The right panel displays a drop-down list of kernel names at the top, with tabs below to display the intermediate language (IL) or instruction set architecture (ISA) code for each device.
       </li>
       <li class="li">
        Click on a tab to display it; or double-click to display it in a new window.
       </li>
       <li class="li">
        Right-click in the code pane, and select Save As to save the IL or ISA code as a text file.
       </li>
       <li class="li">
        You can export the output as a binary file with File ® Export Binaries.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-538494" xml:lang="en-US">
     <a name="50401315_pgfId-538494" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-538494" name="50401315_pgfId-538494" shape="rect">
       1.2.7 Build Statistics Tab 1-10
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The statistics tab (See Statistics Tab) gives detailed statistics for each device.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-538501" xml:lang="en-US">
     <a name="50401315_pgfId-538501" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-538501" name="50401315_pgfId-538501" shape="rect">
       1.2.8 The Analysis Tab 1-10
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The Analysis output tab (See Analysis Output Tab) shows the analysis for the selected kernel.
       </li>
       <li class="li">
        The upper section shows the parameters used for the current executions of the simulation, as defined by the user in the Analysis Input tab.
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="50401315_pgfId-537927" xml:lang="en-US">
    <a name="50401315_pgfId-537927" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-537927" name="50401315_pgfId-537927" shape="rect">
      1.3 Analyzing Processor Kernels 1-11
     </a>
    </h3>
    <div class="topic concept nested3" id="50401315_pgfId-446463" xml:lang="en-US">
     <a name="50401315_pgfId-446463" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-446463" name="50401315_pgfId-446463" shape="rect">
       1.3.1 Intermediate Language and GPU Disassembly 1-11
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The AMD Accelerated Parallel Processing software exposes the Intermediate Language (IL) and instruction set architecture (ISA) code generated for OpenCL ™ kernels through the compiler options -save-temps[=prefix] .
       </li>
       <li class="li">
        The AMD Intermediate Language (IL) is an abstract representation for hardware vertex, pixel, and geometry shaders, as well as compute kernels that can be taken as input by other modules implementing the IL.
       </li>
       <li class="li">
        An IL compiler uses an IL shader or kernel in conjunction with driver state information to translate these shaders into hardware instructions or a software emulation layer.
       </li>
       <li class="li">
        For a complete description of IL, see the AMD Intermediate Language (IL) Specification v2.
       </li>
       <li class="li">
        The instruction set architecture (ISA) defines the instructions and formats accessible to programmers and compilers for the AMD GPUs.
       </li>
       <li class="li">
        The Northern Islands-family ISA instructions and microcode are documented in the AMD Northern Islands-Family ISA Instructions and Microcode.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-446467" xml:lang="en-US">
     <a name="50401315_pgfId-446467" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-446467" name="50401315_pgfId-446467" shape="rect">
       1.3.2 Generating IL and ISA Code 1-11
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        In Microsoft Visual Studio, the CodeXL GPU Profiler provides an integrated tool to view IL and ISA code.
       </li>
       <li class="li">
        (The AMD APP KernelAnalyzer2 also can show the IL and ISA code.)
       </li>
       <li class="li">
        After running the Profiler, single-click the name of the kernel for detailed programming and disassembly information.
       </li>
       <li class="li">
        The associated ISA disassembly is shown in a new tab.
       </li>
       <li class="li">
        A drop-down menu provides the option to view the IL, ISA, or source OpenCL for the selected kernel.
       </li>
       <li class="li">
        Developers also can generate IL and ISA code from their OpenCL kernel by setting the environment variable AMD_OCL_BUILD_OPTIONS_APPEND=-save-temps (see See AMD-Developed Supplemental Compiler Options).
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="50401315_pgfId-495738" xml:lang="en-US">
    <a name="50401315_pgfId-495738" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-495738" name="50401315_pgfId-495738" shape="rect">
      1.4 Estimating Performance 1-12
     </a>
    </h3>
    <div class="topic concept nested3" id="50401315_pgfId-446474" xml:lang="en-US">
     <a name="50401315_pgfId-446474" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-446474" name="50401315_pgfId-446474" shape="rect">
       1.4.1 Measuring Execution Time 1-12
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The OpenCL runtime provides a built-in mechanism for timing the execution of kernels by setting the CL_QUEUE_PROFILING_ENABLE flag when the queue is created.
       </li>
       <li class="li">
        Once profiling is enabled, the OpenCL runtime automatically records timestamp information for every kernel and memory operation submitted to the queue.
       </li>
       <li class="li">
        OpenCL provides four timestamps: CL_PROFILING_COMMAND_QUEUED – Indicates when the command is enqueued into a command-queue on the host.
       </li>
       <li class="li">
        This is set by the OpenCL runtime when the user calls an clEnqueue* function.
       </li>
       <li class="li">
        CL_PROFILING_COMMAND_SUBMIT – Indicates when the command is submitted to the device.
       </li>
       <li class="li">
        For AMD GPU devices, this time is only approximately defined and is not detailed in this section.
       </li>
       <li class="li">
        CL_PROFILING_COMMAND_START – Indicates when the command starts execution on the requested device.
       </li>
       <li class="li">
        CL_PROFILING_COMMAND_END – Indicates when the command finishes execution on the requested device.
       </li>
       <li class="li">
        The sample code below shows how to compute the kernel execution time (End-Start): The CodeXL GPU Profiler also can record the execution time for a kernel automatically.
       </li>
       <li class="li">
        The Kernel Time metric reported in the Profiler output uses the built-in OpenCL timing capability and reports the same result as the kernelExecTimeNs calculation shown above.
       </li>
       <li class="li">
        Another interesting metric to track is the kernel launch time (Start – Queue).
       </li>
       <li class="li">
        The kernel launch time includes both the time spent in the user application (after enqueuing the command, but before it is submitted to the device), as well as the time spent in the runtime to launch the kernel.
       </li>
       <li class="li">
        For CPU devices, the kernel launch time is fast (tens of μ s), but for discrete GPU devices it can be several hundred μ s. Enabling profiling on a command queue adds approximately 10 μ s to 40 μ s overhead to all clEnqueue calls.
       </li>
       <li class="li">
        Much of the profiling overhead affects the start time; thus, it is visible in the launch time.
       </li>
       <li class="li">
        Be careful when interpreting this metric.
       </li>
       <li class="li">
        To reduce the launch overhead, the AMD OpenCL runtime combines several command submissions into a batch.
       </li>
       <li class="li">
        Commands submitted as batch report similar start times and the same end time.
       </li>
       <li class="li">
        Measure performance of your test with CPU counters.
       </li>
       <li class="li">
        Do not use OCL profiling.
       </li>
       <li class="li">
        To determine if an application is executed asynchonically, build a dependent execution with OCL events.
       </li>
       <li class="li">
        This is a “generic” solution; however, there is an exception when you can enable profiling and have overlap transfers.
       </li>
       <li class="li">
        DRMDMA engines do not support timestamps (“GPU counters”).
       </li>
       <li class="li">
        To get OCL profiling data, the runtime must synchronize the main command processor (CP) with the DMA engine; this disables overlap.
       </li>
       <li class="li">
        Note, however, that Southern Islands has two independent main CPs and runtime pairs them with DMA engines.
       </li>
       <li class="li">
        So, the application can still execute kernels on one CP, while another is synced with a DRM engine for profiling; this lets you profile it with APP or OCL profiling.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-451445" xml:lang="en-US">
     <a name="50401315_pgfId-451445" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-451445" name="50401315_pgfId-451445" shape="rect">
       1.4.2 Using the OpenCL timer with Other System Timers 1-13
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The resolution of the timer, given in ns, can be obtained from: AMD CPUs and GPUs report a timer resolution of 1 ns.
       </li>
       <li class="li">
        AMD OpenCL devices are required to correctly track time across changes in frequency and power states.
       </li>
       <li class="li">
        Also, the AMD OpenCL SDK uses the same time-domain for all devices in the platform; thus, the profiling timestamps can be directly compared across the CPU and GPU devices.
       </li>
       <li class="li">
        The sample code below can be used to read the current value of the OpenCL timer clock.
       </li>
       <li class="li">
        The clock is the same routine used by the AMD OpenCL runtime to generate the profiling timestamps.
       </li>
       <li class="li">
        This function is useful for correlating other program events with the OpenCL profiling timestamps.
       </li>
       <li class="li">
        Normal CPU time-of-day routines can provide a rough measure of the elapsed time of a GPU kernel.
       </li>
       <li class="li">
        GPU kernel execution is non-blocking, that is, calls to enqueue*Kernel return to the CPU before the work on the GPU is finished.
       </li>
       <li class="li">
        For an accurate time value, ensure that the GPU is finished.
       </li>
       <li class="li">
        In OpenCL, you can force the CPU to wait for the GPU to become idle by inserting calls to clFinish() before and after the sequence you want to time; this increases the timing accuracy of the CPU routines.
       </li>
       <li class="li">
        The routine clFinish() blocks the CPU until all previously enqueued OpenCL commands have finished.
       </li>
       <li class="li">
        For more information, see section 5.9, “Profiling Operations on Memory Objects and Kernels,” of the OpenCL 1.0 Specification.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-446494" xml:lang="en-US">
     <a name="50401315_pgfId-446494" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-446494" name="50401315_pgfId-446494" shape="rect">
       1.4.3 Estimating Memory Bandwidth 1-14
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The memory bandwidth required by a kernel is perhaps the most important performance consideration.
       </li>
       <li class="li">
        To calculate this: Effective Bandwidth = (Br + Bw)/T where: Br = total number of bytes read from global memory.
       </li>
       <li class="li">
        Bw = total number of bytes written to global memory.
       </li>
       <li class="li">
        T = time required to run kernel, specified in nanoseconds.
       </li>
       <li class="li">
        If B r and B w are specified in bytes, and T in ns, the resulting effective bandwidth is measured in GB/s, which is appropriate for current CPUs and GPUs for which the peak bandwidth range is 20-260 GB/s.
       </li>
       <li class="li">
        Computing B r and B w requires a thorough understanding of the kernel algorithm; it also can be a highly effective way to optimize performance.
       </li>
       <li class="li">
        For illustration purposes, consider a simple matrix addition: each element in the two source arrays is read once, added together, then stored to a third array.
       </li>
       <li class="li">
        The effective bandwidth for a 1024×1024 matrix addition is calculated as: B r = 2 x (1024 x 1024 x 4 bytes) = 8388608 bytes ;; 2 arrays, 1024×1024, each element 4-byte float B w = 1 x (1024 x 1024 x 4 bytes) = 4194304 bytes ;; 1 array, 1024×1024, each element 4-byte float.
       </li>
       <li class="li">
        If the elapsed time for this copy as reported by the profiling timers is 1000000 ns (1 million ns, or .001 sec), the effective bandwidth is: (Br+Bw)/T = (8388608+4194304)/1000000 = 12.6GB/s The CodeXL GPU Profiler can report the number of dynamic instructions per thread that access global memory through the FetchInsts and WriteInsts counters.
       </li>
       <li class="li">
        The Fetch and Write reports average the per-thread counts; these can be fractions if the threads diverge.
       </li>
       <li class="li">
        The Profiler also reports the dimensions of the global NDRange for the kernel in the GlobalWorkSize field.
       </li>
       <li class="li">
        The total number of threads can be determined by multiplying together the three components of the range.
       </li>
       <li class="li">
        If all (or most) global accesses are the same size, the counts from the Profiler and the approximate size can be used to estimate Br and Bw: Br = Fetch * GlobalWorkitems * Size Bw = Write * GlobalWorkitems * Element Size where GlobalWorkitems is the dispatch size.
       </li>
       <li class="li">
        An example Profiler output and bandwidth calculation: WaveFrontSize = 192*144*1 = 27648 global work items.
       </li>
       <li class="li">
        In this example, assume we know that all accesses in the kernel are four bytes; then, the bandwidth can be calculated as: Br = 70.8 * 27648 * 4 = 7829914 bytes Bw = 0.5 * 27648 * 4 = 55296 bytes The bandwidth then can be calculated as: (Br + Bw)/T = (7829914 bytes + 55296 bytes) / .9522 ms / 1000000 = 8.2 GB/s
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="50401315_pgfId-495909" xml:lang="en-US">
    <a name="50401315_pgfId-495909" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-495909" name="50401315_pgfId-495909" shape="rect">
      1.5 OpenCL Memory Objects 1-15
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       This section explains the AMD OpenCL runtime policy for memory objects.
      </li>
      <li class="li">
       It also recommends best practices for best performance.
      </li>
      <li class="li">
       OpenCL uses memory objects to pass data to kernels.
      </li>
      <li class="li">
       These can be either buffers or images.
      </li>
      <li class="li">
       Space for these is managed by the runtime, which uses several types of memory, each with different performance characteristics.
      </li>
      <li class="li">
       Each type of memory is suitable for a different usage pattern.
      </li>
      <li class="li">
       The following subsections describe: the memory types used by the runtime; how to control which memory kind is used for a memory object; how the runtime maps memory objects for host access; how the runtime performs memory object reading, writing and copying; how best to use command queues; and some recommended usage patterns.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-502813" xml:lang="en-US">
     <a name="50401315_pgfId-502813" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-502813" name="50401315_pgfId-502813" shape="rect">
       1.5.1 Types of Memory Used by the Runtime 1-15
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Memory is used to store memory objects that are accessed by kernels executing on the device, as well as to hold memory object data when they are mapped for access by the host application.
       </li>
       <li class="li">
        This section describes the different memory kinds used by the runtime.
       </li>
       <li class="li">
        See Memory Bandwidth in GB/s (R = read, W = write) in GB/s lists the performance of each memory type given a PCIe3-capable platform and a high-end AMD Radeon  7XXX discrete GPU.
       </li>
       <li class="li">
        In See Memory Bandwidth in GB/s (R = read, W = write) in GB/s, when host memory is accessed by the GPU shader, it is of type CL_MEM_ALLOC_HOST_PTR .
       </li>
       <li class="li">
        When GPU memory is accessed by the CPU, it is of type CL_MEM_PERSISTENT_MEM_AMD .
       </li>
       <li class="li">
        Host memory and device memory in the above table consists of one of the subtypes given below.
       </li>
      </ul>
     </div>
     <div class="topic concept nested4" id="50401315_pgfId-532479" xml:lang="en-US">
      <a name="50401315_pgfId-532479" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-532479" name="50401315_pgfId-532479" shape="rect">
        Host Memory 1-16
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         This regular CPU memory can be access by the CPU at full memory bandwidth; however, it is not directly accessible by the GPU.
        </li>
        <li class="li">
         For the GPU to transfer host memory to device memory (for example, as a parameter to clEnqueueReadBuffer or clEnqueueWriteBuffer ), it first must be pinned (see section See Pinned Host Memory).
        </li>
        <li class="li">
         Pinning takes time, so avoid incurring pinning costs where CPU overhead must be avoided.
        </li>
        <li class="li">
         When host memory is copied to device memory, the OpenCL runtime uses the following transfer methods.
        </li>
        <li class="li">
         &lt;=32 kB: For transfers from the host to device, the data is copied by the CPU to a runtime pinned host memory buffer, and the DMA engine transfers the data to device memory.
        </li>
        <li class="li">
         The opposite is done for transfers from the device to the host.
        </li>
        <li class="li">
         &gt;32 kB and &lt;=16 MB: The host memory physical pages containing the data are pinned, the GPU DMA engine is used, and the pages then are unpinned.
        </li>
        <li class="li">
         &gt;16 MB: Runtime pins host memory in stages of 16 MB blocks and transfer data to the device using the GPU DMA engine.
        </li>
        <li class="li">
         Double buffering for pinning is used to overlap the pinning cost of each 16 MB block with the DMA transfer.
        </li>
        <li class="li">
         Due to the cost of copying to staging buffers, or pinning/unpinning host memory, host memory does not offer the best transfer performance.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401315_pgfId-502946" xml:lang="en-US">
      <a name="50401315_pgfId-502946" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-502946" name="50401315_pgfId-502946" shape="rect">
        Pinned Host Memory 1-16
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         This is host memory that the operating system has bound to a fixed physical address and that the operating system ensures is resident.
        </li>
        <li class="li">
         The CPU can access pinned host memory at full memory bandwidth.
        </li>
        <li class="li">
         The runtime limits the total amount of pinned host memory that can be used for memory objects.
        </li>
        <li class="li">
         (See See Placement, for information about pinning memory.
        </li>
        <li class="li">
         If the runtime knows the data is in pinned host memory, it can be transferred to, and from, device memory without requiring staging buffers or having to perform pinning/unpinning on each transfer.
        </li>
        <li class="li">
         This offers improved transfer performance.
        </li>
        <li class="li">
         Currently, the runtime recognizes only data that is in pinned host memory for operation arguments that are memory objects it has allocated in pinned host memory.
        </li>
        <li class="li">
         For example, the buffer argument of clEnqueueReadBuffer / clEnqueueWriteBuffer and image argument of clEnqueueReadImage / clEnqueueWriteImage .
        </li>
        <li class="li">
         It does not detect that the ptr arguments of these operations addresses pinned host memory, even if they are the result of clEnqueueMapBuffer / clEnqueueMapImage on a memory object that is in pinned host memory.
        </li>
        <li class="li">
         The runtime can make pinned host memory directly accessible from the GPU.
        </li>
        <li class="li">
         Like regular host memory, the CPU uses caching when accessing pinned host memory.
        </li>
        <li class="li">
         Thus, GPU accesses must use the CPU cache coherency protocol when accessing.
        </li>
        <li class="li">
         For discrete devices, the GPU access to this memory is through the PCIe bus, which also limits bandwidth.
        </li>
        <li class="li">
         For APU devices that do not have the PCIe overhead, GPU access is significantly slower than accessing device-visible host memory (see section See Device-Visible Host Memory), which does not use the cache coherency protocol.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401315_pgfId-503174" xml:lang="en-US">
      <a name="50401315_pgfId-503174" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-503174" name="50401315_pgfId-503174" shape="rect">
        Device-Visible Host Memory 1-17
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The runtime allocates a limited amount of pinned host memory that is accessible by the GPU without using the CPU cache coherency protocol.
        </li>
        <li class="li">
         This allows the GPU to access the memory at a higher bandwidth than regular pinned host memory.
        </li>
        <li class="li">
         A portion of this memory is also configured to be accessible by the CPU as uncached memory.
        </li>
        <li class="li">
         Thus, reads by the CPU are significantly slower than those from regular host memory.
        </li>
        <li class="li">
         However, these pages are also configured to use the memory system write combining buffers.
        </li>
        <li class="li">
         The size, alignment, and number of write combining buffers is chip-set dependent.
        </li>
        <li class="li">
         Typically, there are 4 to 8 buffers of 64 bytes, each aligned to start on a 64-byte memory address.
        </li>
        <li class="li">
         These allow writes to adjacent memory locations to be combined into a single memory access.
        </li>
        <li class="li">
         This allows CPU streaming writes to perform reasonably well.
        </li>
        <li class="li">
         Scattered writes that do not fill the write combining buffers before they have to be flushed do not perform as well.
        </li>
        <li class="li">
         APU devices have no device memory and use device-visible host memory for their global device memory.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401315_pgfId-503307" xml:lang="en-US">
      <a name="50401315_pgfId-503307" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-503307" name="50401315_pgfId-503307" shape="rect">
        Device Memory 1-17
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Discrete GPU devices have their own dedicated memory, which provides the highest bandwidth for GPU access.
        </li>
        <li class="li">
         The CPU cannot directly access device memory on a discrete GPU (except for the host-visible device memory portion described in section See Host-Visible Device Memory).
        </li>
        <li class="li">
         On an APU, the system memory is shared between the GPU and the CPU; it is visible by either the CPU or the GPU at any given time.
        </li>
        <li class="li">
         A significant benefit of this is that buffers can be zero copied between the devices by using map/unmap operations to logically move the buffer between the CPU and the GPU address space.
        </li>
        <li class="li">
         (Note that in the system BIOS at boot time, it is possible to allocate the size of the frame buffer.
        </li>
        <li class="li">
         This section of memory is divided into two parts, one of which is invisible to the CPU.
        </li>
        <li class="li">
         Thus, not all system memory supports zero copy.
        </li>
        <li class="li">
         See See OpenCL Memory Object Properties, specifically the Default row.)
        </li>
        <li class="li">
         See See Mapping, for more information on zero copy.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401315_pgfId-503175" xml:lang="en-US">
      <a name="50401315_pgfId-503175" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-503175" name="50401315_pgfId-503175" shape="rect">
        Host-Visible Device Memory 1-18
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         A limited portion of discrete GPU device memory is configured to be directly accessible by the CPU.
        </li>
        <li class="li">
         It can be accessed by the GPU at full bandwidth, but CPU access is over the PCIe bus; thus, it is much slower that host memory bandwidth.
        </li>
        <li class="li">
         The memory is mapped into the CPU address space as uncached, but using the memory system write combining buffers.
        </li>
        <li class="li">
         This results in slow CPU reads and scattered writes, but streaming CPU writes perform much better because they reduce PCIe overhead.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-503627" xml:lang="en-US">
     <a name="50401315_pgfId-503627" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-503627" name="50401315_pgfId-503627" shape="rect">
       1.5.2 Placement 1-18
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Every OpenCL memory object has a location that is defined by the flags passed to clCreateBuffer / clCreateImage .
       </li>
       <li class="li">
        A memory object can be located either on a device, or (as of SDK 2.4) it can be located on the host and accessed directly by all the devices.
       </li>
       <li class="li">
        The Location column of See OpenCL Memory Object Properties gives the memory type used for each of the allocation flag values for different kinds of devices.
       </li>
       <li class="li">
        When a device kernel is executed, it accesses the contents of memory objects from this location.
       </li>
       <li class="li">
        The performance of these accesses is determined by the memory kind used.
       </li>
       <li class="li">
        An OpenCL context can have multiple devices, and a memory object that is located on a device has a location on each device.
       </li>
       <li class="li">
        To avoid over-allocating device memory for memory objects that are never used on that device, space is not allocated until first used on a device-by-device basis.
       </li>
       <li class="li">
        For this reason, the first use of a memory object after it is created can be slower than subsequent uses.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-503571" xml:lang="en-US">
     <a name="50401315_pgfId-503571" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-503571" name="50401315_pgfId-503571" shape="rect">
       1.5.3 Memory Allocation 1-19
      </a>
     </h3>
     <div class="topic concept nested4" id="50401315_pgfId-520796" xml:lang="en-US">
      <a name="50401315_pgfId-520796" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-520796" name="50401315_pgfId-520796" shape="rect">
        Using the CPU 1-19
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Create memory objects with CL_MEM_ALLOC_HOST_PTR , and use map / unmap ; do not use read / write .
        </li>
        <li class="li">
         The reason for this is that if the object is created with CL_MEM_USE_HOST_PTR the CPU is running the kernel on the buffer provided by the application (a hack that all vendors use).
        </li>
        <li class="li">
         This results in zero copy between the CPU and the application buffer; the kernel updates the application buffer, and in this case a map / unmap is actually a no-op.
        </li>
        <li class="li">
         Also, when allocating the buffer on the host, ensure that it is created with the correct alignment.
        </li>
        <li class="li">
         For example, a buffer to be used as float4* must be 128-bit aligned.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401315_pgfId-520798" xml:lang="en-US">
      <a name="50401315_pgfId-520798" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-520798" name="50401315_pgfId-520798" shape="rect">
        Using Both CPU and GPU Devices, or using an APU Device 1-20
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         When creating memory objects, create them with CL_MEM_USE_PERSISTENT_MEM_AMD .
        </li>
        <li class="li">
         This enables the zero copy feature, as explained in See Using the CPU.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401315_pgfId-520800" xml:lang="en-US">
      <a name="50401315_pgfId-520800" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-520800" name="50401315_pgfId-520800" shape="rect">
        Buffers vs Images 1-20
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Unlike GPUs, CPUs do not contain dedicated hardware (samplers) for accessing images.
        </li>
        <li class="li">
         Instead, image access is emulated in software.
        </li>
        <li class="li">
         Thus, a developer may prefer using buffers instead of images if no sampling operation is needed.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401315_pgfId-521010" xml:lang="en-US">
      <a name="50401315_pgfId-521010" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-521010" name="50401315_pgfId-521010" shape="rect">
        Choosing Execution Dimensions 1-20
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Note the following guidelines.
        </li>
        <li class="li">
         Make the number of work-groups a multiple of the number of logical CPU cores (device compute units) for maximum use.
        </li>
        <li class="li">
         When work-groups number exceed the number of CPU cores, the CPU cores execute the work-groups sequentially.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-520762" xml:lang="en-US">
     <a name="50401315_pgfId-520762" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-520762" name="50401315_pgfId-520762" shape="rect">
       1.5.4 Mapping 1-20
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The host application can use clEnqueueMapBuffer / clEnqueueMapImage to obtain a pointer that can be used to access the memory object data.
       </li>
       <li class="li">
        When finished accessing, clEnqueueUnmapMemObject must be used to make the data available to device kernel access.
       </li>
       <li class="li">
        When a memory object is located on a device, the data either can be transferred to, and from, the host, or (as of SDK 2.4) be accessed directly from the host.
       </li>
       <li class="li">
        Memory objects that are located on the host, or located on the device but accessed directly by the host, are termed zero copy memory objects.
       </li>
       <li class="li">
        The data is never transferred, but is accessed directly by both the host and device.
       </li>
       <li class="li">
        Memory objects that are located on the device and transferred to, and from, the device when mapped and unmapped are termed copy memory objects.
       </li>
       <li class="li">
        The Map Mode column of See OpenCL Memory Object Properties specifies the transfer mode used for each kind of memory object, and the Map Location column indicates the kind of memory referenced by the pointer returned by the map operations.
       </li>
      </ul>
     </div>
     <div class="topic concept nested4" id="50401315_pgfId-503784" xml:lang="en-US">
      <a name="50401315_pgfId-503784" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-503784" name="50401315_pgfId-503784" shape="rect">
        Zero Copy Memory Objects 1-20
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         CL_MEM_USE_PERSISTENT_MEM_AMD , CL_MEM_USE_HOST_PTR , and CL_MEM_ALLOC_HOST_PTR support zero copy memory objects.
        </li>
        <li class="li">
         The first provides device-resident zero copy memory objects; the other two provide host-resident zero copy memory objects.
        </li>
        <li class="li">
         Zero copy memory objects can be used by an application to optimize data movement.
        </li>
        <li class="li">
         When clEnqueueMapBuffer / clEnqueueMapImage / clEnqueueUnmapMemObject are used, no runtime transfers are performed, and the operations are very fast; however, the runtime can return a different pointer value each time a zero copy memory object is mapped.
        </li>
        <li class="li">
         Note that only images created with CL_MEM_USE_PERSISTENT_MEM_AMD can be zero copy.
        </li>
        <li class="li">
         From Southern Island on, devices support zero copy memory objects under Linux; however, only images created with CL_MEM_USE_PERSISTENT_MEM_AMD can be zero copy.
        </li>
        <li class="li">
         Zero copy host resident memory objects can boost performance when host memory is accessed by the device in a sparse manner or when a large host memory buffer is shared between multiple devices and the copies are too expensive.
        </li>
        <li class="li">
         When choosing this, the cost of the transfer must be greater than the extra cost of the slower accesses.
        </li>
        <li class="li">
         Streaming writes by the host to zero copy device resident memory objects are about as fast as the transfer rates, so this can be a good choice when the host does not read the memory object to avoid the host having to make a copy of the data to transfer.
        </li>
        <li class="li">
         Memory objects requiring partial updates between kernel executions can also benefit.
        </li>
        <li class="li">
         If the contents of the memory object must be read by the host, use clEnqueueCopyBuffer to transfer the data to a separate CL_MEM_ALLOC_HOST_PTR buffer.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401315_pgfId-504154" xml:lang="en-US">
      <a name="50401315_pgfId-504154" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-504154" name="50401315_pgfId-504154" shape="rect">
        Copy Memory Objects 1-21
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         For memory objects with copy map mode, the memory object location is on the device, and it is transferred to, and from, the host when clEnqueueMapBuffer / clEnqueueMapImage / clEnqueueUnmapMemObject are called.
        </li>
        <li class="li">
         See Transfer policy on clEnqueueMapBuffer / clEnqueueMapImage / clEnqueueUnmapMemObject for Copy Memory Objects shows how the map_flags argument affects transfers.
        </li>
        <li class="li">
         The runtime transfers only the portion of the memory object requested in the offset and cb arguments.
        </li>
        <li class="li">
         When accessing only a portion of a memory object, only map that portion for improved performance.
        </li>
        <li class="li">
         For default memory objects, the pointer returned by clEnqueueMapBuffer / clEnqueueMapImage may not be to the same memory area each time because different runtime buffers may be used.
        </li>
        <li class="li">
         For CL_MEM_USE_HOST_PTR and CL_MEM_ALLOC_HOST_PTR the same map location is used for all maps; thus, the pointer returned is always in the same memory area.
        </li>
        <li class="li">
         For other copy memory objects, the pointer returned may not always be to the same memory region.
        </li>
        <li class="li">
         For CL_MEM_USE_HOST_PTR and the CL_MEM_ALLOC_HOST_PTR cases that use copy map mode, the runtime tracks if the map location contains an up-to-date copy of the memory object contents and avoids doing a transfer from the device when mapping as CL_MAP_READ .
        </li>
        <li class="li">
         This determination is based on whether an operation such as clEnqueueWriteBuffer / clEnqueueCopyBuffer or a kernel execution has modified the memory object.
        </li>
        <li class="li">
         If a memory object is created with CL_MEM_READ_ONLY , then a kernel execution with the memory object as an argument is not considered as modifying the memory object.
        </li>
        <li class="li">
         Default memory objects cannot be tracked because the map location changes between map calls; thus, they are always transferred on the map.
        </li>
        <li class="li">
         For CL_MEM_USE_HOST_PTR , clCreateBuffer / clCreateImage pins the host memory passed to the host_ptr argument.
        </li>
        <li class="li">
         It is unpinned when the memory object is deleted.
        </li>
        <li class="li">
         To minimize pinning costs, align the memory to 4KiB.
        </li>
        <li class="li">
         This avoids the runtime having to pin/unpin on every map/unmap transfer, but does add to the total amount of pinned memory.
        </li>
        <li class="li">
         For CL_MEM_USE_HOST_PTR , the host memory passed as the ptr argument of clCreateBuffer / clCreateImage is used as the map location.
        </li>
        <li class="li">
         As mentioned in section See Host Memory, host memory transfers incur considerable cost in pinning/unpinning on every transfer.
        </li>
        <li class="li">
         If used, ensure the memory aligned to the data type size used in the kernels.
        </li>
        <li class="li">
         If host memory that is updated once is required, use CL_MEM_ALLOC_HOST_PTR with the CL_MEM_COPY_HOST_PTR flag instead.
        </li>
        <li class="li">
         If device memory is needed, use CL_MEM_USE_PERSISTENT_MEM_AMD and clEnqueueWriteBuffer .
        </li>
        <li class="li">
         If CL_MEM_COPY_HOST_PTR is specified with CL_MEM_ALLOC_HOST_PTR when creating a memory object, the memory is allocated in pinned host memory and initialized with the passed data.
        </li>
        <li class="li">
         For other kinds of memory objects, the deferred allocation means the memory is not yet allocated on a device, so the runtime has to copy the data into a temporary runtime buffer.
        </li>
        <li class="li">
         The memory is allocated on the device when the device first accesses the resource.
        </li>
        <li class="li">
         At that time, any data that must be transferred to the resource is copied.
        </li>
        <li class="li">
         For example, this would apply when a buffer was allocated with the flag CL_MEM_COPY_HOST_PTR .
        </li>
        <li class="li">
         Using CL_MEM_COPY_HOST_PTR for these buffers is not recommended because of the extra copy.
        </li>
        <li class="li">
         Instead, create the buffer without CL_MEM_COPY_HOST_PTR , and initialize with clEnqueueWriteBuffer / clEnqueueWriteImage .
        </li>
        <li class="li">
         When images are transferred, additional costs are involved because the image must be converted to, and from, linear address mode for host access.
        </li>
        <li class="li">
         The runtime does this by executing kernels on the device.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-504422" xml:lang="en-US">
     <a name="50401315_pgfId-504422" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-504422" name="50401315_pgfId-504422" shape="rect">
       1.5.5 Reading, Writing, and Copying 1-23
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        There are numerous OpenCL commands to read, write, and copy buffers and images.
       </li>
       <li class="li">
        The runtime performs transfers depending on the memory kind of the source and destination.
       </li>
       <li class="li">
        When transferring between host memory and device memory the methods described in section See Host Memory, are used.
       </li>
       <li class="li">
        Memcpy is used to transferring between the various kinds of host memory, this may be slow if reading from device visible host memory, as described in section See Device-Visible Host Memory.
       </li>
       <li class="li">
        Finally, device kernels are used to copy between device memory.
       </li>
       <li class="li">
        For images, device kernels are used to convert to and from the linear address mode when necessary.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-504431" xml:lang="en-US">
     <a name="50401315_pgfId-504431" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-504431" name="50401315_pgfId-504431" shape="rect">
       1.5.6 Command Queue 1-23
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        It is best to use non-blocking commands to allow multiple commands to be queued before the command queue is flushed to the GPU.
       </li>
       <li class="li">
        This sends larger batches of commands, which amortizes the cost of preparing and submitting work to the GPU.
       </li>
       <li class="li">
        Use event tracking to specify the dependence between operations.
       </li>
       <li class="li">
        It is recommended to queue operations that do not depend of the results of previous copy and map operations.
       </li>
       <li class="li">
        This can help keep the GPU busy with kernel execution and DMA transfers.
       </li>
       <li class="li">
        Note that if a non-blocking copy or map is queued, it does not start until the command queue is flushed.
       </li>
       <li class="li">
        Use clFlush if necessary, but avoid unnecessary flushes because they cause small command batching.
       </li>
       <li class="li">
        For Southern Islands and later, devices support at least two hardware compute queues.
       </li>
       <li class="li">
        That allows an application to increase the throughput of small dispatches with two command queues for asynchronous submission and possibly execution.
       </li>
       <li class="li">
        The hardware compute queues are selected in the following order: first queue = even OCL command queues, second queue = odd OCL queues.
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="50401315_pgfId-502559" xml:lang="en-US">
    <a name="50401315_pgfId-502559" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-502559" name="50401315_pgfId-502559" shape="rect">
      1.6 OpenCL Data Transfer Optimization 1-23
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       The AMD OpenCL implementation offers several optimized paths for data transfer to, and from, the device.
      </li>
      <li class="li">
       The following chapters describe buffer and image paths, as well as how they map to common application scenarios.
      </li>
      <li class="li">
       To find out where the application’s buffers are stored (and understand how the data transfer behaves), use the CodeXL GPU Profiler API Trace View, and look at the tool tips of the clEnqueueMapBuffer calls.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-525051" xml:lang="en-US">
     <a name="50401315_pgfId-525051" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-525051" name="50401315_pgfId-525051" shape="rect">
       1.6.1 Definitions 1-24
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Deferred allocation — The CL runtime attempts to minimize resource consumption by delaying buffer allocation until first use.
       </li>
       <li class="li">
        As a side effect, the first accesses to a buffer may be more expensive than subsequent accesses.
       </li>
       <li class="li">
        Peak interconnect bandwidth — As used in the text below, this is the transfer bandwidth between host and device that is available under optimal conditions at the application level.
       </li>
       <li class="li">
        It is dependent on the type of interconnect, the chipset, and the graphics chip.
       </li>
       <li class="li">
        As an example, a high-performance PC with a PCIe 3.0 16x bus and a GCN architecture (AMD Radeon  HD 7XXX series) graphics card has a nominal interconnect bandwidth of 16 GB/s.
       </li>
       <li class="li">
        Pinning — When a range of host memory is prepared for transfer to the GPU, its pages are locked into system memory.
       </li>
       <li class="li">
        This operation is called pinning; it can impose a high cost, proportional to the size of the memory range.
       </li>
       <li class="li">
        One of the goals of optimizing data transfer is to use pre-pinned buffers whenever possible.
       </li>
       <li class="li">
        However, if pre-pinned buffers are used excessively, it can reduce the available system memory and result in excessive swapping.
       </li>
       <li class="li">
        Host side zero copy buffers provide easy access to pre-pinned memory.
       </li>
       <li class="li">
        WC — Write Combine is a feature of the CPU write path to a select region of the address space.
       </li>
       <li class="li">
        Multiple adjacent writes are combined into cache lines (for example, 64 bytes) before being sent to the external bus.
       </li>
       <li class="li">
        This path typically provides fast streamed writes, but slower scattered writes.
       </li>
       <li class="li">
        Depending on the chip set, scattered writes across a graphics interconnect can be very slow.
       </li>
       <li class="li">
        Also, some platforms require multi-core CPU writes to saturate the WC path over an interconnect.
       </li>
       <li class="li">
        Uncached accesses — Host memory and I/O regions can be configured as uncached.
       </li>
       <li class="li">
        CPU read accesses are typically very slow; for example: uncached CPU reads of graphics memory over an interconnect.
       </li>
       <li class="li">
        USWC — Host memory from the Uncached Speculative Write Combine heap can be accessed by the GPU without causing CPU cache coherency traffic.
       </li>
       <li class="li">
        Due to the uncached WC access path, CPU streamed writes are fast, while CPU reads are very slow.
       </li>
       <li class="li">
        On APU devices, this memory provides the fastest possible route for CPU writes followed by GPU reads.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-501699" xml:lang="en-US">
     <a name="50401315_pgfId-501699" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-501699" name="50401315_pgfId-501699" shape="rect">
       1.6.2 Buffers 1-24
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        OpenCL buffers currently offer the widest variety of specialized buffer types and optimized paths, as well as slightly higher transfer performance.
       </li>
      </ul>
     </div>
     <div class="topic concept nested4" id="50401315_pgfId-496787" xml:lang="en-US">
      <a name="50401315_pgfId-496787" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-496787" name="50401315_pgfId-496787" shape="rect">
        Regular Device Buffers 1-24
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Buffers allocated using the flags CL_MEM_READ_ONLY , CL_MEM_WRITE_ONLY , or CL_MEM_READ_WRITE are placed on the GPU device.
        </li>
        <li class="li">
         These buffers can be accessed by a GPU kernel at very high bandwidths.
        </li>
        <li class="li">
         For example, on a high-end graphics card, the OpenCL kernel read/write performance is significantly higher than 100 GB/s.
        </li>
        <li class="li">
         When device buffers are accessed by the host through any of the OpenCL read/write/copy and map/unmap API calls, the result is an explicit transfer across the hardware interconnect.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401315_pgfId-497032" xml:lang="en-US">
      <a name="50401315_pgfId-497032" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-497032" name="50401315_pgfId-497032" shape="rect">
        Zero Copy Buffers 1-25
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         AMD APP SDK 2.4 on Windows 7 and Vista introduces a new feature called zero copy buffers.
        </li>
        <li class="li">
         If a buffer is of the zero copy type, the runtime tries to leave its content in place, unless the application explicitly triggers a transfer (for example, through clEnqueueCopyBuffer() ).
        </li>
        <li class="li">
         Depending on its type, a zero copy buffer resides on the host or the device.
        </li>
        <li class="li">
         Independent of its location, it can be accessed directly by the host CPU or a GPU device kernel, at a bandwidth determined by the capabilities of the hardware interconnect.
        </li>
        <li class="li">
         Calling clEnqueueMapBuffer() and clEnqueueUnmapMemObject() on a zero copy buffer is typically a low-cost operation.
        </li>
        <li class="li">
         Since not all possible read and write paths perform equally, check the application scenarios below for recommended usage.
        </li>
        <li class="li">
         To assess performance on a given platform, use the BufferBandwidth sample.
        </li>
        <li class="li">
         If a given platform supports the zero copy feature, the following buffer types are available: The CL_MEM_ALLOC_HOST_PTR and CL_MEM_USE_HOST_PTR buffers are: zero copy buffers that resides on the host.
        </li>
        <li class="li">
         directly accessible by the host at host memory bandwidth.
        </li>
        <li class="li">
         directly accessible by the device across the interconnect.
        </li>
        <li class="li">
         a pre-pinned sources or destinations for CL read, write, and copy commands into device memory at peak interconnect bandwidth.
        </li>
        <li class="li">
         Note that buffers created with the flag CL_MEM_ALLOC_HOST_PTR together with CL_MEM_READ_ONLY may reside in uncached write-combined memory.
        </li>
        <li class="li">
         As a result, CPU can have high streamed write bandwidth, but low read and potentially low write scatter bandwidth, due to the uncached WC path.
        </li>
        <li class="li">
         The CL_MEM_USE_PERSISTENT_MEM_AMD buffer is a zero copy buffer that resides on the GPU device.
        </li>
        <li class="li">
         directly accessible by the GPU device at GPU memory bandwidth.
        </li>
        <li class="li">
         directly accessible by the host across the interconnect (typically with high streamed write bandwidth, but low read and potentially low write scatter bandwidth, due to the uncached WC path).
        </li>
        <li class="li">
         copyable to, and from, the device at peak interconnect bandwidth using CL read, write, and copy commands.
        </li>
        <li class="li">
         There is a limit on the maximum size per buffer, as well as on the total size of all buffers.
        </li>
        <li class="li">
         This is platform-dependent, limited in size for each buffer, and also for the total size of all buffers of that type (a good working assumption is 64 MB for the per-buffer limit, and 128 MB for the total).
        </li>
        <li class="li">
         Zero copy buffers work well on APU devices.
        </li>
        <li class="li">
         SDK 2.5 introduced an optimization that is of particular benefit on APUs.
        </li>
        <li class="li">
         The runtime uses USWC memory for buffers allocated as CL_MEM_ALLOC_HOST_PTR | CL_MEM_READ_ONLY .
        </li>
        <li class="li">
         On APU systems, this type of zero copy buffer can be written to by the CPU at very high data rates, then handed over to the GPU at minimal cost for equally high GPU read-data rates over the Radeon memory bus.
        </li>
        <li class="li">
         This path provides the highest data transfer rate for the CPU-to-GPU path.
        </li>
        <li class="li">
         The use of multiple CPU cores may be necessary to achieve peak write performance.
        </li>
        <li class="li">
         address = clMapBuffer ( buffer ) memset ( address ) or memcpy ( address ) (if possible, using multiple CPU cores) clEnqueueUnmapMemObject ( buffer ) clEnqueueNDRangeKernel ( buffer ) As this memory is not cacheable, CPU read operations are very slow.
        </li>
        <li class="li">
         This type of buffer also exists on discrete platforms, but transfer performance typically is limited by PCIe bandwidth.
        </li>
        <li class="li">
         Zero copy buffers can provide low latency for small transfers, depending on the transfer path.
        </li>
        <li class="li">
         For small buffers, the combined latency of map/CPU memory access/unmap can be smaller than the corresponding DMA latency.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401315_pgfId-518336" xml:lang="en-US">
      <a name="50401315_pgfId-518336" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-518336" name="50401315_pgfId-518336" shape="rect">
        Pre-pinned Buffers 1-26
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         AMD APP SDK 2.5 introduces a new feature called pre-pinned buffers.
        </li>
        <li class="li">
         This feature is supported on Windows 7, Windows Vista, and Linux.
        </li>
        <li class="li">
         Buffers of type CL_MEM_ALLOC_HOST_PTR or CL_MEM_USE_HOST_PTR are pinned at creation time.
        </li>
        <li class="li">
         These buffers can be used directly as a source or destination for clEnqueueCopyBuffer to achieve peak interconnect bandwidth.
        </li>
        <li class="li">
         Mapped buffers also can be used as a source or destination for clEnqueueRead / WriteBuffer calls, again achieving peak interconnect bandwidth.
        </li>
        <li class="li">
         Note that using CL_MEM_USE_HOST_PTR permits turning an existing user memory region into pre-pinned memory.
        </li>
        <li class="li">
         However, in order to stay on the fast path, that memory must be aligned to 256 bytes.
        </li>
        <li class="li">
         Buffers of type CL_MEM_USE_HOST_PTR remain pre-pinned as long as they are used only for data transfer, but not as kernel arguments.
        </li>
        <li class="li">
         If the buffer is used in a kernel, the runtime creates a cached copy on the device, and subsequent copies are not on the fast path.
        </li>
        <li class="li">
         The same restriction applies to CL_MEM_ALLOC_HOST_PTR allocations under Linux.
        </li>
        <li class="li">
         See usage examples described for various options below.
        </li>
        <li class="li">
         The pre-pinned path is supported for the following calls.
        </li>
        <li class="li">
         clEnqueueRead / WriteBuffer clEnqueueRead / WriteImage clEnqueueRead / WriteBufferRect Offsets into mapped buffer addresses are supported, too.
        </li>
        <li class="li">
         Note that the CL image calls must use pre-pinned mapped buffers on the host side, and not pre-pinned images.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401315_pgfId-517669" xml:lang="en-US">
      <a name="50401315_pgfId-517669" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-517669" name="50401315_pgfId-517669" shape="rect">
        Application Scenarios and Recommended OpenCL Paths 1-27
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The following section describes various application scenarios, and the corresponding paths in the OpenCL API that are known to work well on AMD platforms.
        </li>
        <li class="li">
         The various cases are listed, ordered from generic to more specialized.
        </li>
        <li class="li">
         From an application point of view, two fundamental use cases exist, and they can be linked to the various options, described below.
        </li>
        <li class="li">
         An application wants to transfer a buffer that was already allocated through malloc() or mmap() .
        </li>
        <li class="li">
         In this case, options 2), 3) and 4) below always consist of a memcpy() plus a device transfer.
        </li>
        <li class="li">
         Option 1) does not require a memcpy() .
        </li>
        <li class="li">
         If an application is able to let OpenCL allocate the buffer, options 2) and 4) below can be used to avoid the extra memcpy() .
        </li>
        <li class="li">
         In the case of option 5), memcpy() and transfer are identical.
        </li>
        <li class="li">
         Note that the OpenCL runtime uses deferred allocation to maximize memory resources.
        </li>
        <li class="li">
         This means that a complete roundtrip chain, including data transfer and kernel compute, might take one or two iterations to reach peak performance.
        </li>
        <li class="li">
         A code sample named BufferBandwidth can be used to investigate and benchmark the various transfer options in combination with different buffer types.
        </li>
        <li class="li">
         Option 1 – clEnqueueWriteBuffer() and clEnqueueReadBuffer() This option is the easiest to use on the application side.
        </li>
        <li class="li">
         CL_MEM_USE_HOST_PTR is an ideal choice if the application wants to transfer a buffer that has already been allocated through malloc() or mmap() .
        </li>
        <li class="li">
         There are two ways to use this option.
        </li>
        <li class="li">
         The first uses clEnqueueRead / WriteBuffer on a pre-pinned, mapped host-side buffer: The pinning cost is incurred at step c. Step d does not incur any pinning cost.
        </li>
        <li class="li">
         Typically, an application performs steps a, b, c, and e once.
        </li>
        <li class="li">
         It then repeatedly reads or modifies the data in pinnedMemory, followed by step d. For the second way to use this option, clEnqueueRead / WriteBuffer is used directly on a user memory buffer.
        </li>
        <li class="li">
         The standard clEnqueueRead / Write calls require to pin (lock in memory) memory pages before they can be copied (by the DMA engine).
        </li>
        <li class="li">
         This creates a performance penalty that is proportional to the buffer size.
        </li>
        <li class="li">
         The performance of this path is currently about two-thirds of peak interconnect bandwidth.
        </li>
        <li class="li">
         Option 2 – clEnqueueCopyBuffer() on a pre-pinned host buffer (requires pre-pinned buffer support) This is analogous to Option 1.
        </li>
        <li class="li">
         Performing a CL copy of a pre-pinned buffer to a device buffer (or vice versa) runs at peak interconnect bandwidth.
        </li>
        <li class="li">
         This is followed either by: or by: Since the pinnedBuffer resides in host memory, the clMap() and clUnmap() calls do not result in data transfers, and they are of very low latency.
        </li>
        <li class="li">
         Sparse or dense memory operations by the application take place at host memory bandwidth.
        </li>
        <li class="li">
         Option 3 – clEnqueueMapBuffer() and clEnqueueUnmapMemObject() of a Device Buffer This is a good choice if the application fills in the data on the fly, or requires a pointer for calls to other library functions (such as fread() or fwrite() ).
        </li>
        <li class="li">
         An optimized path exists for regular device buffers; this path provides peak interconnect bandwidth at map/unmap time.
        </li>
        <li class="li">
         For buffers already allocated through malloc() or mmap() , the total transfer cost includes a memcpy() into the mapped device buffer, in addition to the interconnect transfer.
        </li>
        <li class="li">
         Typically, this is slower than option 1), above.
        </li>
        <li class="li">
         The transfer sequence is as follows: The application fills in the host buffer through memset( ptr ) , memcpy ( ptr, srcptr ) , fread( ptr ) , or direct CPU writes.
        </li>
        <li class="li">
         This happens at host memory bandwidth.
        </li>
        <li class="li">
         clEnqueueUnmapMemObject( .., buf, ptr, .. ) The pre-pinned buffer is transferred to the GPU device, at peak interconnect bandwidth.
        </li>
        <li class="li">
         The application reads and processes the data, or executes a memcpy( dstptr, ptr ) , fwrite (ptr) , or similar function.
        </li>
        <li class="li">
         Since the buffer resides in host memory, this happens at host memory bandwidth.
        </li>
        <li class="li">
         clEnqueueUnmapMemObject( .., buf, ptr, .. ) Since the buffer was mapped as read-only, no transfer takes place, and the unmap operation is very low cost.
        </li>
        <li class="li">
         Option 4 – Direct host access to a zero copy device buffer (requires zero copy support) This option allows overlapping of data transfers and GPU compute.
        </li>
        <li class="li">
         It is also useful for sparse write updates under certain constraints.
        </li>
        <li class="li">
         buf = clCreateBuffer ( .., CL_MEM_USE_PERSISTENT_MEM_AMD, .. ) This buffer can be directly accessed by the host CPU, using the uncached WC path.
        </li>
        <li class="li">
         This can take place at the same time the GPU executes a compute kernel.
        </li>
        <li class="li">
         A common double buffering scheme has the kernel process data from one buffer while the CPU fills a second buffer.
        </li>
        <li class="li">
         See the TransferOverlap code sample.
        </li>
        <li class="li">
         A zero copy device buffer can also be used to for sparse updates, such as assembling sub-rows of a larger matrix into a smaller, contiguous block for GPU processing.
        </li>
        <li class="li">
         Due to the WC path, it is a good design choice to try to align writes to the cache line size, and to pick the write block size as large as possible.
        </li>
        <li class="li">
         The application transfers data via memset( ptr ) , memcpy( ptr, srcptr ) , or direct CPU writes.The CPU writes directly across the interconnect into the zero copy device buffer.
        </li>
        <li class="li">
         Depending on the chipset, the bandwidth can be of the same order of magnitude as the interconnect bandwidth, although it typically is lower than peak.
        </li>
        <li class="li">
         clEnqueueUnmapMemObject( .., buf, ptr, .. ) As with the preceding map, this operation is low cost because the buffer continues to reside on the device.
        </li>
        <li class="li">
         clEnqueueReadBuffer( .., buf, ..) or clEnqueueCopyBuffer( .., buf, zero copy host buffer, .. ) .
        </li>
        <li class="li">
         This bypasses slow host reads through the uncached path.
        </li>
        <li class="li">
         Option 5 – Direct GPU access to a zero copy host buffer (requires zero copy support) This option allows direct reads or writes of host memory by the GPU.
        </li>
        <li class="li">
         A GPU kernel can import data from the host without explicit transfer, and write data directly back to host memory.
        </li>
        <li class="li">
         An ideal use is to perform small I/Os straight from the kernel, or to integrate the transfer latency directly into the kernel execution time.
        </li>
        <li class="li">
         buf = clCreateBuffer( .., CL_MEM_ALLOC_HOST_PTR, .. ) The application modifies the data through memset( ptr ) , memcpy( in either direction ) , sparse or dense CPU reads or writes.
        </li>
        <li class="li">
         Since the application is modifying a host buffer, these operations take place at host memory bandwidth.
        </li>
        <li class="li">
         clEnqueueUnmapMemObject( .., buf, ptr, .. ) As with the preceding map, this operation is very low cost because the buffer continues to reside in host memory.
        </li>
        <li class="li">
         The achievable bandwidth depends on the platform and chipset, but can be of the same order of magnitude as the peak interconnect bandwidth.
        </li>
        <li class="li">
         For discrete graphics cards, it is important to note that resulting GPU kernel bandwidth is an order of magnitude lower compared to a kernel accessing a regular device buffer located on the device.
        </li>
       </ul>
      </div>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="50401315_pgfId-531115" xml:lang="en-US">
    <a name="50401315_pgfId-531115" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-531115" name="50401315_pgfId-531115" shape="rect">
      1.7 Using Multiple OpenCL Devices 1-31
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       The AMD OpenCL runtime supports both CPU and GPU devices.
      </li>
      <li class="li">
       This section introduces techniques for appropriately partitioning the workload and balancing it across the devices in the system.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-531120" xml:lang="en-US">
     <a name="50401315_pgfId-531120" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-531120" name="50401315_pgfId-531120" shape="rect">
       1.7.1 CPU and GPU Devices 1-31
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        See CPU and GPU Performance Characteristics lists some key performance characteristics of two exemplary CPU and GPU devices: a quad-core AMD Phenom II X4 processor running at 2.8 GHz, and a mid-range AMD Radeon  HD 7770 GPU running at 1 GHz.
       </li>
       <li class="li">
        The “best” device in each characteristic is highlighted, and the ratio of the best/other device is shown in the final column.
       </li>
       <li class="li">
        The GPU excels at high-throughput: the peak execution rate (measured in FLOPS) is 7X higher than the CPU, and the memory bandwidth is 2.5X higher than the CPU.
       </li>
       <li class="li">
        The GPU also consumes approximately 65% the power of the CPU; thus, for this comparison, the power efficiency in flops/watt is 10X higher.
       </li>
       <li class="li">
        While power efficiency can vary significantly with different devices, GPUs generally provide greater power efficiency (flops/watt) than CPUs because they optimize for throughput and eliminate hardware designed to hide latency.
       </li>
       <li class="li">
        Table 4.5 provides a comparison of the CPU and GPU performance charac-teristics in an AMD A8-4555M “Trinity” APU (19 W, 21 GB/s memory bandwidth).
       </li>
       <li class="li">
        Conversely, CPUs excel at latency-sensitive tasks.
       </li>
       <li class="li">
        For example, an integer add is 10X faster on the CPU than on the GPU.
       </li>
       <li class="li">
        This is a product of both the CPUs higher clock rate (2800 MHz vs 1000 MHz for this comparison), as well as the operation latency; the CPU is optimized to perform an integer add in just one cycle, while the GPU requires four cycles.
       </li>
       <li class="li">
        The CPU also has a latency-optimized path to DRAM, while the GPU optimizes for bandwidth and relies on many in-flight threads to hide the latency.
       </li>
       <li class="li">
        The AMD Radeon  HD 7770 GPU, for example, supports more than 25,000 in-flight work-items and can switch to a new wavefront (containing up to 64 work-items) in a single cycle.
       </li>
       <li class="li">
        The CPU supports only four hardware threads, and thread-switching requires saving and restoring the CPU registers from memory.
       </li>
       <li class="li">
        The GPU requires many active threads to both keep the execution resources busy, as well as provide enough threads to hide the long latency of cache misses.
       </li>
       <li class="li">
        Each GPU wavefront has its own register state, which enables the fast single-cycle switching between threads.
       </li>
       <li class="li">
        Also, GPUs can be very efficient at gather/scatter operations: each work-item can load from any arbitrary address, and the registers are completely decoupled from the other threads.
       </li>
       <li class="li">
        This is substantially more flexible and higher-performing than a classic Vector ALU-style architecture (such as SSE on the CPU), which typically requires that data be accessed from contiguous and aligned memory locations.
       </li>
       <li class="li">
        SSE supports instructions that write parts of a register (for example, MOVLPS and MOVHPS , which write the upper and lower halves, respectively, of an SSE register), but these instructions generate additional microarchitecture dependencies and frequently require additional pack instructions to format the data correctly.
       </li>
       <li class="li">
        In contrast, each GPU thread shares the same program counter with 63 other threads in a wavefront.
       </li>
       <li class="li">
        Divergent control-flow on a GPU can be quite expensive and can lead to significant under-utilization of the GPU device.
       </li>
       <li class="li">
        When control flow substantially narrows the number of valid work-items in a wave-front, it can be faster to use the CPU device.
       </li>
       <li class="li">
        CPUs also tend to provide significantly more on-chip cache than GPUs.
       </li>
       <li class="li">
        In this example, the CPU device contains 512 kB L2 cache/core plus a 6 MB L3 cache that is shared among all cores, for a total of 8 MB of cache.
       </li>
       <li class="li">
        In contrast, the GPU device contains only 128 kB cache shared by the five compute units.
       </li>
       <li class="li">
        The larger CPU cache serves both to reduce the average memory latency and to reduce memory bandwidth in cases where data can be re-used from the caches.
       </li>
       <li class="li">
        Finally, note the approximate 2X difference in kernel launch latency.
       </li>
       <li class="li">
        The GPU launch time includes both the latency through the software stack, as well as the time to transfer the compiled kernel and associated arguments across the PCI-express bus to the discrete GPU.
       </li>
       <li class="li">
        Notably, the launch time does not include the time to compile the kernel.
       </li>
       <li class="li">
        The CPU can be the device-of-choice for small, quick-running problems when the overhead to launch the work on the GPU outweighs the potential speedup.
       </li>
       <li class="li">
        Often, the work size is data-dependent, and the choice of device can be data-dependent as well.
       </li>
       <li class="li">
        For example, an image-processing algorithm may run faster on the GPU if the images are large, but faster on the CPU when the images are small.
       </li>
       <li class="li">
        The differences in performance characteristics present interesting optimization opportunities.
       </li>
       <li class="li">
        Workloads that are large and data parallel can run orders of magnitude faster on the GPU, and at higher power efficiency.
       </li>
       <li class="li">
        Serial or small parallel workloads (too small to efficiently use the GPU resources) often run significantly faster on the CPU devices.
       </li>
       <li class="li">
        In some cases, the same algorithm can exhibit both types of workload.
       </li>
       <li class="li">
        A simple example is a reduction operation such as a sum of all the elements in a large array.
       </li>
       <li class="li">
        The beginning phases of the operation can be performed in parallel and run much faster on the GPU.
       </li>
       <li class="li">
        The end of the operation requires summing together the partial sums that were computed in parallel; eventually, the width becomes small enough so that the overhead to parallelize outweighs the computation cost, and it makes sense to perform a serial add.
       </li>
       <li class="li">
        For these serial operations, the CPU can be significantly faster than the GPU.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-531299" xml:lang="en-US">
     <a name="50401315_pgfId-531299" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-531299" name="50401315_pgfId-531299" shape="rect">
       1.7.2 When to Use Multiple Devices 1-33
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        One of the features of GPU computing is that some algorithms can run substantially faster and at better energy efficiency compared to a CPU device.
       </li>
       <li class="li">
        Also, once an algorithm has been coded in the data-parallel task style for OpenCL, the same code typically can scale to run on GPUs with increasing compute capability (that is more compute units) or even multiple GPUs (with a little more work).
       </li>
       <li class="li">
        For some algorithms, the advantages of the GPU (high computation throughput, latency hiding) are offset by the advantages of the CPU (low latency, caches, fast launch time), so that the performance on either devices is similar.
       </li>
       <li class="li">
        This case is more common for mid-range GPUs and when running more mainstream algorithms.
       </li>
       <li class="li">
        If the CPU and the GPU deliver similar performance, the user can get the benefit of either improved power efficiency (by running on the GPU) or higher peak performance (use both devices).
       </li>
       <li class="li">
        Usually, when the data size is small, it is faster to use the CPU because the start-up time is quicker than on the GPU due to a smaller driver overhead and avoiding the need to copy buffers from the host to the device.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-531308" xml:lang="en-US">
     <a name="50401315_pgfId-531308" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-531308" name="50401315_pgfId-531308" shape="rect">
       1.7.3 Partitioning Work for Multiple Devices 1-34
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        By design, each OpenCL command queue can only schedule work on a single OpenCL device.
       </li>
       <li class="li">
        Thus, using multiple devices requires the developer to create a separate queue for each device, then partition the work between the available command queues.
       </li>
       <li class="li">
        A simple scheme for partitioning work between devices would be to statically determine the relative performance of each device, partition the work so that faster devices received more work, launch all the kernels, and then wait for them to complete.
       </li>
       <li class="li">
        In practice, however, this rarely yields optimal performance.
       </li>
       <li class="li">
        The relative performance of devices can be difficult to determine, in particular for kernels whose performance depends on the data input.
       </li>
       <li class="li">
        Further, the device performance can be affected by dynamic frequency scaling, OS thread scheduling decisions, or contention for shared resources, such as shared caches and DRAM bandwidth.
       </li>
       <li class="li">
        Simple static partitioning algorithms which “guess wrong” at the beginning can result in significantly lower performance, since some devices finish and become idle while the whole system waits for the single, unexpectedly slow device.
       </li>
       <li class="li">
        For these reasons, a dynamic scheduling algorithm is recommended.
       </li>
       <li class="li">
        In this approach, the workload is partitioned into smaller parts that are periodically scheduled onto the hardware.
       </li>
       <li class="li">
        As each device completes a part of the workload, it requests a new part to execute from the pool of remaining work.
       </li>
       <li class="li">
        Faster devices, or devices which work on easier parts of the workload, request new input faster, resulting in a natural workload balancing across the system.
       </li>
       <li class="li">
        The approach creates some additional scheduling and kernel submission overhead, but dynamic scheduling generally helps avoid the performance cliff from a single bad initial scheduling decision, as well as higher performance in real-world system environments (since it can adapt to system conditions as the algorithm runs).
       </li>
       <li class="li">
        Multi-core runtimes, such as Cilk, have already introduced dynamic scheduling algorithms for multi-core CPUs, and it is natural to consider extending these scheduling algorithms to GPUs as well as CPUs.
       </li>
       <li class="li">
        A GPU introduces several new aspects to the scheduling process: Heterogeneous Compute Devices Most existing multi-core schedulers target only homogenous computing devices.
       </li>
       <li class="li">
        When scheduling across both CPU and GPU devices, the scheduler must be aware that the devices can have very different performance characteristics (10X or more) for some algorithms.
       </li>
       <li class="li">
        To some extent, dynamic scheduling is already designed to deal with heterogeneous workloads (based on data input the same algorithm can have very different performance, even when run on the same device), but a system with heterogeneous devices makes these cases more common and more extreme.
       </li>
       <li class="li">
        Here are some suggestions for these situations.
       </li>
       <li class="li">
        The scheduler should support sending different workload sizes to different devices.
       </li>
       <li class="li">
        GPUs typically prefer larger grain sizes, and higher-performing GPUs prefer still larger grain sizes.
       </li>
       <li class="li">
        The scheduler should be conservative about allocating work until after it has examined how the work is being executed.
       </li>
       <li class="li">
        In particular, it is important to avoid the performance cliff that occurs when a slow device is assigned an important long-running task.
       </li>
       <li class="li">
        One technique is to use small grain allocations at the beginning of the algorithm, then switch to larger grain allocations when the device characteristics are well-known.
       </li>
       <li class="li">
        As a special case of the above rule, when the devices are substantially different in performance (perhaps 10X), load-balancing has only a small potential performance upside, and the overhead of scheduling the load probably eliminates the advantage.
       </li>
       <li class="li">
        In the case where one device is far faster than everything else in the system, use only the fast device.
       </li>
       <li class="li">
        The scheduler must balance small-grain-size (which increase the adaptiveness of the schedule and can efficiently use heterogeneous devices) with larger grain sizes (which reduce scheduling overhead).
       </li>
       <li class="li">
        Note that the grain size must be large enough to efficiently use the GPU.
       </li>
       <li class="li">
        Asynchronous Launch OpenCL devices are designed to be scheduled asynchronously from a command-queue.
       </li>
       <li class="li">
        The host application can enqueue multiple kernels, flush the kernels so they begin executing on the device, then use the host core for other work.
       </li>
       <li class="li">
        The AMD OpenCL implementation uses a separate thread for each command-queue, so work can be transparently scheduled to the GPU in the background.
       </li>
       <li class="li">
        Avoid starving the high-performance GPU devices.
       </li>
       <li class="li">
        This can occur if the physical CPU core, which must re-fill the device queue, is itself being used as a device.
       </li>
       <li class="li">
        A simple approach to this problem is to dedicate a physical CPU core for scheduling chores.
       </li>
       <li class="li">
        The device fission extension (see the Extensions appendix in the AMD OpenCL User Guide) can be used to reserve a core for scheduling.
       </li>
       <li class="li">
        For example, on a quad-core device, device fission can be used to create an OpenCL device with only three cores.
       </li>
       <li class="li">
        Another approach is to schedule enough work to the device so that it can tolerate latency in additional scheduling.
       </li>
       <li class="li">
        Here, the scheduler maintains a watermark of uncompleted work that has been sent to the device, and refills the queue when it drops below the watermark.
       </li>
       <li class="li">
        This effectively increase the grain size, but can be very effective at reducing or eliminating device starvation.
       </li>
       <li class="li">
        Developers cannot directly query the list of commands in the OpenCL command queues; however, it is possible to pass an event to each clEnqueue call that can be queried, in order to determine the execution status (in particular the command completion time); developers also can maintain their own queue of outstanding requests.
       </li>
       <li class="li">
        For many algorithms, this technique can be effective enough at hiding latency so that a core does not need to be reserved for scheduling.
       </li>
       <li class="li">
        In particular, algorithms where the work-load is largely known up-front often work well with a deep queue and watermark.
       </li>
       <li class="li">
        Algorithms in which work is dynamically created may require a dedicated thread to provide low-latency scheduling.
       </li>
       <li class="li">
        Data Location Discrete GPUs use dedicated high-bandwidth memory that exists in a separate address space.
       </li>
       <li class="li">
        Moving data between the device address space and the host requires time-consuming transfers over a relatively slow PCI-Express bus.
       </li>
       <li class="li">
        Schedulers should be aware of this cost and, for example, attempt to schedule work that consumes the result on the same device producing it.
       </li>
       <li class="li">
        CPU and GPU devices share the same memory bandwidth, which results in additional interactions of kernel executions.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-531363" xml:lang="en-US">
     <a name="50401315_pgfId-531363" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-531363" name="50401315_pgfId-531363" shape="rect">
       1.7.4 Synchronization Caveats 1-36
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The OpenCL functions that enqueue work ( clEnqueueNDRangeKernel ) merely enqueue the requested work in the command queue; they do not cause it to begin executing.
       </li>
       <li class="li">
        Execution begins when the user executes a synchronizing command, such as clFlush or clWaitForEvents .
       </li>
       <li class="li">
        Enqueuing several commands before flushing can enable the host CPU to batch together the command submission, which can reduce launch overhead.
       </li>
       <li class="li">
        Command-queues that are configured to execute in-order are guaranteed to complete execution of each command before the next command begins.
       </li>
       <li class="li">
        This synchronization guarantee can often be leveraged to avoid explicit clWaitForEvents() calls between command submissions.
       </li>
       <li class="li">
        Using clWaitForEvents() requires intervention by the host CPU and additional synchronization cost between the host and the GPU; by leveraging the in-order queue property, back-to-back kernel executions can be efficiently handled directly on the GPU hardware.
       </li>
       <li class="li">
        AMD Southern Islands GPUs can execute multiple kernels simultaneously when there are no dependencies.
       </li>
       <li class="li">
        The AMD OpenCL implementation spawns a new thread to manage each command queue.
       </li>
       <li class="li">
        Thus, the OpenCL host code is free to manage multiple devices from a single host thread.
       </li>
       <li class="li">
        Note that clFinish is a blocking operation; the thread that calls clFinish blocks until all commands in the specified command-queue have been processed and completed.
       </li>
       <li class="li">
        If the host thread is managing multiple devices, it is important to call clFlush for each command-queue before calling clFinish , so that the commands are flushed and execute in parallel on the devices.
       </li>
       <li class="li">
        Otherwise, the first call to clFinish blocks, the commands on the other devices are not flushed, and the devices appear to execute serially rather than in parallel.
       </li>
       <li class="li">
        For low-latency CPU response, it can be more efficient to use a dedicated spin loop and not call clFinish() Calling clFinish() indicates that the application wants to wait for the GPU, putting the thread to sleep.
       </li>
       <li class="li">
        For low latency, the application should use clFlush() , followed by a loop to wait for the event to complete.
       </li>
       <li class="li">
        This is also true for blocking maps.
       </li>
       <li class="li">
        The application should use non-blocking maps followed by a loop waiting on the event.
       </li>
       <li class="li">
        The following provides sample code for this.
       </li>
       <li class="li">
        if (sleep) { // this puts host thread to sleep, useful if power is a consideration or overhead is not a concern clFinish(cmd_queue_); } else { // this keeps the host thread awake, useful if latency is a concern clFlush(cmd_queue_); error_ = clGetEventInfo(event, CL_EVENT_COMMAND_EXECUTION_STATUS, sizeof(cl_int), &amp;eventStatus, NULL); while (eventStatus &gt; 0) { error_ = clGetEventInfo(event, CL_EVENT_COMMAND_EXECUTION_STATUS, sizeof(cl_int), &amp;eventStatus, NULL); Sleep(0); // be nice to other threads, allow scheduler to find other work if possible // Choose your favorite way to yield, SwitchToThread() for example, in place of Sleep(0) } }
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-531396" xml:lang="en-US">
     <a name="50401315_pgfId-531396" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-531396" name="50401315_pgfId-531396" shape="rect">
       1.7.5 GPU and CPU Kernels 1-38
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        While OpenCL provides functional portability so that the same kernel can run on any device, peak performance for each device is typically obtained by tuning the OpenCL kernel for the target device.
       </li>
       <li class="li">
        Code optimized for the Tahiti device (the AMD Radeon ™ HD 7970 GPU) typically runs well across other members of the Southern Islands family.
       </li>
       <li class="li">
        CPUs and GPUs have very different performance characteristics, and some of these impact how one writes an optimal kernel.
       </li>
       <li class="li">
        Notable differences include: The Vector ALU floating point resources in a CPU (SSE/AVX) require the use of vectorized types (such as float4) to enable packed SSE code generation and extract good performance from the Vector ALU hardware.
       </li>
       <li class="li">
        The GPU Vector ALU hardware is more flexible and can efficiently use the floating-point hardware; however, code that can use float4 often generates hi-quality code for both the CPU and the AMD GPUs.
       </li>
       <li class="li">
        The AMD OpenCL CPU implementation runs work-items from the same work-group back-to-back on the same physical CPU core.
       </li>
       <li class="li">
        For optimally coalesced memory patterns, a common access pattern for GPU-optimized algorithms is for work-items in the same wavefront to access memory locations from the same cache line.
       </li>
       <li class="li">
        On a GPU, these work-items execute in parallel and generate a coalesced access pattern.
       </li>
       <li class="li">
        On a CPU, the first work-item runs to completion (or until hitting a barrier) before switching to the next.
       </li>
       <li class="li">
        Generally, if the working set for the data used by a work-group fits in the CPU caches, this access pattern can work efficiently: the first work-item brings a line into the cache hierarchy, which the other work-items later hit.
       </li>
       <li class="li">
        For large working-sets that exceed the capacity of the cache hierarchy, this access pattern does not work as efficiently; each work-item refetches cache lines that were already brought in by earlier work-items but were evicted from the cache hierarchy before being used.
       </li>
       <li class="li">
        Note that AMD CPUs typically provide 512 kB to 2 MB of L2+L3 cache for each compute unit.
       </li>
       <li class="li">
        CPUs do not contain any hardware resources specifically designed to accelerate local memory accesses.
       </li>
       <li class="li">
        On a CPU, local memory is mapped to the same cacheable DRAM used for global memory, and there is no performance benefit from using the __local qualifier.
       </li>
       <li class="li">
        The additional memory operations to write to LDS, and the associated barrier operations can reduce performance.
       </li>
       <li class="li">
        One notable exception is when local memory is used to pack values to avoid non-coalesced memory patterns.
       </li>
       <li class="li">
        CPU devices only support a small number of hardware threads, typically two to eight.
       </li>
       <li class="li">
        Small numbers of active work-group sizes reduce the CPU switching overhead, although for larger kernels this is a second-order effect.
       </li>
       <li class="li">
        For a balanced solution that runs reasonably well on both devices, developers are encouraged to write the algorithm using float4 vectorization.
       </li>
       <li class="li">
        The GPU is more sensitive to algorithm tuning; it also has higher peak performance potential.
       </li>
       <li class="li">
        Thus, one strategy is to target optimizations to the GPU and aim for reasonable performance on the CPU.
       </li>
       <li class="li">
        For peak performance on all devices, developers can choose to use conditional compilation for key code loops in the kernel, or in some cases even provide two separate kernels.
       </li>
       <li class="li">
        Even with device-specific kernel optimizations, the surrounding host code for allocating memory, launching kernels, and interfacing with the rest of the program generally only needs to be written once.
       </li>
       <li class="li">
        Another approach is to leverage a CPU-targeted routine written in a standard high-level language, such as C++.
       </li>
       <li class="li">
        In some cases, this code path may already exist for platforms that do not support an OpenCL device.
       </li>
       <li class="li">
        The program uses OpenCL for GPU devices, and the standard routine for CPU devices.
       </li>
       <li class="li">
        Load-balancing between devices can still leverage the techniques described in See Partitioning Work for Multiple Devices.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401315_pgfId-531424" xml:lang="en-US">
     <a name="50401315_pgfId-531424" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401315_pgfId-531424" name="50401315_pgfId-531424" shape="rect">
       1.7.6 Contexts and Devices 1-39
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The AMD OpenCL program creates at least one context, and each context can contain multiple devices.
       </li>
       <li class="li">
        Thus, developers must choose whether to place all devices in the same context or create a new context for each device.
       </li>
       <li class="li">
        Generally, it is easier to extend a context to support additional devices rather than duplicating the context for each device: buffers are allocated at the context level (and automatically across all devices), programs are associated with the context, and kernel compilation (via clBuildProgram ) can easily be done for all devices in a context.
       </li>
       <li class="li">
        However, with current OpenCL implementations, creating a separate context for each device provides more flexibility, especially in that buffer allocations can be targeted to occur on specific devices.
       </li>
       <li class="li">
        Generally, placing the devices in the same context is the preferred solution.
       </li>
      </ul>
     </div>
    </div>
   </div>
  </div>
  <div class="topic concept nested1" id="50401334_pgfId-412605" xml:lang="en-US">
   <a name="50401334_pgfId-412605" shape="rect">
   </a>
   <h2 class="title topictitle1">
    <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-412605" name="50401334_pgfId-412605" shape="rect">
     Chapter 2 OpenCL Performance and Optimization for GCN Devices
    </a>
   </h2>
   <div class="body conbody">
    <ul class="ul">
     <li class="li">
      This chapter discusses performance and optimization when programming for AMD Accelerated Parallel Processing GPU compute devices that are based on the Graphic Core Next (GCN) architecture (such as the Southern Islands devices and Kabini APUs), as well as CPUs and multiple devices.
     </li>
     <li class="li">
      Details specific to the Evergreen and Northern Islands families of GPUs are provided in See OpenCL Performance and Optimization for Evergreen and Northern Islands Devices
     </li>
    </ul>
   </div>
   <div class="topic concept nested2" id="50401334_pgfId-472054" xml:lang="en-US">
    <a name="50401334_pgfId-472054" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-472054" name="50401334_pgfId-472054" shape="rect">
      2.1 Global Memory Optimization 2-1
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       See Memory System is a block diagram of the GPU memory system.
      </li>
      <li class="li">
       The up arrows are read paths, the down arrows are write paths.
      </li>
      <li class="li">
       WC is the write combine cache.
      </li>
      <li class="li">
       The GPU consists of multiple compute units.
      </li>
      <li class="li">
       Each compute unit (CU) contains local (on-chip) memory, L1 cache, registers, and four SIMDs.
      </li>
      <li class="li">
       Each SIMD consists of 16 processing element (PEs).
      </li>
      <li class="li">
       Individual work-items execute on a single processing element; one or more work-groups execute on a single compute unit.
      </li>
      <li class="li">
       On a GPU, hardware schedules groups of work-items, called wavefronts, onto compute units; thus, work-items within a wavefront execute in lock-step; the same instruction is executed on different data.
      </li>
      <li class="li">
       Each compute unit contains 64 kB local memory, 16 kB of read/write L1 cache, four vector units, and one scalar unit.
      </li>
      <li class="li">
       The maximum local memory allocation is 32 kB per work-group.
      </li>
      <li class="li">
       Each vector unit contains 512 scalar registers (SGPRs) for handling branching, constants, and other data constant across a wavefront.
      </li>
      <li class="li">
       Vector units also contain 256 vector registers (VGPRs).
      </li>
      <li class="li">
       VGPRs actually are scalar registers, but they are replicated across the whole wavefront.
      </li>
      <li class="li">
       Vector units contain 16 processing elements (PEs).
      </li>
      <li class="li">
       Each PE is scalar.
      </li>
      <li class="li">
       Since the L1 cache is 16 kB per compute unit, the total L1 cache size is 16 kB * (# of compute units).
      </li>
      <li class="li">
       For the AMD Radeon ™ HD 7970, this means a total of 512 kB L1 cache.
      </li>
      <li class="li">
       L1 bandwidth can be computed as: L1 peak bandwidth = Compute Units * (4 threads/clock) * (128 bits per thread) * (1 byte / 8 bits) * Engine Clock For the AMD Radeon  HD 7970, this is ~1.9 TB/s.
      </li>
      <li class="li">
       If two memory access requests are directed to the same controller, the hardware serializes the access.
      </li>
      <li class="li">
       This is called a channel conflict.
      </li>
      <li class="li">
       Similarly, if two memory access requests go to the same memory bank, hardware serializes the access.
      </li>
      <li class="li">
       This is called a bank conflict.
      </li>
      <li class="li">
       From a developer’s point of view, there is not much difference between channel and bank conflicts.
      </li>
      <li class="li">
       Often, a large power of two stride results in a channel conflict.
      </li>
      <li class="li">
       The size of the power of two stride that causes a specific type of conflict depends on the chip.
      </li>
      <li class="li">
       A stride that results in a channel conflict on a machine with eight channels might result in a bank conflict on a machine with four.
      </li>
      <li class="li">
       In this document, the term bank conflict is used to refer to either kind of conflict.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="50401334_pgfId-472173" xml:lang="en-US">
     <a name="50401334_pgfId-472173" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-472173" name="50401334_pgfId-472173" shape="rect">
       2.1.1 Channel Conflicts 2-3
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The important concept is memory stride: the increment in memory address, measured in elements, between successive elements fetched or stored by consecutive work-items in a kernel.
       </li>
       <li class="li">
        Many important kernels do not exclusively use simple stride one accessing patterns; instead, they feature large non-unit strides.
       </li>
       <li class="li">
        For instance, many codes perform similar operations on each dimension of a two- or three-dimensional array.
       </li>
       <li class="li">
        Performing computations on the low dimension can often be done with unit stride, but the strides of the computations in the other dimensions are typically large values.
       </li>
       <li class="li">
        This can result in significantly degraded performance when the codes are ported unchanged to GPU systems.
       </li>
       <li class="li">
        A CPU with caches presents the same problem, large power-of-two strides force data into only a few cache lines.
       </li>
       <li class="li">
        One solution is to rewrite the code to employ array transpositions between the kernels.
       </li>
       <li class="li">
        This allows all computations to be done at unit stride.
       </li>
       <li class="li">
        Ensure that the time required for the transposition is relatively small compared to the time to perform the kernel calculation.
       </li>
       <li class="li">
        For many kernels, the reduction in performance is sufficiently large that it is worthwhile to try to understand and solve this problem.
       </li>
       <li class="li">
        In GPU programming, it is best to have adjacent work-items read or write adjacent memory addresses.
       </li>
       <li class="li">
        This is one way to avoid channel conflicts.
       </li>
       <li class="li">
        When the application has complete control of the access pattern and address generation, the developer must arrange the data structures to minimize bank conflicts.
       </li>
       <li class="li">
        Accesses that differ in the lower bits can run in parallel; those that differ only in the upper bits can be serialized.
       </li>
       <li class="li">
        In this example: where the lower bits are all the same, the memory requests all access the same bank on the same channel and are processed serially.
       </li>
       <li class="li">
        This is a low-performance pattern to be avoided.
       </li>
       <li class="li">
        When the stride is a power of 2 (and larger than the channel interleave), the loop above only accesses one channel of memory.
       </li>
       <li class="li">
        The hardware byte address bits are: On all AMD Radeon  HD 79XX-series GPUs, there are 12 channels.
       </li>
       <li class="li">
        A crossbar distributes the load to the appropriate memory channel.
       </li>
       <li class="li">
        Each memory channel has a read/write global L2 cache, with 64 kB per channel.
       </li>
       <li class="li">
        The cache line size is 64 bytes.
       </li>
       <li class="li">
        Because 12 channels are not a part of the power of two memory and bank channel addressing, this is not straightforward for the AMD Radeon  HD 79XX series.
       </li>
       <li class="li">
        The memory channels are grouped in four quadrants, each which consisting of three channels.
       </li>
       <li class="li">
        Bits 8, 9, and 10 of the address select a “virtual pipe.” The top two bits of this pipe select the quadrant; then, the channel within the quadrant is selected using the low bit of the pipe and the row and bank address modulo three, according to the following conditional equation.
       </li>
       <li class="li">
        See Channel Remapping/Interleaving illustrates the memory channel mapping.
       </li>
       <li class="li">
        Note that an increase of the address by 2048 results in a 1/3 probability the same channel is hit; increasing the address by 256 results in a 1/6 probability the same channel is hit, etc.
       </li>
       <li class="li">
        On AMD Radeon  HD 78XX GPUs, the channel selection are bits 10:8 of the byte address.
       </li>
       <li class="li">
        For the AMD Radeon  HD 77XX, the channel selection are bits 9:8 of the byte address.
       </li>
       <li class="li">
        This means a linear burst switches channels every 256 bytes.
       </li>
       <li class="li">
        Since the wavefront size is 64, channel conflicts are avoided if each work-item in a wave reads a different address from a 64-word region.
       </li>
       <li class="li">
        All AMD Radeon  HD 7XXX series GPUs have the same layout: channel ends at bit 8, and the memory bank is to the left of the channel.
       </li>
       <li class="li">
        For AMD Radeon  HD 77XX and 78XX GPUs, a burst of 2 kB (# of channels * 256 bytes) cycles through all the channels.
       </li>
       <li class="li">
        For AMD Radeon  HD 77XX and 78XX GPUs, when calculating an address as y*width+x, but reading a burst on a column (incrementing y), only one memory channel of the system is used, since the width is likely a multiple of 256 words = 2048 bytes.
       </li>
       <li class="li">
        If the width is an odd multiple of 256B, then it cycles through all channels.
       </li>
       <li class="li">
        If every work-item in a work-group references consecutive memory addresses and the address of work-item 0 is aligned to 256 bytes and each work-item fetches 32 bits, the entire wavefront accesses one channel.
       </li>
       <li class="li">
        Although this seems slow, it actually is a fast pattern because it is necessary to consider the memory access over the entire device, not just a single wavefront.
       </li>
       <li class="li">
        One or more work-groups execute on each compute unit.
       </li>
       <li class="li">
        On the AMD Radeon  HD 7000-series GPUs, work-groups are dispatched in a linear order, with x changing most rapidly.
       </li>
       <li class="li">
        For a single dimension, this is: DispatchOrder = get_group_id(0) For two dimensions, this is: DispatchOrder = get_group_id(0) + get_group_id(1) * get_num_groups(0) This is row-major-ordering of the blocks in the index space.
       </li>
       <li class="li">
        Once all compute units are in use, additional work-groups are assigned to compute units as needed.
       </li>
       <li class="li">
        Work-groups retire in order, so active work-groups are contiguous.
       </li>
       <li class="li">
        At any time, each compute unit is executing an instruction from a single wavefront.
       </li>
       <li class="li">
        In memory intensive kernels, it is likely that the instruction is a memory access.
       </li>
       <li class="li">
        Since there are 12 channels on the AMD Radeon  HD 7970 GPU, at most 12 of the compute units can issue a memory access operation in one cycle.
       </li>
       <li class="li">
        It is most efficient if the accesses from 12 wavefronts go to different channels.
       </li>
       <li class="li">
        One way to achieve this is for each wavefront to access consecutive groups of 256 = 64 * 4 bytes.
       </li>
       <li class="li">
        Note, as shown in See Channel Remapping/Interleaving, fetching 256 * 12 bytes in a row does not always cycle through all channels.
       </li>
       <li class="li">
        An inefficient access pattern is if each wavefront accesses all the channels.
       </li>
       <li class="li">
        This is likely to happen if consecutive work-items access data that has a large power of two strides.
       </li>
       <li class="li">
        In the next example of a kernel for copying, the input and output buffers are interpreted as though they were 2D, and the work-group size is organized as 2D.
       </li>
       <li class="li">
        The kernel code is: By changing the width, the data type and the work-group dimensions, we get a set of kernels out of this code.
       </li>
       <li class="li">
        Given a 64×1 work-group size, each work-item reads a consecutive 32-bit address.
       </li>
       <li class="li">
        Given a 1×64 work-group size, each work-item reads a value separated by the width in a power of two bytes.
       </li>
       <li class="li">
        To avoid power of two strides: Add an extra column to the data matrix.
       </li>
       <li class="li">
        Change the work-group size so that it is not a power of 22.
       </li>
       <li class="li">
        It is best to use a width that causes a rotation through all of the memory channels, instead of using the same one repeatedly.
       </li>
       <li class="li">
        Change the kernel to access the matrix with a staggered offset.
       </li>
      </ul>
     </div>
     <div class="topic concept nested4" id="50401334_pgfId-472340" xml:lang="en-US">
      <a name="50401334_pgfId-472340" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-472340" name="50401334_pgfId-472340" shape="rect">
        Staggered Offsets 2-7
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Staggered offsets apply a coordinate transformation to the kernel so that the data is processed in a different order.
        </li>
        <li class="li">
         Unlike adding a column, this technique does not use extra space.
        </li>
        <li class="li">
         It is also relatively simple to add to existing code.
        </li>
        <li class="li">
         See Transformation to Staggered Offsets illustrates the transformation to staggered offsets.
        </li>
        <li class="li">
         The global ID values reflect the order that the hardware initiates work-groups.
        </li>
        <li class="li">
         The values of get group ID are in ascending launch order.
        </li>
        <li class="li">
         global_id(0) = get_group_id(0) * get_local_size(0) + get_local_id(0) global_id(1) = get_group_id(1) * get_local_size(1) + get_local_id(1) The hardware launch order is fixed, but it is possible to change the launch order, as shown in the following example.
        </li>
        <li class="li">
         Assume a work-group size of k x k, where k is a power of two, and a large 2D matrix of size 2n x 2m in row-major order.
        </li>
        <li class="li">
         If each work-group must process a block in column-order, the launch order does not work out correctly: consecutive work-groups execute down the columns, and the columns are a large power-of-two apart; so, consecutive work-groups access the same channel.
        </li>
        <li class="li">
         By introducing a transformation, it is possible to stagger the work-groups to avoid channel conflicts.
        </li>
        <li class="li">
         Since we are executing 2D work-groups, each work group is identified by four numbers.
        </li>
        <li class="li">
         get_group_id(1 ) – the y coordinate or the block within the row of the matrix.
        </li>
        <li class="li">
         get_global_id(0) – the x coordinate or the column of the matrix.
        </li>
        <li class="li">
         get_global_id(1) – the y coordinate or the row of the matrix.
        </li>
        <li class="li">
         To transform the code, add the following four lines to the top of the kernel.
        </li>
        <li class="li">
         Then, change the global IDs and group IDs to the staggered form.
        </li>
        <li class="li">
         The result is:
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401334_pgfId-472385" xml:lang="en-US">
      <a name="50401334_pgfId-472385" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-472385" name="50401334_pgfId-472385" shape="rect">
        Reads Of The Same Address 2-9
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Under certain conditions, one unexpected case of a channel conflict is that reading from the same address is a conflict, even on the FastPath.
        </li>
        <li class="li">
         This does not happen on the read-only memories, such as constant buffers, textures, or shader resource view (SRV); but it is possible on the read/write UAV memory or OpenCL global memory.
        </li>
        <li class="li">
         From a hardware standpoint, reads from a fixed address have the same upper bits, so they collide and are serialized.
        </li>
        <li class="li">
         To read in a single value, read the value in a single work-item, place it in local memory, and then use that location: Avoid: Use:
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="50401334_pgfId-472466" xml:lang="en-US">
     <a name="50401334_pgfId-472466" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-472466" name="50401334_pgfId-472466" shape="rect">
       2.1.2 Coalesced Writes 2-9
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Southern Island devices do not support coalesced writes; however, continuous addresses within work-groups provide maximum performance.
       </li>
       <li class="li">
        Each compute unit accesses the memory system in quarter-wavefront units.
       </li>
       <li class="li">
        The compute unit transfers a 32-bit address and one element-sized piece of data for each work-item.
       </li>
       <li class="li">
        This results in a total of 16 elements + 16 addresses per quarter-wavefront.
       </li>
       <li class="li">
        On GCN-based devices, processing quarter-wavefront requires two cycles before the data is transferred to the memory controller.
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="50401334_pgfId-481974" xml:lang="en-US">
    <a name="50401334_pgfId-481974" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-481974" name="50401334_pgfId-481974" shape="rect">
      2.2 Local Memory (LDS) Optimization 2-10
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       AMD Southern Islands GPUs include a Local Data Store (LDS) cache, which accelerates local memory accesses.
      </li>
      <li class="li">
       LDS provides high-bandwidth access (more than 10X higher than global memory), efficient data transfers between work-items in a work-group, and high-performance atomic support.
      </li>
      <li class="li">
       LDS is much faster than L1 cache access as it has twice the peak bandwidth and far lower latency.
      </li>
      <li class="li">
       Additionally, using LDS memory can reduce global memory bandwidth usage.
      </li>
      <li class="li">
       Local memory offers significant advantages when the data is re-used; for example, subsequent accesses can read from local memory, thus reducing global memory bandwidth.
      </li>
      <li class="li">
       Another advantage is that local memory does not require coalescing.
      </li>
      <li class="li">
       To determine local memory size: All AMD Southern Islands GPUs contain a 64 kB LDS for each compute unit; although only 32 kB can be allocated per work-group.
      </li>
      <li class="li">
       The LDS contains 32-banks, each bank is four bytes wide and 256 bytes deep; the bank address is determined by bits 6:2 in the address.
      </li>
      <li class="li">
       As shown below, programmers must carefully control the bank bits to avoid bank conflicts as much as possible.
      </li>
      <li class="li">
       Bank conflicts are determined by what addresses are accessed on each half wavefront boundary.
      </li>
      <li class="li">
       Threads 0 through 31 are checked for conflicts as are threads 32 through 63 within a wavefront.
      </li>
      <li class="li">
       In a single cycle, local memory can service a request for each bank (up to 32 accesses each cycle on the AMD Radeon  HD 7970 GPU).
      </li>
      <li class="li">
       For an AMD Radeon  HD 7970 GPU, this delivers a memory bandwidth of over 100 GB/s for each compute unit, and more than 3.5 TB/s for the whole chip.
      </li>
      <li class="li">
       This is more than 14X the global memory bandwidth.
      </li>
      <li class="li">
       However, accesses that map to the same bank are serialized and serviced on consecutive cycles.
      </li>
      <li class="li">
       LDS operations do not stall; however, the compiler inserts wait operations prior to issuing operations that depend on the results.
      </li>
      <li class="li">
       A wavefront that generated bank conflicts does not stall implicitly, but may stall explicitly in the kernel if the compiler has inserted a wait command for the outstanding memory access.
      </li>
      <li class="li">
       The GPU reprocesses the wavefront on subsequent cycles, enabling only the lanes receiving data, until all the conflicting accesses complete.
      </li>
      <li class="li">
       The bank with the most conflicting accesses determines the latency for the wavefront to complete the local memory operation.
      </li>
      <li class="li">
       The worst case occurs when all 64 work-items map to the same bank, since each access then is serviced at a rate of one per clock cycle; this case takes 64 cycles to complete the local memory access for the wavefront.
      </li>
      <li class="li">
       A program with a large number of bank conflicts (as measured by the LDSBankConflict performance counter in the CodeXL GPU Profiler statistics) might benefit from using the constant or image memory rather than LDS.
      </li>
      <li class="li">
       Thus, the key to effectively using the LDS is to control the access pattern, so that accesses generated on the same cycle map to different banks in the LDS.
      </li>
      <li class="li">
       One notable exception is that accesses to the same address (even though they have the same bits 6:2) can be broadcast to all requestors and do not generate a bank conflict.
      </li>
      <li class="li">
       The LDS hardware examines the requests generated over two cycles (32 work-items of execution) for bank conflicts.
      </li>
      <li class="li">
       Ensure, as much as possible, that the memory requests generated from a quarter-wavefront avoid bank conflicts by using unique address bits 6:2.
      </li>
      <li class="li">
       A simple sequential address pattern, where each work-item reads a float2 value from LDS, generates a conflict-free access pattern on the AMD Radeon  HD 7XXX GPU.
      </li>
      <li class="li">
       Note that a sequential access pattern, where each work-item reads a float4 value from LDS, uses only half the banks on each cycle on the AMD Radeon  HD 7XXX GPU and delivers half the performance of the float access pattern.
      </li>
      <li class="li">
       Each stream processor can generate up to two 4-byte LDS requests per cycle.
      </li>
      <li class="li">
       Byte and short reads consume four bytes of LDS bandwidth.
      </li>
      <li class="li">
       Developers can use the large register file: each compute unit has 256 kB of register space available (8X the LDS size) and can provide up to twelve 4-byte values/cycle (6X the LDS bandwidth).
      </li>
      <li class="li">
       Registers do not offer the same indexing flexibility as does the LDS, but for some algorithms this can be overcome with loop unrolling and explicit addressing.
      </li>
      <li class="li">
       LDS reads require one ALU operation to initiate them.
      </li>
      <li class="li">
       Each operation can initiate two loads of up to four bytes each.
      </li>
      <li class="li">
       The CodeXL GPU Profiler provides the following performance counter to help optimize local memory usage: LDSBankConflict : The percentage of time accesses to the LDS are stalled due to bank conflicts relative to GPU Time.
      </li>
      <li class="li">
       In the ideal case, there are no bank conflicts in the local memory access, and this number is zero.
      </li>
      <li class="li">
       Local memory is software-controlled “scratchpad” memory.
      </li>
      <li class="li">
       In contrast, caches typically used on CPUs monitor the access stream and automatically capture recent accesses in a tagged cache.
      </li>
      <li class="li">
       The scratchpad allows the kernel to explicitly load items into the memory; they exist in local memory until the kernel replaces them, or until the work-group ends.
      </li>
      <li class="li">
       To declare a block of local memory, use the __local keyword; for example: These declarations can be either in the parameters to the kernel call or in the body of the kernel.
      </li>
      <li class="li">
       The __local syntax allocates a single block of memory, which is shared across all work-items in the workgroup.
      </li>
      <li class="li">
       To write data into local memory, write it into an array allocated with __local .
      </li>
      <li class="li">
       For example: A typical access pattern is for each work-item to collaboratively write to the local memory: each work-item writes a subsection, and as the work-items execute in parallel they write the entire array.
      </li>
      <li class="li">
       Combined with proper consideration for the access pattern and bank alignment, these collaborative write approaches can lead to highly efficient memory accessing.
      </li>
      <li class="li">
       The following example is a simple kernel section that collaboratively writes, then reads from, local memory: __kernel void localMemoryExample (__global float *In, __global float *Out) { __local float localBuffer[64]; uint tx = get_local_id(0); uint gx = get_global_id(0); // Initialize local memory: // Copy from this work-group’s section of global memory to local: // Each work-item writes one element; together they write it all localBuffer[tx] = In[gx]; // Ensure writes have completed: barrier(CLK_LOCAL_MEM_FENCE); // Toy computation to compute a partial factorial, shows re-use from local float f = localBuffer[tx]; for (uint i=tx+1; i&lt;64; i++) { f *= localBuffer[i]; } Out[gx] = f; } Note the host code cannot read from, or write to, local memory.
      </li>
      <li class="li">
       Only the kernel can access local memory.
      </li>
      <li class="li">
       Local memory is consistent across work-items only at a work-group barrier; thus, before reading the values written collaboratively, the kernel must include a barrier() instruction.
      </li>
      <li class="li">
       An important optimization is the case where the local work-group size is less than, or equal to, the wavefront size.
      </li>
      <li class="li">
       Because the wavefront executes as an atomic unit, the explicit barrier operation is not required.
      </li>
      <li class="li">
       The compiler automatically removes these barriers if the kernel specifies a reqd_work_group_size (see section 5.8 of the OpenCL Specification) that is less than the wavefront size.
      </li>
      <li class="li">
       Developers are strongly encouraged to include the barriers where appropriate, and rely on the compiler to remove the barriers when possible, rather than manually removing the barriers() .
      </li>
      <li class="li">
       This technique results in more portable code, including the ability to run kernels on CPU devices.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="50401334_pgfId-448213" xml:lang="en-US">
    <a name="50401334_pgfId-448213" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-448213" name="50401334_pgfId-448213" shape="rect">
      2.3 Constant Memory Optimization 2-12
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       Constants (data from read-only buffers shared by a wavefront) are loaded to SGPRs from memory through the L1 (and L2) cache using scalar memory read instructions.
      </li>
      <li class="li">
       The scalar instructions can use up to two SGPR sources per cycle; vector instructions can use one SGPR source per cycle.
      </li>
      <li class="li">
       (There are 512 SGPRs per SIMD, 4 SIMDs per CU; so a 32 CU configuration like Tahiti has 256 kB of SGPRs.)
      </li>
      <li class="li">
       Southern Islands hardware supports specific inline literal constants.
      </li>
      <li class="li">
       These constants are “free” in that they do not increase code size: 0 integers 1.. 64 integers -1 .. -16 0.5 single or double floats -0.5 1.0 -1.0 2.0 -2.0 4.0 -4.0 Any other literal constant increases the code size by at least 32 bits.
      </li>
      <li class="li">
       The AMD implementation of OpenCL provides three levels of performance for the “constant” memory type.
      </li>
      <li class="li">
       Very high bandwidth can be attained when the compiler has available the constant address at compile time and can embed the constant address into the instruction.
      </li>
      <li class="li">
       Each processing element can load up to 4×4-byte direct-addressed constant values each cycle.
      </li>
      <li class="li">
       Typically, these cases are limited to simple non-array constants and function parameters.
      </li>
      <li class="li">
       The executing kernel loads the constants into scalar registers and concurrently populates the constant cache.
      </li>
      <li class="li">
       The constant cache is a tagged cache.
      </li>
      <li class="li">
       Typically each 16 8k cache is shared among four compute units.
      </li>
      <li class="li">
       If the constant data is already present in the constant cache, the load is serviced by the cache and does not require any global memory bandwidth.
      </li>
      <li class="li">
       The constant cache size varies from 4k to 48k per GPU.
      </li>
      <li class="li">
       Same Index Hardware acceleration also takes place when all work-items in a wavefront reference the same constant address.
      </li>
      <li class="li">
       In this case, the data is loaded from memory one time, stored in the L1 cache, and then broadcast to all wave-fronts.
      </li>
      <li class="li">
       This can reduce significantly the required memory bandwidth.
      </li>
      <li class="li">
       Varying Index More sophisticated addressing patterns, including the case where each work-item accesses different indices, are not hardware accelerated and deliver the same performance as a global memory read with the potential for cache hits.
      </li>
      <li class="li">
       To further improve the performance of the AMD OpenCL stack, two methods allow users to take advantage of hardware constant buffers.
      </li>
      <li class="li">
       These are: Per-pointer attribute specifying the maximum pointer size.
      </li>
      <li class="li">
       This is specified using the max_constant_size(N) attribute.
      </li>
      <li class="li">
       The attribute form conforms to section 6.10 of the OpenCL 1.0 specification.
      </li>
      <li class="li">
       This attribute is restricted to top-level kernel function arguments in the constant address space.
      </li>
      <li class="li">
       This restriction prevents a pointer of one size from being passed as an argument to a function that declares a different size.
      </li>
      <li class="li">
       It informs the compiler that indices into the pointer remain inside this range and it is safe to allocate a constant buffer in hardware, if it fits.
      </li>
      <li class="li">
       Using a constant pointer that goes outside of this range results in undefined behavior.
      </li>
      <li class="li">
       All allocations are aligned on the 16-byte boundary.
      </li>
      <li class="li">
       For example: A kernel that uses constant buffers must use CL_DEVICE_MAX_CONSTANT_ARGS to query the device for the maximum number of constant buffers the kernel can support.
      </li>
      <li class="li">
       This value might differ from the maximum number of hardware constant buffers available.
      </li>
      <li class="li">
       In this case, if the number of hardware constant buffers is less than the CL_DEVICE_MAX_CONSTANT_ARGS , the compiler allocates the largest constant buffers in hardware first and allocates the rest of the constant buffers in global memory.
      </li>
      <li class="li">
       As an optimization, if a constant pointer A uses n bytes of memory, where n is less than 64 kB, and constant pointer B uses m bytes of memory, where m is less than (64 kB – n) bytes of memory, the compiler can allocate the constant buffer pointers in a single hardware constant buffer.
      </li>
      <li class="li">
       This optimization can be applied recursively by treating the resulting allocation as a single allocation and finding the next smallest constant pointer that fits within the space left in the constant buffer.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="50401334_pgfId-449206" xml:lang="en-US">
    <a name="50401334_pgfId-449206" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-449206" name="50401334_pgfId-449206" shape="rect">
      2.4 OpenCL Memory Resources: Capacity and Performance 2-14
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       See Hardware Performance Parameters summarizes the hardware capacity and associated performance for the structures associated with the five OpenCL Memory Types.
      </li>
      <li class="li">
       This information specific to the AMD Radeon  HD 7970 GPUs with 3 GB video memory.
      </li>
      <li class="li">
       The compiler tries to map private memory allocations to the pool of GPRs in the GPU.
      </li>
      <li class="li">
       In the event GPRs are not available, private memory is mapped to the “scratch” region, which has the same performance as global memory.
      </li>
      <li class="li">
       See Resource Limits on Active Wavefronts, has more information on register allocation and identifying when the compiler uses the scratch region.
      </li>
      <li class="li">
       GPRs provide the highest-bandwidth access of any hardware resource.
      </li>
      <li class="li">
       In addition to reading up to 12 bytes/cycle per processing element from the register file, the hardware can access results produced in the previous cycle without consuming any register file bandwidth.
      </li>
      <li class="li">
       Same-indexed constants can be cached in the L1 and L2 cache.
      </li>
      <li class="li">
       Note that “same-indexed” refers to the case where all work-items in the wavefront reference the same constant index on the same cycle.
      </li>
      <li class="li">
       The performance shown assumes an L1 cache hit.
      </li>
      <li class="li">
       Varying-indexed constants, which are cached only in L2, use the same path as global memory access and are subject to the same bank and alignment constraints described in See Global Memory Optimization.
      </li>
      <li class="li">
       The L1 and L2 read/write caches are constantly enabled.
      </li>
      <li class="li">
       As of SDK 2.4, read only buffers can be cached in L1 and L2.
      </li>
      <li class="li">
       The L1 cache can service up to four address requests per cycle, each delivering up to 16 bytes.
      </li>
      <li class="li">
       The bandwidth shown assumes an access size of 16 bytes; smaller access sizes/requests result in a lower peak bandwidth for the L1 cache.
      </li>
      <li class="li">
       Using float4 with images increases the request size and can deliver higher L1 cache bandwidth.
      </li>
      <li class="li">
       Each memory channel on the GPU contains an L2 cache that can deliver up to 64 bytes/cycle.
      </li>
      <li class="li">
       The AMD Radeon  HD 7970 GPU has 12 memory channels; thus, it can deliver up to 768 bytes/cycle; divided among 2048 stream cores, this provides up to ~0.4 bytes/cycle for each stream core.
      </li>
      <li class="li">
       Global Memory bandwidth is limited by external pins, not internal bus bandwidth.
      </li>
      <li class="li">
       The AMD Radeon  HD 7970 GPU supports up to 264 GB/s of memory bandwidth which is an average of 0.14 bytes/cycle for each stream core.
      </li>
      <li class="li">
       Note that See Hardware Performance Parameters shows the performance for the AMD Radeon  HD 7970 GPU.
      </li>
      <li class="li">
       The “Size/Compute Unit” column and many of the bandwidths/processing element apply to all Southern Islands-class GPUs; however, the “Size/GPU” column and the bandwidths for varying-indexed constant, L2, and global memory vary across different GPU devices.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="50401334_pgfId-538469" xml:lang="en-US">
    <a name="50401334_pgfId-538469" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-538469" name="50401334_pgfId-538469" shape="rect">
      2.5 Using LDS or L1 Cache 2-16
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       There are a number of considerations when deciding between LDS and L1 cache for a given algorithm.
      </li>
      <li class="li">
       LDS supports read/modify/write operations, as well as atomics.
      </li>
      <li class="li">
       It is well-suited for code that requires fast read/write, read/modify/write, or scatter operations that otherwise are directed to global memory.
      </li>
      <li class="li">
       On current AMD hardware, L1 is part of the read path; hence, it is suited to cache-read-sensitive algorithms, such as matrix multiplication or convolution.
      </li>
      <li class="li">
       LDS is typically larger than L1 (for example: 64 kB vs 16 kB on Southern Islands devices).
      </li>
      <li class="li">
       If it is not possible to obtain a high L1 cache hit rate for an algorithm, the larger LDS size can help.
      </li>
      <li class="li">
       On the AMD Radeon  HD 7970 device, the theoretical LDS peak bandwidth is 3.8 TB/s, compared to L1 at 1.9 TB/sec.
      </li>
      <li class="li">
       The native data type for L1 is a four-vector of 32-bit words.
      </li>
      <li class="li">
       On L1, fill and read addressing are linked.
      </li>
      <li class="li">
       It is important that L1 is initially filled from global memory with a coalesced access pattern; once filled, random accesses come at no extra processing cost.
      </li>
      <li class="li">
       Currently, the native format of LDS is a 32-bit word.
      </li>
      <li class="li">
       The theoretical LDS peak bandwidth is achieved when each thread operates on a two-vector of 32-bit words (16 threads per clock operate on 32 banks).
      </li>
      <li class="li">
       If an algorithm requires coalesced 32-bit quantities, it maps well to LDS.
      </li>
      <li class="li">
       The use of four-vectors or larger can lead to bank conflicts, although the compiler can mitigate some of these.
      </li>
      <li class="li">
       From an application point of view, filling LDS from global memory, and reading from it, are independent operations that can use independent addressing.
      </li>
      <li class="li">
       Thus, LDS can be used to explicitly convert a scattered access pattern to a coalesced pattern for read and write to global memory.
      </li>
      <li class="li">
       Or, by taking advantage of the LDS read broadcast feature, LDS can be filled with a coalesced pattern from global memory, followed by all threads iterating through the same LDS words simultaneously.
      </li>
      <li class="li">
       LDS reuses the data already pulled into cache by other wavefronts.
      </li>
      <li class="li">
       Sharing across work-groups is not possible because OpenCL does not guarantee that LDS is in a particular state at the beginning of work-group execution.
      </li>
      <li class="li">
       L1 content, on the other hand, is independent of work-group execution, so that successive work-groups can share the content in the L1 cache of a given Vector ALU.
      </li>
      <li class="li">
       However, it currently is not possible to explicitly control L1 sharing across work-groups.
      </li>
      <li class="li">
       The use of LDS is linked to GPR usage and wavefront-per-Vector ALU count.
      </li>
      <li class="li">
       Better sharing efficiency requires a larger work-group, so that more work-items share the same LDS.
      </li>
      <li class="li">
       Compiling kernels for larger work-groups typically results in increased register use, so that fewer wavefronts can be scheduled simultaneously per Vector ALU.
      </li>
      <li class="li">
       This, in turn, reduces memory latency hiding.
      </li>
      <li class="li">
       Requesting larger amounts of LDS per work-group results in fewer wavefronts per Vector ALU, with the same effect.
      </li>
      <li class="li">
       LDS typically involves the use of barriers, with a potential performance impact.
      </li>
      <li class="li">
       This is true even for read-only use cases, as LDS must be explicitly filled in from global memory (after which a barrier is required before reads can commence).
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="50401334_pgfId-487709" xml:lang="en-US">
    <a name="50401334_pgfId-487709" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-487709" name="50401334_pgfId-487709" shape="rect">
      2.6 NDRange and Execution Range Optimization 2-17
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       Probably the most effective way to exploit the potential performance of the GPU is to provide enough threads to keep the device completely busy.
      </li>
      <li class="li">
       The programmer specifies a three-dimensional NDRange over which to execute the kernel; bigger problems with larger NDRanges certainly help to more effectively use the machine.
      </li>
      <li class="li">
       The programmer also controls how the global NDRange is divided into local ranges, as well as how much work is done in each work-item, and which resources (registers and local memory) are used by the kernel.
      </li>
      <li class="li">
       All of these can play a role in how the work is balanced across the machine and how well it is used.
      </li>
      <li class="li">
       This section introduces the concept of latency hiding, how many wavefronts are required to hide latency on AMD GPUs, how the resource usage in the kernel can impact the active wavefronts, and how to choose appropriate global and local work-group dimensions.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="50401334_pgfId-473708" xml:lang="en-US">
     <a name="50401334_pgfId-473708" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-473708" name="50401334_pgfId-473708" shape="rect">
       2.6.1 Hiding ALU and Memory Latency 2-17
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The read-after-write latency for most arithmetic operations (a floating-point add, for example) is only four cycles.
       </li>
       <li class="li">
        For most Southern Island devices, each CU can execute 64 vector ALU instructions per cycle, 16 per wavefront.
       </li>
       <li class="li">
        Also, a wavefront can issue a scalar ALU instruction every four cycles.
       </li>
       <li class="li">
        To achieve peak ALU power, a minimum of four wavefronts must be scheduled for each CU.
       </li>
       <li class="li">
        Global memory reads generate a reference to the off-chip memory and experience a latency of 300 to 600 cycles.
       </li>
       <li class="li">
        The wavefront that generates the global memory access is made idle until the memory request completes.
       </li>
       <li class="li">
        During this time, the compute unit can process other independent wavefronts, if they are available.
       </li>
       <li class="li">
        Kernel execution time also plays a role in hiding memory latency: longer chains of ALU instructions keep the functional units busy and effectively hide more latency.
       </li>
       <li class="li">
        To better understand this concept, consider a global memory access which takes 400 cycles to execute.
       </li>
       <li class="li">
        Assume the compute unit contains many other wavefronts, each of which performs five ALU instructions before generating another global memory reference.
       </li>
       <li class="li">
        As discussed previously, the hardware executes each instruction in the wavefront in four cycles; thus, all five instructions occupy the ALU for 20 cycles.
       </li>
       <li class="li">
        Note the compute unit interleaves two of these wavefronts and executes the five instructions from both wavefronts (10 total instructions) in 40 cycles.
       </li>
       <li class="li">
        To fully hide the 400 cycles of latency, the compute unit requires (400/40) = 10 pairs of wavefronts, or 20 total wavefronts.
       </li>
       <li class="li">
        If the wavefront contains 10 instructions rather than 5, the wavefront pair would consume 80 cycles of latency, and only 10 wavefronts would be required to hide the 400 cycles of latency.
       </li>
       <li class="li">
        Generally, it is not possible to predict how the compute unit schedules the available wavefronts, and thus it is not useful to try to predict exactly which ALU block executes when trying to hide latency.
       </li>
       <li class="li">
        Instead, consider the overall ratio of ALU operations to fetch operations – this metric is reported by the CodeXL GPU Profiler in the ALUFetchRatio counter.
       </li>
       <li class="li">
        Each ALU operation keeps the compute unit busy for four cycles, so you can roughly divide 500 cycles of latency by ( 4*ALUFetchRatio ) to determine how many wavefronts must be in-flight to hide that latency.
       </li>
       <li class="li">
        Additionally, a low value for the ALUBusy performance counter can indicate that the compute unit is not providing enough wavefronts to keep the execution resources in full use.
       </li>
       <li class="li">
        (This counter also can be low if the kernel exhausts the available DRAM bandwidth.
       </li>
       <li class="li">
        In this case, generating more wavefronts does not improve performance; it can reduce performance by creating more contention.)
       </li>
       <li class="li">
        Increasing the wavefronts/compute unit does not indefinitely improve performance; once the GPU has enough wavefronts to hide latency, additional active wavefronts provide little or no performance benefit.
       </li>
       <li class="li">
        A closely related metric to wavefronts/compute unit is “occupancy,” which is defined as the ratio of active wavefronts to the maximum number of possible wavefronts supported by the hardware.
       </li>
       <li class="li">
        Many of the important optimization targets and resource limits are expressed in wavefronts/compute units, so this section uses this metric rather than the related “occupancy” term.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401334_pgfId-452280" xml:lang="en-US">
     <a name="50401334_pgfId-452280" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-452280" name="50401334_pgfId-452280" shape="rect">
       2.6.2 Resource Limits on Active Wavefronts 2-18
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        AMD GPUs have two important global resource constraints that limit the number of in-flight wavefronts: Southern Islands devices support a maximum of 16 work-groups per CU if a work-group is larger than one wavefront.
       </li>
       <li class="li">
        The maximum number of wavefronts that can be scheduled to a CU is 40, or 10 per Vector Unit.
       </li>
       <li class="li">
        These limits are largely properties of the hardware and, thus, difficult for developers to control directly.
       </li>
       <li class="li">
        Fortunately, these are relatively generous limits.
       </li>
       <li class="li">
        Frequently, the register and LDS usage in the kernel determines the limit on the number of active wavefronts/compute unit, and these can be controlled by the developer.
       </li>
      </ul>
     </div>
     <div class="topic concept nested4" id="50401334_pgfId-452285" xml:lang="en-US">
      <a name="50401334_pgfId-452285" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-452285" name="50401334_pgfId-452285" shape="rect">
        GPU Registers 2-18
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Southern Islands registers are scalar, so each is 32-bits.
        </li>
        <li class="li">
         Each wavefront can have at most 256 registers (VGPRs).
        </li>
        <li class="li">
         To compute the number of wavefronts per CU, take (256/# registers)*4.
        </li>
        <li class="li">
         For example, a kernel that uses 120 registers (120×32-bit values) can run with eight active wavefronts on each compute unit.
        </li>
        <li class="li">
         Because of the global limits described earlier, each compute unit is limited to 40 wavefronts; thus, kernels can use up to 25 registers (25×32-bit values) without affecting the number of wavefronts/compute unit.
        </li>
        <li class="li">
         AMD provides the following tools to examine the number of general-purpose registers (GPRs) used by the kernel.
        </li>
        <li class="li">
         The CodeXL GPU Profiler displays the number of GPRs used by the kernel.
        </li>
        <li class="li">
         Alternatively, the CodeXL GPU Profiler generates the ISA dump (described in See Analyzing Processor Kernels), which then can be searched for the string :NUM_GPRS .
        </li>
        <li class="li">
         The AMD APP KernelAnalyzer2 also shows the GPR used by the kernel, across a wide variety of GPU compilation targets.
        </li>
        <li class="li">
         The compiler generates spill code (shuffling values to, and from, memory) if it cannot fit all the live values into registers.
        </li>
        <li class="li">
         Spill code uses long-latency global memory and can have a large impact on performance.
        </li>
        <li class="li">
         Spilled registers can be cached in Southern Island devices, thus reducing the impact on performance.
        </li>
        <li class="li">
         The CodeXL GPU Profiler reports the static number of register spills in the ScratchReg field.
        </li>
        <li class="li">
         Generally, it is a good idea to re-write the algorithm to use fewer GPRs, or tune the work-group dimensions specified at launch time to expose more registers/kernel to the compiler, in order to reduce the scratch register usage to 0.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401334_pgfId-458289" xml:lang="en-US">
      <a name="50401334_pgfId-458289" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-458289" name="50401334_pgfId-458289" shape="rect">
        Specifying the Default Work-Group Size at Compile-Time 2-19
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The number of registers used by a work-item is determined when the kernel is compiled.
        </li>
        <li class="li">
         The user later specifies the size of the work-group.
        </li>
        <li class="li">
         Ideally, the OpenCL compiler knows the size of the work-group at compile-time, so it can make optimal register allocation decisions.
        </li>
        <li class="li">
         Without knowing the work-group size, the compiler must assume an upper-bound size to avoid allocating more registers in the work-item than the hardware actually contains.
        </li>
        <li class="li">
         OpenCL provides a mechanism to specify a work-group size that the compiler can use to optimize the register allocation.
        </li>
        <li class="li">
         In particular, specifying a smaller work-group size at compile time allows the compiler to allocate more registers for each kernel, which can avoid spill code and improve performance.
        </li>
        <li class="li">
         The kernel attribute syntax is: Section 6.7.2 of the OpenCL specification explains the attribute in more detail.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401334_pgfId-458253" xml:lang="en-US">
      <a name="50401334_pgfId-458253" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-458253" name="50401334_pgfId-458253" shape="rect">
        Local Memory (LDS) Size 2-19
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         In addition to registers, shared memory can also serve to limit the active wavefronts/compute unit.
        </li>
        <li class="li">
         Each compute unit has 64 kB of LDS, which is shared among all active work-groups.
        </li>
        <li class="li">
         Note that the maximum allocation size is 32 kB.
        </li>
        <li class="li">
         LDS is allocated on a per-work-group granularity, so it is possible (and useful) for multiple wavefronts to share the same local memory allocation.
        </li>
        <li class="li">
         However, large LDS allocations eventually limits the number of workgroups that can be active.
        </li>
        <li class="li">
         See Effect of LDS Usage on Wavefronts/CU1 provides more details about how LDS usage can impact the wavefronts/compute unit.
        </li>
        <li class="li">
         Assumes each work-group uses four wavefronts (the maximum supported by the AMD OpenCL SDK).
        </li>
        <li class="li">
         AMD provides the following tools to examine the amount of LDS used by the kernel: The CodeXL GPU Profiler displays the LDS usage.
        </li>
        <li class="li">
         See the LocalMem counter.
        </li>
        <li class="li">
         Alternatively, use the CodeXL GPU Profiler to generate the ISA dump (described in See Analyzing Processor Kernels), then search for the string SQ_LDS_ALLOC:SIZE in the ISA dump.
        </li>
        <li class="li">
         Note that the value is shown in hexadecimal format.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="50401334_pgfId-458820" xml:lang="en-US">
     <a name="50401334_pgfId-458820" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-458820" name="50401334_pgfId-458820" shape="rect">
       2.6.3 Partitioning the Work 2-20
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        In OpenCL, each kernel executes on an index point that exists in a global NDRange.
       </li>
       <li class="li">
        The partition of the NDRange can have a significant impact on performance; thus, it is recommended that the developer explicitly specify the global ( #work-groups ) and local ( #work-items/work-group ) dimensions, rather than rely on OpenCL to set these automatically (by setting local_work_size to NULL in clEnqueueNDRangeKernel ).
       </li>
       <li class="li">
        This section explains the guidelines for partitioning at the global, local, and work/kernel levels.
       </li>
      </ul>
     </div>
     <div class="topic concept nested4" id="50401334_pgfId-452491" xml:lang="en-US">
      <a name="50401334_pgfId-452491" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-452491" name="50401334_pgfId-452491" shape="rect">
        Global Work Size 2-21
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         OpenCL does not explicitly limit the number of work-groups that can be submitted with a clEnqueueNDRangeKernel command.
        </li>
        <li class="li">
         The hardware limits the available in-flight threads, but the OpenCL SDK automatically partitions a large number of work-groups into smaller pieces that the hardware can process.
        </li>
        <li class="li">
         For some large workloads, the amount of memory available to the GPU can be a limitation; the problem might require so much memory capacity that the GPU cannot hold it all.
        </li>
        <li class="li">
         In these cases, the programmer must partition the workload into multiple clEnqueueNDRangeKernel commands.
        </li>
        <li class="li">
         The available device memory can be obtained by querying clDeviceInfo .
        </li>
        <li class="li">
         At a minimum, ensure that the workload contains at least as many work-groups as the number of compute units in the hardware.
        </li>
        <li class="li">
         Work-groups cannot be split across multiple compute units, so if the number of work-groups is less than the available compute units, some units are idle.
        </li>
        <li class="li">
         Use clGetDeviceInfo(…CL_DEVICE_MAX_COMPUTE_UNITS) to determine the value dynamically.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401334_pgfId-452494" xml:lang="en-US">
      <a name="50401334_pgfId-452494" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-452494" name="50401334_pgfId-452494" shape="rect">
        Local Work Size (#Work-Items per Work-Group) 2-21
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         OpenCL limits the number of work-items in each group.
        </li>
        <li class="li">
         Call clDeviceInfo with the CL_DEVICE_MAX_WORK_GROUP_SIZE to determine the maximum number of work-groups supported by the hardware.
        </li>
        <li class="li">
         Currently, AMD GPUs with SDK 2.1 return 256 as the maximum number of work-items per work-group.
        </li>
        <li class="li">
         Note the number of work-items is the product of all work-group dimensions; for example, a work-group with dimensions 32×16 requires 512 work-items, which is not allowed with the current AMD OpenCL SDK.
        </li>
        <li class="li">
         The fundamental unit of work on AMD GPUs is called a wavefront.
        </li>
        <li class="li">
         Each wavefront consists of 64 work-items; thus, the optimal local work size is an integer multiple of 64 (specifically 64, 128, 192, or 256) work-items per work-group.
        </li>
        <li class="li">
         Work-items in the same work-group can share data through LDS memory and also use high-speed local atomic operations.
        </li>
        <li class="li">
         Thus, larger work-groups enable more work-items to efficiently share data, which can reduce the amount of slower global communication.
        </li>
        <li class="li">
         However, larger work-groups reduce the number of global work-groups, which, for small workloads, could result in idle compute units.
        </li>
        <li class="li">
         Generally, larger work-groups are better as long as the global range is big enough to provide 1-2 Work-Groups for each compute unit in the system; for small workloads it generally works best to reduce the work-group size in order to avoid idle compute units.
        </li>
        <li class="li">
         Note that it is possible to make the decision dynamically, when the kernel is launched, based on the launch dimensions and the target device characteristics.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401334_pgfId-457158" xml:lang="en-US">
      <a name="50401334_pgfId-457158" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-457158" name="50401334_pgfId-457158" shape="rect">
        Work-Group Dimensions vs Size 2-22
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The local NDRange can contain up to three dimensions, here labeled X, Y, and Z.
        </li>
        <li class="li">
         The X dimension is returned by get_local_id(0) , Y is returned by get_local_id(1) , and Z is returned by get_local_id(2) .
        </li>
        <li class="li">
         The GPU hardware schedules the kernels so that the X dimension moves fastest as the work-items are packed into wavefronts.
        </li>
        <li class="li">
         For example, the 128 threads in a 2D work-group of dimension 32×4 (X=32 and Y=4) are packed into two wavefronts as follows (notation shown in X,Y order).
        </li>
        <li class="li">
         The total number of work-items in the work-group is typically the most important parameter to consider, in particular when optimizing to hide latency by increasing wavefronts/compute unit.
        </li>
        <li class="li">
         However, the choice of XYZ dimensions for the same overall work-group size can have the following second-order effects.
        </li>
        <li class="li">
         Work-items in the same quarter-wavefront execute on the same cycle in the processing engine.
        </li>
        <li class="li">
         Thus, global memory coalescing and local memory bank conflicts can be impacted by dimension, particularly if the fast-moving X dimension is small.
        </li>
        <li class="li">
         Typically, it is best to choose an X dimension of at least 16, then optimize the memory patterns for a block of 16 work-items which differ by 1 in the X dimension.
        </li>
        <li class="li">
         Work-items in the same wavefront have the same program counter and execute the same instruction on each cycle.
        </li>
        <li class="li">
         The packing order can be important if the kernel contains divergent branches.
        </li>
        <li class="li">
         If possible, pack together work-items that are likely to follow the same direction when control-flow is encountered.
        </li>
        <li class="li">
         For example, consider an image-processing kernel where each work-item processes one pixel, and the control-flow depends on the color of the pixel.
        </li>
        <li class="li">
         It might be more likely that a square of 8×8 pixels is the same color than a 64×1 strip; thus, the 8×8 would see less divergence and higher performance.
        </li>
        <li class="li">
         When in doubt, a square 16×16 work-group size is a good start.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="50401334_pgfId-457368" xml:lang="en-US">
     <a name="50401334_pgfId-457368" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-457368" name="50401334_pgfId-457368" shape="rect">
       2.6.4 Summary of NDRange Optimizations 2-22
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        As shown above, execution range optimization is a complex topic with many interacting variables and which frequently requires some experimentation to determine the optimal values.
       </li>
       <li class="li">
        Some general guidelines are: Select the work-group size to be a multiple of 64, so that the wavefronts are fully populated.
       </li>
       <li class="li">
        Schedule at least four wavefronts per compute unit.
       </li>
       <li class="li">
        Latency hiding depends on both the number of wavefronts/compute unit, as well as the execution time for each kernel.
       </li>
       <li class="li">
        Generally, 8 to 32 wavefronts/compute unit is desirable, but this can vary significantly, depending on the complexity of the kernel and the available memory bandwidth.
       </li>
       <li class="li">
        The CodeXL GPU Profiler and associated performance counters can help to select an optimal value.
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="50401334_pgfId-451154" xml:lang="en-US">
    <a name="50401334_pgfId-451154" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-451154" name="50401334_pgfId-451154" shape="rect">
      2.7 Instruction Selection Optimizations 2-24
     </a>
    </h3>
    <div class="topic concept nested3" id="50401334_pgfId-459510" xml:lang="en-US">
     <a name="50401334_pgfId-459510" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-459510" name="50401334_pgfId-459510" shape="rect">
       2.7.1 Instruction Bandwidths 2-24
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        See Instruction Throughput (Operations/Cycle for Each Stream Processor) lists the throughput of instructions for GPUs.
       </li>
       <li class="li">
        Double-precision is supported on all Southern Islands devices at varying rates.
       </li>
       <li class="li">
        The use of single-precision calculation is encouraged, if that precision is acceptable.
       </li>
       <li class="li">
        Single-precision data is also half the size of double-precision, which requires less chip bandwidth and is not as demanding on the cache structures.
       </li>
       <li class="li">
        Generally, the throughput and latency for 32-bit integer operations is the same as for single-precision floating point operations.
       </li>
       <li class="li">
        24-bit integer MULs and MADs have four times the throughput of 32-bit integer multiplies.
       </li>
       <li class="li">
        24-bit signed and unsigned integers are natively supported on the Southern Islands family of devices.
       </li>
       <li class="li">
        The use of OpenCL built-in functions for mul24 and mad24 is encouraged.
       </li>
       <li class="li">
        Note that mul24 can be useful for array indexing operations.
       </li>
       <li class="li">
        Packed 16-bit and 8-bit operations are not natively supported; however, in cases where it is known that no overflow will occur, some algorithms may be able to effectively pack 2 to 4 values into the 32-bit registers natively supported by the hardware.
       </li>
       <li class="li">
        The MAD instruction is an IEEE-compliant multiply followed by an IEEE-compliant add; it has the same accuracy as two separate MUL/ADD operations.
       </li>
       <li class="li">
        No special compiler flags are required for the compiler to convert separate MUL/ADD operations to use the MAD instruction.
       </li>
       <li class="li">
        See Instruction Throughput (Operations/Cycle for Each Stream Processor) shows the throughput for each stream processing core.
       </li>
       <li class="li">
        To obtain the peak throughput for the whole device, multiply the number of stream cores and the engine clock.
       </li>
       <li class="li">
        For example, according to See Instruction Throughput (Operations/Cycle for Each Stream Processor), a Tahiti device can perform one double-precision ADD operations/2 cycles in each stream core.
       </li>
       <li class="li">
        An AMD Radeon  HD 7970 GPU has 2048 Stream Cores and an engine clock of 925 MHz, so the entire GPU has a throughput rate of (.5*2048*925 MHz) = 947 GFlops for double-precision adds.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401334_pgfId-459722" xml:lang="en-US">
     <a name="50401334_pgfId-459722" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-459722" name="50401334_pgfId-459722" shape="rect">
       2.7.2 AMD Media Instructions 2-25
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        AMD provides a set of media instructions for accelerating media processing.
       </li>
       <li class="li">
        Notably, the sum-of-absolute differences (SAD) operation is widely used in motion estimation algorithms.
       </li>
       <li class="li">
        For the Southern Islands family of devices, new media instructions have been added; these are available under the cl_amd_media_ops2 extensions.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401334_pgfId-459778" xml:lang="en-US">
     <a name="50401334_pgfId-459778" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-459778" name="50401334_pgfId-459778" shape="rect">
       2.7.3 Math Libraries 2-25
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The Southern Islands environment contains new instructions for increasing the previous performance of floating point division, trigonometric range reduction, certain type conversions with double-precision values, floating-point classification, and frexp/ldexp.
       </li>
       <li class="li">
        OpenCL supports two types of math library operation: native_function() and function() .
       </li>
       <li class="li">
        Native_functions are generally supported in hardware and can run substantially faster, although at somewhat lower accuracy.
       </li>
       <li class="li">
        The accuracy for the non-native functions is specified in section 7.4 of the OpenCL Specification.
       </li>
       <li class="li">
        The accuracy for the native functions is implementation-defined.
       </li>
       <li class="li">
        Developers are encouraged to use the native functions when performance is more important than accuracy.
       </li>
       <li class="li">
        Compared to previous families of GPUs, the accuracy of certain native functions is increased in the Southern Islands family.
       </li>
       <li class="li">
        We recommend retesting applications where native function accuracy was insufficient on previous GPU devices.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401334_pgfId-451159" xml:lang="en-US">
     <a name="50401334_pgfId-451159" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-451159" name="50401334_pgfId-451159" shape="rect">
       2.7.4 Compiler Optimizations 2-26
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The OpenCL compiler currently recognizes a few patterns and transforms them into a single instruction.
       </li>
       <li class="li">
        By following these patterns, a developer can generate highly efficient code.
       </li>
       <li class="li">
        The currently accepted patterns are: Bitfield extract on signed/unsigned integers.
       </li>
       <li class="li">
        where B and C are compile time constants, A is a 8/16/32bit integer type, and C is a mask.
       </li>
       <li class="li">
        Bitfield insert on signed/unsigned integers where B and E have no conflicting bits ( B^E == 0 ), B, C, E, and F are compile-time constants, and B and E are masks.
       </li>
       <li class="li">
        The first bit set in B is greater than the number of bits in E plus the first bit set in E, or the first bit set in E is greater than the number of bits in B plus the first bit set in B.
       </li>
       <li class="li">
        If B, C, E, or F are equivalent to the value 0, this optimization is also supported.
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="50401334_pgfId-520751" xml:lang="en-US">
    <a name="50401334_pgfId-520751" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-520751" name="50401334_pgfId-520751" shape="rect">
      2.8 Additional Performance Guidance 2-26
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       This section is a collection of performance tips for GPU compute and AMD-specific optimizations.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="50401334_pgfId-448804" xml:lang="en-US">
     <a name="50401334_pgfId-448804" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-448804" name="50401334_pgfId-448804" shape="rect">
       2.8.1 Loop Unroll  pragma  2-26
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The compiler directive #pragma unroll &lt;unroll-factor&gt; can be placed immediately prior to a loop as a hint to the compiler to unroll a loop.
       </li>
       <li class="li">
        &lt;unroll-factor&gt; must be a positive integer, 1 or greater.
       </li>
       <li class="li">
        When &lt;unroll-factor&gt; is 1, loop unrolling is disabled.
       </li>
       <li class="li">
        When &lt;unroll-factor&gt; is 2 or greater, the compiler uses this as a hint for the number of times the loop is to be unrolled.
       </li>
       <li class="li">
        Examples for using this loop follow.
       </li>
       <li class="li">
        No unrolling example: #pragma unroll 1 for (int i = 0; i &lt; n; i++) { … } Partial unrolling example: #pragma unroll 4 for (int i = 0; i &lt; 128; i++) { … } Currently, the unroll pragma requires that the loop boundaries can be determined at compile time.
       </li>
       <li class="li">
        Both loop bounds must be known at compile time.
       </li>
       <li class="li">
        If n is not given, it is equivalent to the number of iterations of the loop when both loop bounds are known.
       </li>
       <li class="li">
        If the unroll-factor is not specified, and the compiler can determine the loop count, the compiler fully unrolls the loop.
       </li>
       <li class="li">
        If the unroll-factor is not specified, and the compiler cannot determine the loop count, the compiler does no unrolling.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401334_pgfId-495342" xml:lang="en-US">
     <a name="50401334_pgfId-495342" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-495342" name="50401334_pgfId-495342" shape="rect">
       2.8.2 Memory Tiling 2-27
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        There are many possible physical memory layouts for images.
       </li>
       <li class="li">
        AMD Accelerated Parallel Processing devices can access memory in a tiled or in a linear arrangement.
       </li>
       <li class="li">
        Linear – A linear layout format arranges the data linearly in memory such that element addresses are sequential.
       </li>
       <li class="li">
        This is the layout that is familiar to CPU programmers.
       </li>
       <li class="li">
        This format must be used for OpenCL buffers; it can be used for images.
       </li>
       <li class="li">
        Tiled – A tiled layout format has a pre-defined sequence of element blocks arranged in sequential memory addresses (see See One Example of a Tiled Layout Format for a conceptual illustration).
       </li>
       <li class="li">
        A microtile consists of ABIJ; a macrotile consists of the top-left 16 squares for which the arrows are red.
       </li>
       <li class="li">
        Only images can use this format.
       </li>
       <li class="li">
        Translating from user address space to the tiled arrangement is transparent to the user.
       </li>
       <li class="li">
        Tiled memory layouts provide an optimized memory access pattern to make more efficient use of the RAM attached to the GPU compute device.
       </li>
       <li class="li">
        This can contribute to lower latency.
       </li>
       <li class="li">
        Memory access patterns in compute kernels are usually different from those in the pixel shaders.
       </li>
       <li class="li">
        Whereas the access pattern for pixel shaders is in a hierarchical, space-filling curve pattern and is tuned for tiled memory performance (generally for textures), the access pattern for a compute kernel is linear across each row before moving to the next row in the global id space.
       </li>
       <li class="li">
        This has an effect on performance, since pixel shaders have implicit blocking, and compute kernels do not.
       </li>
       <li class="li">
        If accessing a tiled image, best performance is achieved if the application tries to use workgroups with 16×16 (or 8×8) work-items.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401334_pgfId-446673" xml:lang="en-US">
     <a name="50401334_pgfId-446673" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-446673" name="50401334_pgfId-446673" shape="rect">
       2.8.3 General Tips 2-28
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Using dynamic pointer assignment in kernels that are executed on the GPU cause inefficient code generation.
       </li>
       <li class="li">
        Many OpenCL specification compiler options that are accepted by the AMD OpenCL compiler are not implemented.
       </li>
       <li class="li">
        The implemented options are -D , -I , w , Werror , -clsingle-precision-constant , -cl-opt-disable , and -cl-fp32-correctly-rounded-divide-sqrt .
       </li>
       <li class="li">
        Avoid declaring global arrays on the kernel’s stack frame as these typically cannot be allocated in registers and require expensive global memory operations.
       </li>
       <li class="li">
        Use predication rather than control-flow.
       </li>
       <li class="li">
        The predication allows the GPU to execute both paths of execution in parallel, which can be faster than attempting to minimize the work through clever control-flow.
       </li>
       <li class="li">
        The reason for this is that if no memory operation exists in a ?
       </li>
       <li class="li">
        : operator (also called a ternary operator), this operation is translated into a single cmov_logical instruction, which is executed in a single cycle.
       </li>
       <li class="li">
        An example of this is: Replace this with: In the first block of code, this translates into an IF/ELSE/ENDIF sequence of conditional code, each taking ~8 cycles.
       </li>
       <li class="li">
        If divergent, this code executes in ~36 clocks; otherwise, in ~28 clocks.
       </li>
       <li class="li">
        A branch not taken costs four cycles (one instruction slot); a branch taken adds four slots of latency to fetch instructions from the instruction cache, for a total of 16 clocks.
       </li>
       <li class="li">
        Since the execution mask is saved, then modified, then restored for the branch, ~12 clocks are added when divergent, ~8 clocks when not.
       </li>
       <li class="li">
        In the second block of code, the ?
       </li>
       <li class="li">
        : operator executes in the vector units, so no extra CF instructions are generated.
       </li>
       <li class="li">
        Since the instructions are sequentially dependent, this block of code executes in 12 cycles, for a 1.3x speed improvement.
       </li>
       <li class="li">
        To see this, the first cycle is the (A&gt;B) comparison, the result of which is input to the second cycle, which is the cmov_logical factor, bool, 1, -1.
       </li>
       <li class="li">
        The final cycle is a MAD instruction that: mad C, factor, D, C. If the ratio between conditional code and ALU instructions is low, this is a good pattern to remove the control flow.
       </li>
       <li class="li">
        Loop Unrolling OpenCL kernels typically are high instruction-per-clock applications.
       </li>
       <li class="li">
        Thus, the overhead to evaluate control-flow and execute branch instructions can consume a significant part of resource that otherwise can be used for high-throughput compute operations.
       </li>
       <li class="li">
        The AMD Accelerated Parallel Processing OpenCL compiler performs simple loop unrolling optimizations; however, for more complex loop unrolling, it may be beneficial to do this manually.
       </li>
       <li class="li">
        If possible, create a reduced-size version of your data set for easier debugging and faster turn-around on performance experimentation.
       </li>
       <li class="li">
        GPUs do not have automatic caching mechanisms and typically scale well as resources are added.
       </li>
       <li class="li">
        In many cases, performance optimization for the reduced-size data implementation also benefits the full-size algorithm.
       </li>
       <li class="li">
        When tuning an algorithm, it is often beneficial to code a simple but accurate algorithm that is retained and used for functional comparison.
       </li>
       <li class="li">
        GPU tuning can be an iterative process, so success requires frequent experimentation, verification, and performance measurement.
       </li>
       <li class="li">
        The profiling and analysis tools report statistics on a per-kernel granularity.
       </li>
       <li class="li">
        To narrow the problem further, it might be useful to remove or comment-out sections of code, then re-run the timing and profiling tool.
       </li>
       <li class="li">
        Avoid writing code with dynamic pointer assignment on the GPU.
       </li>
       <li class="li">
        For example: kernel void dyn_assign(global int* a, global int* b, global int* c) { global int* d; size_t idx = get_global_id(0); if (idx &amp; 1) { d = b; } else { d = c; } a[idx] = d[idx]; } This is inefficient because the GPU compiler must know the base pointer that every load comes from and in this situation, the compiler cannot determine what ‘d’ points to.
       </li>
       <li class="li">
        So, both B and C are assigned to the same GPU resource, removing the ability to do certain optimizations.
       </li>
       <li class="li">
        If the algorithm allows changing the work-group size, it is possible to get better performance by using larger work-groups (more work-items in each work-group) because the workgroup creation overhead is reduced.
       </li>
       <li class="li">
        On the other hand, the OpenCL CPU runtime uses a task-stealing algorithm at the work-group level, so when the kernel execution time differs because it contains conditions and/or loops of varying number of iterations, it might be better to increase the number of work-groups.
       </li>
       <li class="li">
        This gives the runtime more flexibility in scheduling work-groups to idle CPU cores.
       </li>
       <li class="li">
        Experimentation might be needed to reach optimal work-group size.
       </li>
       <li class="li">
        Since the AMD OpenCL runtime supports only in-order queuing, using clFinish() on a queue and queuing a blocking command gives the same result.
       </li>
       <li class="li">
        The latter saves the overhead of another API command.
       </li>
       <li class="li">
        For example: clEnqueueWriteBuffer(myCQ, buff, CL_FALSE, 0, buffSize, input, 0, NULL, NULL); clFinish(myCQ); is equivalent, for the AMD OpenCL runtime, to: clEnqueueWriteBuffer(myCQ, buff, CL_TRUE, 0, buffSize, input, 0, NULL, NULL);
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401334_pgfId-521164" xml:lang="en-US">
     <a name="50401334_pgfId-521164" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-521164" name="50401334_pgfId-521164" shape="rect">
       2.8.4 Guidance for CUDA Programmers Using OpenCL 2-30
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Porting from CUDA to OpenCL is relatively straightforward.
       </li>
       <li class="li">
        Multiple vendors have documents describing how to do this, including AMD: https://developer.amd.com/documentation/articles/pages/OpenCL-and-the-ATI-Stream-v2.0-Beta.aspx#four Some specific performance recommendations which differ from other GPU architectures: Use a workgroup size that is a multiple of 64.
       </li>
       <li class="li">
        CUDA code can use a workgroup size of 32; this uses only half the available compute resources on an AMD Radeon  HD 7970 GPU.
       </li>
       <li class="li">
        AMD GPUs have a very high single-precision flops capability (3.788 teraflops in a single AMD Radeon  HD 7970 GPU).
       </li>
       <li class="li">
        Algorithms that benefit from such throughput can deliver excellent performance on AMD Accelerated Parallel Processing hardware.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401334_pgfId-446698" xml:lang="en-US">
     <a name="50401334_pgfId-446698" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-446698" name="50401334_pgfId-446698" shape="rect">
       2.8.5 Guidance for CPU Programmers Using OpenCL to Program GPUs 2-30
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        OpenCL is the industry-standard toolchain for programming GPUs and parallel devices from many vendors.
       </li>
       <li class="li">
        It is expected that many programmers skilled in CPU programming will program GPUs for the first time using OpenCL.
       </li>
       <li class="li">
        This section provides some guidance for experienced programmers who are programming a GPU for the first time.
       </li>
       <li class="li">
        It specifically highlights the key differences in optimization strategy.
       </li>
       <li class="li">
        Study the local memory (LDS) optimizations.
       </li>
       <li class="li">
        These greatly affect the GPU performance.
       </li>
       <li class="li">
        Note the difference in the organization of local memory on the GPU as compared to the CPU cache.
       </li>
       <li class="li">
        Local memory is shared by many work-items (64 on Tahiti).
       </li>
       <li class="li">
        This contrasts with a CPU cache that normally is dedicated to a single work-item.
       </li>
       <li class="li">
        GPU kernels run well when they collaboratively load the shared memory.
       </li>
       <li class="li">
        GPUs have a large amount of raw compute horsepower, compared to memory bandwidth and to “control flow” bandwidth.
       </li>
       <li class="li">
        This leads to some high-level differences in GPU programming strategy.
       </li>
       <li class="li">
        A CPU-optimized algorithm may test branching conditions to minimize the workload.
       </li>
       <li class="li">
        On a GPU, it is frequently faster simply to execute the workload.
       </li>
       <li class="li">
        A CPU-optimized version can use memory to store and later load pre-computed values.
       </li>
       <li class="li">
        On a GPU, it frequently is faster to recompute values rather than saving them in registers.
       </li>
       <li class="li">
        Per-thread registers are a scarce resource on the CPU; in contrast, GPUs have many available per-thread register resources.
       </li>
       <li class="li">
        Use float4 and the OpenCL built-ins for vector types ( vload , vstore , etc.).
       </li>
       <li class="li">
        These enable the AMD Accelerated Parallel Processing OpenCL implementation to generate efficient, packed SSE instructions when running on the CPU.
       </li>
       <li class="li">
        Vectorization is an optimization that benefits both the AMD CPU and GPU.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401334_pgfId-521316" xml:lang="en-US">
     <a name="50401334_pgfId-521316" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-521316" name="50401334_pgfId-521316" shape="rect">
       2.8.6 Optimizing Kernel Code 2-31
      </a>
     </h3>
     <div class="topic concept nested4" id="50401334_pgfId-521317" xml:lang="en-US">
      <a name="50401334_pgfId-521317" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-521317" name="50401334_pgfId-521317" shape="rect">
        Using Vector Data Types 2-31
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The CPU contains a vector unit, which can be efficiently used if the developer is writing the code using vector data types.
        </li>
        <li class="li">
         For architectures before Bulldozer, the instruction set is called SSE, and the vector width is 128 bits.
        </li>
        <li class="li">
         For Bulldozer, there the instruction set is called AVX, for which the vector width is increased to 256 bits.
        </li>
        <li class="li">
         Using four-wide vector types (int4, float4, etc.)
        </li>
        <li class="li">
         is preferred, even with Bulldozer.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401334_pgfId-521255" xml:lang="en-US">
      <a name="50401334_pgfId-521255" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-521255" name="50401334_pgfId-521255" shape="rect">
        Local Memory 2-31
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The CPU does not benefit much from local memory; sometimes it is detrimental to performance.
        </li>
        <li class="li">
         As local memory is emulated on the CPU by using the caches, accessing local memory and global memory are the same speed, assuming the information from the global memory is in the cache.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401334_pgfId-521257" xml:lang="en-US">
      <a name="50401334_pgfId-521257" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-521257" name="50401334_pgfId-521257" shape="rect">
        Using Special CPU Instructions 2-31
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The Bulldozer family of CPUs supports FMA4 instructions, exchanging instructions of the form a*b+c with fma(a,b,c) or mad(a,b,c) allows for the use of the special hardware instructions for multiplying and adding.
        </li>
        <li class="li">
         There also is hardware support for OpenCL functions that give the new hardware implementation of rotating.
        </li>
        <li class="li">
         For example: can be written as a composition of mad instructions which use fused multiple add (FMA):
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401334_pgfId-521264" xml:lang="en-US">
      <a name="50401334_pgfId-521264" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-521264" name="50401334_pgfId-521264" shape="rect">
        Avoid Barriers When Possible 2-32
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Using barriers in a kernel on the CPU causes a significant performance penalty compared to the same kernel without barriers.
        </li>
        <li class="li">
         Use a barrier only if the kernel requires it for correctness, and consider changing the algorithm to reduce barriers usage.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="50401334_pgfId-521246" xml:lang="en-US">
     <a name="50401334_pgfId-521246" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-521246" name="50401334_pgfId-521246" shape="rect">
       2.8.7 Optimizing Kernels for Southern Island GPUs 2-32
      </a>
     </h3>
     <div class="topic concept nested4" id="50401334_pgfId-494706" xml:lang="en-US">
      <a name="50401334_pgfId-494706" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-494706" name="50401334_pgfId-494706" shape="rect">
        Remove Conditional Assignments 2-32
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         A conditional of the form “if-then-else” generates branching.
        </li>
        <li class="li">
         Use the select() function to replace these structures with conditional assignments that do not cause branching.
        </li>
        <li class="li">
         For example: becomes Note that if the body of the if statement contains an I/O, the if statement cannot be eliminated.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401334_pgfId-494711" xml:lang="en-US">
      <a name="50401334_pgfId-494711" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-494711" name="50401334_pgfId-494711" shape="rect">
        Bypass Short-Circuiting 2-32
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         A conditional expression with many terms can compile into nested conditional code due to the C-language requirement that expressions must short circuit.
        </li>
        <li class="li">
         To prevent this, move the expression out of the control flow statement.
        </li>
        <li class="li">
         For example: becomes The same applies to conditional expressions used in loop constructs ( do , while , for ).
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401334_pgfId-494717" xml:lang="en-US">
      <a name="50401334_pgfId-494717" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-494717" name="50401334_pgfId-494717" shape="rect">
        Unroll Small Loops 2-32
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         If the loop bounds are known, and the loop is small (less than 16 or 32 instructions), unrolling the loop usually increases performance.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401334_pgfId-494719" xml:lang="en-US">
      <a name="50401334_pgfId-494719" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-494719" name="50401334_pgfId-494719" shape="rect">
        Avoid Nested  if s 2-32
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Because the GPU is a Vector ALU architecture, there is a cost to executing an if-then-else block because both sides of the branch are evaluated, then one result is retained while the other is discarded.
        </li>
        <li class="li">
         When if blocks are nested, the results are twice as bad; in general, if blocks are nested k levels deep, 2^k nested conditional structures are generated.
        </li>
        <li class="li">
         In this situation, restructure the code to eliminate nesting.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401334_pgfId-494721" xml:lang="en-US">
      <a name="50401334_pgfId-494721" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-494721" name="50401334_pgfId-494721" shape="rect">
        Experiment With  do / while / for Loops 2-33
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         for loops can generate more conditional code than equivalent do or while loops.
        </li>
        <li class="li">
         Experiment with these different loop types to find the one with best performance.
        </li>
       </ul>
      </div>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="50401334_pgfId-521515" xml:lang="en-US">
    <a name="50401334_pgfId-521515" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401334_pgfId-521515" name="50401334_pgfId-521515" shape="rect">
      2.9 Specific Guidelines for Southern Islands GPUs 2-33
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       The AMD Southern Islands (SI) family of products is quite different from previous generations.
      </li>
      <li class="li">
       These are referred to as SI chips and are based on what is publicly called Graphics Core Next.
      </li>
      <li class="li">
       SI compute units are much different than those of previous chips.
      </li>
      <li class="li">
       With previous generations, a compute unit (Vector ALU) was VLIW in nature, so four (Cayman GPUs) or five (all other Evergreen/Northern Islands GPUs) instructions could be packed into a single ALU instruction slot (called a bundle).
      </li>
      <li class="li">
       It was not always easy to schedule instructions to fill all of these slots, so achieving peak ALU utilization was a challenge.
      </li>
      <li class="li">
       With SI GPUs, the compute units are now scalar; however, there now are four Vector ALUs per compute unit.
      </li>
      <li class="li">
       Each Vector ALU requires at least one wavefront scheduled to it to achieve peak ALU utilization.
      </li>
      <li class="li">
       Along with the four Vector ALUs within a compute unit, there is also a scalar unit.
      </li>
      <li class="li">
       The scalar unit is used to handle branching instructions, constant cache accesses, and other operations that occur per wavefront.
      </li>
      <li class="li">
       The advantage to having a scalar unit for each compute unit is that there are no longer large penalties for branching, aside from thread divergence.
      </li>
      <li class="li">
       The instruction set for SI is scalar, as are GPRs.
      </li>
      <li class="li">
       Also, the instruction set is no longer clause-based.
      </li>
      <li class="li">
       There are two types of GPRs: scalar GPRs (SGPRs) and vector GPRs (VGPRs).
      </li>
      <li class="li">
       Each Vector ALU has its own SGPR and VGPR pool.
      </li>
      <li class="li">
       There are 512 SGPRs and 256 VGPRs per Vector ALU.
      </li>
      <li class="li">
       VGPRs handle all vector instructions (any instruction that is handled per thread, such as v_add_f32 , a floating point add).
      </li>
      <li class="li">
       SGPRs are used for scalar instructions: any instruction that is executed once per wavefront, such as a branch, a scalar ALU instruction, and constant cache fetches.
      </li>
      <li class="li">
       (SGPRs are also used for constants, all buffer/texture definitions, and sampler definitions; some kernel arguments are stored, at least temporarily, in SGPRs.)
      </li>
      <li class="li">
       SGPR allocation is in increments of eight, and VGPR allocation is in increments of four.
      </li>
      <li class="li">
       These increments also represent the minimum allocation size of these resources.
      </li>
      <li class="li">
       Typical vector instructions execute in four cycles; typical scalar ALU instructions in one cycle.
      </li>
      <li class="li">
       This allows each compute unit to execute one Vector ALU and one scalar ALU instruction every four clocks (each compute unit is offset by one cycle from the previous one).
      </li>
      <li class="li">
       All Southern Islands GPUs have double-precision support.
      </li>
      <li class="li">
       For Tahiti (AMD Radeon  HD 79XX series), double precision adds run at one-half the single precision add rate.
      </li>
      <li class="li">
       Double-precision multiplies and MAD instructions run at one-quarter the floating-point rate.
      </li>
      <li class="li">
       The double-precision rate of Pitcairn (AMD Radeon  HD 78XX series) and Cape Verde (AMD Radeon  HD 77XX series) is one quarter that of Tahiti.
      </li>
      <li class="li">
       This also affects the performance of single-precision fused multiple add (FMA).
      </li>
      <li class="li">
       Similar to previous generations local data share (LDS) is a shared resource within a compute unit.
      </li>
      <li class="li">
       The maximum LDS allocation size for a work-group is still 32 kB, however each compute unit has a total of 64 kB of LDS.
      </li>
      <li class="li">
       On SI GPUs, LDS memory has 32 banks; thus, it is important to be aware of LDS bank conflicts on half-wavefront boundaries.
      </li>
      <li class="li">
       The allocation granularity for LDS is 256 bytes; the minimum size is 0 bytes.
      </li>
      <li class="li">
       It is much easier to achieve high LDS bandwidth use on SI hardware.
      </li>
      <li class="li">
       L1 cache is still shared within a compute unit.
      </li>
      <li class="li">
       The size has now increased to 16 kB per compute unit for all SI GPUs.
      </li>
      <li class="li">
       The caches now are read/write, so sharing data between work-items in a work-group (for example, when LDS does not suffice) is much faster.
      </li>
      <li class="li">
       It is possible to schedule a maximum of 10 wavefronts per vector unit, assuming there are no limitations by other resources, such as registers or local memory; but there is a limit of 16 work-groups per compute unit if the work-groups are larger than a single wavefront.
      </li>
      <li class="li">
       If the dispatch is larger than what can fit at once on the GPU, the GPU schedules new work-groups as others finish.
      </li>
      <li class="li">
       Since there are no more clauses in the SI instruction set architecture (ISA), the compiler inserts “wait” commands to indicate that the compute unit needs the results of a memory operation before proceeding.
      </li>
      <li class="li">
       If the scalar unit determines that a wait is required (the data is not yet ready), the Vector ALU can switch to another wavefront.
      </li>
      <li class="li">
       There are different types of wait commands, depending on the memory access.
      </li>
      <li class="li">
       Vectorization is no longer needed, nor desirable; in fact, it can affect performance because it requires a greater number of VGPRs for storage.
      </li>
      <li class="li">
       I is recommended not to combine work-items.
      </li>
      <li class="li">
       Register spilling is no greater a problem with four wavefronts per work-group than it is with one wavefront per work-group.
      </li>
      <li class="li">
       This is because each wavefront has the same number of SGPRs and VGPRs available in either case.
      </li>
      <li class="li">
       Read coalescing does not work for 64-bit data sizes.
      </li>
      <li class="li">
       This means reads for float2, int2, and double might be slower than expected.
      </li>
      <li class="li">
       Work-groups with 256 work-items can be used to ensure that each compute unit is being used.
      </li>
      <li class="li">
       Barriers now are much faster.
      </li>
      <li class="li">
       The engine is wider than previous generations; this means larger dispatches are required to keep the all the compute units busy.
      </li>
      <li class="li">
       A single wavefront can take twice as long to execute compared to previous generations (assuming ALU bound).
      </li>
      <li class="li">
       This is because GPUs with VLIW-4 could execute the four instructions in a VLIW bundle in eight clocks (typical), and SI GPUs can execute one vector instruction in four clocks (typical).
      </li>
      <li class="li">
       Execution of kernel dispatches can overlap if there are no dependencies between them and if there are resources available in the GPU.
      </li>
      <li class="li">
       This is critical when writing benchmarks it is important that the measurements are accurate and that “false dependencies” do not cause unnecessary slowdowns.
      </li>
      <li class="li">
       An example of false dependency is: If the output data is the same each time, then this is a false dependency because there is no reason to stall concurrent execution of dispatches.
      </li>
      <li class="li">
       To avoid stalls, use multiple output buffers.
      </li>
      <li class="li">
       The number of buffers required to get peak performance depends on the kernel.
      </li>
      <li class="li">
       See Resource Limits for Northern Islands and Southern Islands compares the resource limits for Northern Islands and Southern Islands GPUs.
      </li>
      <li class="li">
       See Northern Islands Compute Unit Arrangement provides a simplified picture showing the Northern Island compute unit arrangement.
      </li>
      <li class="li">
       See Southern Island Compute Unit Arrangement provides a simplified picture showing the Southern Island compute unit arrangement.
      </li>
     </ul>
    </div>
   </div>
  </div>
  <div class="topic concept nested1" id="50401371_pgfId-412605" xml:lang="en-US">
   <a name="50401371_pgfId-412605" shape="rect">
   </a>
   <h2 class="title topictitle1">
    <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-412605" name="50401371_pgfId-412605" shape="rect">
     Chapter 3 OpenCL Performance and
Optimization for Evergreen and Northern Islands Devices
    </a>
   </h2>
   <div class="body conbody">
    <ul class="ul">
     <li class="li">
      This chapter discusses performance and optimization when programming for AMD Accelerated Parallel Processing GPU compute devices that are part of the Southern Islands family, as well as CPUs and multiple devices.
     </li>
     <li class="li">
      Details specific to the Evergreen and Northern Islands families of GPUs are provided in See OpenCL Performance and Optimization for GCN Devices
     </li>
    </ul>
   </div>
   <div class="topic concept nested2" id="50401371_pgfId-472054" xml:lang="en-US">
    <a name="50401371_pgfId-472054" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-472054" name="50401371_pgfId-472054" shape="rect">
      3.1 Global Memory Optimization 3-1
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       See Memory System is a block diagram of the GPU memory system.
      </li>
      <li class="li">
       The up arrows are read paths, the down arrows are write paths.
      </li>
      <li class="li">
       WC is the write combine cache.
      </li>
      <li class="li">
       The GPU consists of multiple compute units.
      </li>
      <li class="li">
       Each compute unit contains 32 kB local (on-chip) memory, L1 cache, registers, and 16 processing element (PE).
      </li>
      <li class="li">
       Each processing element contains a five-way (or four-way, depending on the GPU type) VLIW processor.
      </li>
      <li class="li">
       Individual work-items execute on a single processing element; one or more work-groups execute on a single compute unit.
      </li>
      <li class="li">
       On a GPU, hardware schedules the work-items.
      </li>
      <li class="li">
       On the ATI Radeon ™ HD 5000 series of GPUs, hardware schedules groups of work-items, called wavefronts, onto stream cores; thus, work-items within a wavefront execute in lock-step; the same instruction is executed on different data.
      </li>
      <li class="li">
       The L1 cache is 8 kB per compute unit.
      </li>
      <li class="li">
       (For the ATI Radeon ™ HD 5870 GPU, this means 160 kB for the 20 compute units.)
      </li>
      <li class="li">
       The L1 cache bandwidth on the ATI Radeon ™ HD 5870 GPU is one terabyte per second: L1 Bandwidth = Compute Units * Wavefront Size/Compute Unit * EngineClock Multiple compute units share L2 caches.
      </li>
      <li class="li">
       The L2 cache size on the ATI Radeon ™ HD 5870 GPUs is 512 kB: L2 Cache Size = Number or channels * L2 per Channel The bandwidth between L1 caches and the shared L2 cache is 435 GB/s: L2 Bandwidth = Number of channels * Wavefront Size * Engine Clock The ATI Radeon ™ HD 5870 GPU has eight memory controllers (“Memory Channel” in See Memory System).
      </li>
      <li class="li">
       The memory controllers are connected to multiple banks of memory.
      </li>
      <li class="li">
       The memory is GDDR5, with a clock speed of 1200 MHz and a data rate of 4800 Mb/pin.
      </li>
      <li class="li">
       Each channel is 32-bits wide, so the peak bandwidth for the ATI Radeon ™ HD 5870 GPU is: (8 memory controllers) * (4800 Mb/pin) * (32 bits) * (1 B/8b) = 154 GB/s If two memory access requests are directed to the same controller, the hardware serializes the access.
      </li>
      <li class="li">
       This is called a channel conflict.
      </li>
      <li class="li">
       Similarly, if two memory access requests go to the same memory bank, hardware serializes the access.
      </li>
      <li class="li">
       This is called a bank conflict.
      </li>
      <li class="li">
       From a developer’s point of view, there is not much difference between channel and bank conflicts.
      </li>
      <li class="li">
       A large power of two stride results in a channel conflict; a larger power of two stride results in a bank conflict.
      </li>
      <li class="li">
       The size of the power of two stride that causes a specific type of conflict depends on the chip.
      </li>
      <li class="li">
       A stride that results in a channel conflict on a machine with eight channels might result in a bank conflict on a machine with four.
      </li>
      <li class="li">
       In this document, the term bank conflict is used to refer to either kind of conflict.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-472079" xml:lang="en-US">
     <a name="50401371_pgfId-472079" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-472079" name="50401371_pgfId-472079" shape="rect">
       3.1.1 Two Memory Paths 3-3
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        ATI Radeon  HD 5000 series graphics processors have two, independent memory paths between the compute units and the memory: FastPath performs only basic operations, such as loads and stores (data sizes must be a multiple of 32 bits).
       </li>
       <li class="li">
        This often is faster and preferred when there are no advanced operations.
       </li>
       <li class="li">
        CompletePath, supports additional advanced operations, including atomics and sub-32-bit (byte/short) data transfers.
       </li>
      </ul>
     </div>
     <div class="topic concept nested4" id="50401371_pgfId-472083" xml:lang="en-US">
      <a name="50401371_pgfId-472083" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-472083" name="50401371_pgfId-472083" shape="rect">
        Performance Impact of FastPath and CompletePath 3-3
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         There is a large difference in performance on ATI Radeon  HD 5000 series hardware between FastPath and CompletePath.
        </li>
        <li class="li">
         See FastPath (blue) vs CompletePath (red) Using float1 shows two kernels (one FastPath, the other CompletePath) and the delivered DRAM bandwidth for each kernel on the ATI Radeon ™ HD 5870 GPU.
        </li>
        <li class="li">
         Note that an atomic add forces CompletePath.
        </li>
        <li class="li">
         The kernel code follows.
        </li>
        <li class="li">
         Note that the atomic extension must be enabled under OpenCL 1.0.
        </li>
        <li class="li">
         See Bandwidths for 1D Copies lists the effective bandwidth and ratio to maximum bandwidth.
        </li>
        <li class="li">
         The difference in performance between FastPath and CompletePath is significant.
        </li>
        <li class="li">
         If your kernel uses CompletePath, consider if there is another way to approach the problem that uses FastPath.
        </li>
        <li class="li">
         OpenCL read-only images always use FastPath.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401371_pgfId-472136" xml:lang="en-US">
      <a name="50401371_pgfId-472136" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-472136" name="50401371_pgfId-472136" shape="rect">
        Determining The Used Path 3-4
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Since the path selection is done automatically by the OpenCL compiler, your kernel may be assigned to CompletePath.
        </li>
        <li class="li">
         This section explains the strategy the compiler uses, and how to find out what path was used.
        </li>
        <li class="li">
         The compiler is conservative when it selects memory paths.
        </li>
        <li class="li">
         The compiler often maps all user data into a single unordered access view (UAV),5 so a single atomic operation (even one that is not executed) may force all loads and stores to use CompletePath.
        </li>
        <li class="li">
         The effective bandwidth listing above shows two OpenCL kernels and the associated performance.
        </li>
        <li class="li">
         The first kernel uses the FastPath while the second uses the CompletePath.
        </li>
        <li class="li">
         The second kernel is forced to CompletePath because in CopyComplete, the compiler noticed the use of an atomic.
        </li>
        <li class="li">
         There are two ways to find out which path is used.
        </li>
        <li class="li">
         The first method uses the CodeXL GPU Profiler, which provides the following three performance counters for this purpose: CompletePath counter: The total bytes read and written through the CompletePath (supports atomics and non-32-bit types).
        </li>
        <li class="li">
         PathUtilization counter: The percentage of bytes read and written through the FastPath or CompletePath compared to the total number of bytes transferred over the bus.
        </li>
        <li class="li">
         The second method is static and lets you determine the path by looking at a machine-level ISA listing (using the AMD APP KernelAnalyzer2 in OpenCL).
        </li>
        <li class="li">
         FastPath operations appear in the listing as: The vfetch Instruction is a load type that in graphics terms is called a vertex fetch (the group control TEX indicates that the load uses the L1 cache.)
        </li>
        <li class="li">
         The instruction MEM_RAT_CACHELESS indicates that FastPath operations are used.
        </li>
        <li class="li">
         Loads in CompletePath are a split-phase operation.
        </li>
        <li class="li">
         In the first phase, hardware copies the old value of a memory location into a special buffer.
        </li>
        <li class="li">
         This is done by performing atomic operations on the memory location.
        </li>
        <li class="li">
         After the value has reached the buffer, a normal load is used to read the value.
        </li>
        <li class="li">
         Note that RAT stands for random access target, which is the same as an unordered access view (UAV); it allows, on DX11 hardware, writes to, and reads from, any arbitrary location in a buffer.
        </li>
        <li class="li">
         The listing shows: The instruction sequence means the following: MEM_RAT Read into a buffer using CompletePath, do no operation on the memory location, and send an ACK when done.
        </li>
        <li class="li">
         WAIT_ACK Suspend execution of the wavefront until the ACK is received.
        </li>
        <li class="li">
         If there is other work pending this might be free, but if there is no other work to be done this could take 100’s of cycles.
        </li>
        <li class="li">
         TEX Use the L1 cache for the next instruction.
        </li>
        <li class="li">
         VFETCH Do a load instruction to (finally) get the value.
        </li>
        <li class="li">
         Stores appear as: The instruction MEM_RAT_STORE is the store along the CompletePath.
        </li>
        <li class="li">
         MEM_RAT means CompletePath; MEM_RAT_CACHELESS means FastPath.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-472173" xml:lang="en-US">
     <a name="50401371_pgfId-472173" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-472173" name="50401371_pgfId-472173" shape="rect">
       3.1.2 Channel Conflicts 3-6
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The important concept is memory stride: the increment in memory address, measured in elements, between successive elements fetched or stored by consecutive work-items in a kernel.
       </li>
       <li class="li">
        Many important kernels do not exclusively use simple stride one accessing patterns; instead, they feature large non-unit strides.
       </li>
       <li class="li">
        For instance, many codes perform similar operations on each dimension of a two- or three-dimensional array.
       </li>
       <li class="li">
        Performing computations on the low dimension can often be done with unit stride, but the strides of the computations in the other dimensions are typically large values.
       </li>
       <li class="li">
        This can result in significantly degraded performance when the codes are ported unchanged to GPU systems.
       </li>
       <li class="li">
        A CPU with caches presents the same problem, large power-of-two strides force data into only a few cache lines.
       </li>
       <li class="li">
        One solution is to rewrite the code to employ array transpositions between the kernels.
       </li>
       <li class="li">
        This allows all computations to be done at unit stride.
       </li>
       <li class="li">
        Ensure that the time required for the transposition is relatively small compared to the time to perform the kernel calculation.
       </li>
       <li class="li">
        For many kernels, the reduction in performance is sufficiently large that it is worthwhile to try to understand and solve this problem.
       </li>
       <li class="li">
        In GPU programming, it is best to have adjacent work-items read or write adjacent memory addresses.
       </li>
       <li class="li">
        This is one way to avoid channel conflicts.
       </li>
       <li class="li">
        When the application has complete control of the access pattern and address generation, the developer must arrange the data structures to minimize bank conflicts.
       </li>
       <li class="li">
        Accesses that differ in the lower bits can run in parallel; those that differ only in the upper bits can be serialized.
       </li>
       <li class="li">
        In this example: where the lower bits are all the same, the memory requests all access the same bank on the same channel and are processed serially.
       </li>
       <li class="li">
        This is a low-performance pattern to be avoided.
       </li>
       <li class="li">
        When the stride is a power of 2 (and larger than the channel interleave), the loop above only accesses one channel of memory.
       </li>
       <li class="li">
        The hardware byte address bits are: On all ATI Radeon  HD 5000-series GPUs, the lower eight bits select an element within a channel.
       </li>
       <li class="li">
        The next set of bits select the channel.
       </li>
       <li class="li">
        The number of channel bits varies, since the number of channels is not the same on all parts.
       </li>
       <li class="li">
        With eight channels, three bits are used to select the channel; with two channels, a single bit is used.
       </li>
       <li class="li">
        The next set of bits selects the memory bank.
       </li>
       <li class="li">
        The number of bits used depends on the number of memory banks.
       </li>
       <li class="li">
        The remaining bits are the rest of the address.
       </li>
       <li class="li">
        On the ATI Radeon  HD 5870 GPU, the channel selection are bits 10:8 of the byte address.
       </li>
       <li class="li">
        This means a linear burst switches channels every 256 bytes.
       </li>
       <li class="li">
        Since the wavefront size is 64, channel conflicts are avoided if each work-item in a wave reads a different address from a 64-word region.
       </li>
       <li class="li">
        All ATI Radeon  HD 5000 series GPUs have the same layout: channel ends at bit 8, and the memory bank is to the left of the channel.
       </li>
       <li class="li">
        A burst of 2 kB (8 * 256 bytes) cycles through all the channels.
       </li>
       <li class="li">
        When calculating an address as y*width+x, but reading a burst on a column (incrementing y), only one memory channel of the system is used, since the width is likely a multiple of 256 words = 2048 bytes.
       </li>
       <li class="li">
        If the width is an odd multiple of 256B, then it cycles through all channels.
       </li>
       <li class="li">
        Similarly, the bank selection bits on the ATI Radeon  HD 5870 GPU are bits 14:11, so the bank switches every 2 kB.
       </li>
       <li class="li">
        A linear burst of 32 kB cycles through all banks and channels of the system.
       </li>
       <li class="li">
        If accessing a 2D surface along a column, with a y*width+x calculation, and the width is some multiple of 2 kB dwords (32 kB), then only 1 bank and 1 channel are accessed of the 16 banks and 8 channels available on this GPU.
       </li>
       <li class="li">
        All ATI Radeon  HD 5000-series GPUs have an interleave of 256 bytes (64 dwords).
       </li>
       <li class="li">
        If every work-item in a work-group references consecutive memory addresses and the address of work-item 0 is aligned to 256 bytes and each work-item fetches 32 bits, the entire wavefront accesses one channel.
       </li>
       <li class="li">
        Although this seems slow, it actually is a fast pattern because it is necessary to consider the memory access over the entire device, not just a single wavefront.
       </li>
       <li class="li">
        One or more work-groups execute on each compute unit.
       </li>
       <li class="li">
        On the ATI Radeon  HD 5000-series GPUs, work-groups are dispatched in a linear order, with x changing most rapidly.
       </li>
       <li class="li">
        For a single dimension, this is: DispatchOrder = get_group_id(0) For two dimensions, this is: DispatchOrder = get_group_id(0) + get_group_id(1) * get_num_groups(0) This is row-major-ordering of the blocks in the index space.
       </li>
       <li class="li">
        Once all compute units are in use, additional work-groups are assigned to compute units as needed.
       </li>
       <li class="li">
        Work-groups retire in order, so active work-groups are contiguous.
       </li>
       <li class="li">
        At any time, each compute unit is executing an instruction from a single wavefront.
       </li>
       <li class="li">
        In memory intensive kernels, it is likely that the instruction is a memory access.
       </li>
       <li class="li">
        Since there are eight channels on the ATI Radeon  HD 5870 GPU, at most eight of the compute units can issue a memory access operation in one cycle.
       </li>
       <li class="li">
        It is most efficient if the accesses from eight wavefronts go to different channels.
       </li>
       <li class="li">
        One way to achieve this is for each wavefront to access consecutive groups of 256 = 64 * 4 bytes.
       </li>
       <li class="li">
        An inefficient access pattern is if each wavefront accesses all the channels.
       </li>
       <li class="li">
        This is likely to happen if consecutive work-items access data that has a large power of two strides.
       </li>
       <li class="li">
        In the next example of a kernel for copying, the input and output buffers are interpreted as though they were 2D, and the work-group size is organized as 2D.
       </li>
       <li class="li">
        The kernel code is: By changing the width, the data type and the work-group dimensions, we get a set of kernels out of this code.
       </li>
       <li class="li">
        Given a 64×1 work-group size, each work-item reads a consecutive 32-bit address.
       </li>
       <li class="li">
        Given a 1×64 work-group size, each work-item reads a value separated by the width in a power of two bytes.
       </li>
       <li class="li">
        See Bandwidths for Different Launch Dimensions shows how much the launch dimension can affect performance.
       </li>
       <li class="li">
        It lists each kernel’s effective bandwidth and ratio to maximum bandwidth.
       </li>
       <li class="li">
        To avoid power of two strides: Add an extra column to the data matrix.
       </li>
       <li class="li">
        Change the work-group size so that it is not a power of 26.
       </li>
       <li class="li">
        It is best to use a width that causes a rotation through all of the memory channels, instead of using the same one repeatedly.
       </li>
       <li class="li">
        Change the kernel to access the matrix with a staggered offset.
       </li>
      </ul>
     </div>
     <div class="topic concept nested4" id="50401371_pgfId-472340" xml:lang="en-US">
      <a name="50401371_pgfId-472340" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-472340" name="50401371_pgfId-472340" shape="rect">
        Staggered Offsets 3-9
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Staggered offsets apply a coordinate transformation to the kernel so that the data is processed in a different order.
        </li>
        <li class="li">
         Unlike adding a column, this technique does not use extra space.
        </li>
        <li class="li">
         It is also relatively simple to add to existing code.
        </li>
        <li class="li">
         See Transformation to Staggered Offsets illustrates the transformation to staggered offsets.
        </li>
        <li class="li">
         The global ID values reflect the order that the hardware initiates work-groups.
        </li>
        <li class="li">
         The values of get group ID are in ascending launch order.
        </li>
        <li class="li">
         global_id(0) = get_group_id(0) * get_local_size(0) + get_local_id(0) global_id(1) = get_group_id(1) * get_local_size(1) + get_local_id(1) The hardware launch order is fixed, but it is possible to change the launch order, as shown in the following example.
        </li>
        <li class="li">
         Assume a work-group size of k x k, where k is a power of two, and a large 2D matrix of size 2n x 2m in row-major order.
        </li>
        <li class="li">
         If each work-group must process a block in column-order, the launch order does not work out correctly: consecutive work-groups execute down the columns, and the columns are a large power-of-two apart; so, consecutive work-groups access the same channel.
        </li>
        <li class="li">
         By introducing a transformation, it is possible to stagger the work-groups to avoid channel conflicts.
        </li>
        <li class="li">
         Since we are executing 2D work-groups, each work group is identified by four numbers.
        </li>
        <li class="li">
         get_group_id(1 ) – the y coordinate or the block within the row of the matrix.
        </li>
        <li class="li">
         get_global_id(0) – the x coordinate or the column of the matrix.
        </li>
        <li class="li">
         get_global_id(1) – the y coordinate or the row of the matrix.
        </li>
        <li class="li">
         To transform the code, add the following four lines to the top of the kernel.
        </li>
        <li class="li">
         Then, change the global IDs and group IDs to the staggered form.
        </li>
        <li class="li">
         The result is:
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401371_pgfId-472385" xml:lang="en-US">
      <a name="50401371_pgfId-472385" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-472385" name="50401371_pgfId-472385" shape="rect">
        Reads Of The Same Address 3-10
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Under certain conditions, one unexpected case of a channel conflict is that reading from the same address is a conflict, even on the FastPath.
        </li>
        <li class="li">
         This does not happen on the read-only memories, such as constant buffers, textures, or shader resource view (SRV); but it is possible on the read/write UAV memory or OpenCL global memory.
        </li>
        <li class="li">
         From a hardware standpoint, reads from a fixed address have the same upper bits, so they collide and are serialized.
        </li>
        <li class="li">
         To read in a single value, read the value in a single work-item, place it in local memory, and then use that location: Avoid: Use:
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-472397" xml:lang="en-US">
     <a name="50401371_pgfId-472397" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-472397" name="50401371_pgfId-472397" shape="rect">
       3.1.3 Float4 Or Float1 3-11
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The internal memory paths on ATI Radeon  HD 5000-series devices support 128-bit transfers.
       </li>
       <li class="li">
        This allows for greater bandwidth when transferring data in float4 format.
       </li>
       <li class="li">
        In certain cases (when the data size is a multiple of four), float4 operations are faster.
       </li>
       <li class="li">
        The performance of these kernels can be seen in See Two Kernels: One Using float4 (blue), the Other float1 (red).
       </li>
       <li class="li">
        Change to float4 after eliminating the conflicts.
       </li>
       <li class="li">
        The following code example has two kernels, both of which can do a simple copy, but Copy4 uses float4 data types.
       </li>
       <li class="li">
        Copying data as float4 gives the best result: 84% of absolute peak.
       </li>
       <li class="li">
        It also speeds up the 2D versions of the copy (see See Bandwidths Including float1 and float4).
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-472466" xml:lang="en-US">
     <a name="50401371_pgfId-472466" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-472466" name="50401371_pgfId-472466" shape="rect">
       3.1.4 Coalesced Writes 3-12
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        On some other vendor devices, it is important to reorder your data to use coalesced writes.
       </li>
       <li class="li">
        The ATI Radeon  HD 5000-series devices also support coalesced writes, but this optimization is less important than other considerations, such as avoiding bank conflicts.
       </li>
       <li class="li">
        In non-coalesced writes, each compute unit accesses the memory system in quarter-wavefront units.
       </li>
       <li class="li">
        The compute unit transfers a 32-bit address and one element-sized piece of data for each work-item.
       </li>
       <li class="li">
        This results in a total of 16 elements + 16 addresses per quarter-wavefront.
       </li>
       <li class="li">
        On ATI Radeon  HD 5000-series devices, processing quarter-wavefront requires two cycles before the data is transferred to the memory controller.
       </li>
       <li class="li">
        In coalesced writes, the compute unit transfers one 32-bit address and 16 element-sized pieces of data for each quarter-wavefront, for a total of 16 elements +1 address per quarter-wavefront.
       </li>
       <li class="li">
        For coalesced writes, processing quarter-wavefront takes one cycle instead of two.
       </li>
       <li class="li">
        While this is twice as fast, the times are small compared to the rate the memory controller can handle the data.
       </li>
       <li class="li">
        See See Effect of Varying Degrees of Coalescing – Coal (blue), NoCoal (red), Split (green).
       </li>
       <li class="li">
        On ATI Radeon  HD 5000-series devices, the coalescing is only done on the FastPath because it supports only 32-bit access.
       </li>
       <li class="li">
        If a work-item does not write, coalesce detection ignores it.
       </li>
       <li class="li">
        The first kernel Copy1 maximizes coalesced writes: work-item k writes to address k. The second kernel writes a shifted pattern: In each quarter-wavefront of 16 work-items, work-item k writes to address k-1, except the first work-item in each quarter-wavefront writes to address k+16.
       </li>
       <li class="li">
        There is not enough order here to coalesce on some other vendor machines.
       </li>
       <li class="li">
        Finally, the third kernel has work-item k write to address k when k is even, and write address 63-k when k is odd.
       </li>
       <li class="li">
        This pattern never coalesces.
       </li>
       <li class="li">
        Write coalescing can be an important factor for AMD GPUs.
       </li>
       <li class="li">
        The following are sample kernels with different coalescing patterns.
       </li>
       <li class="li">
        See Bandwidths Including Coalesced Writes lists the effective bandwidth and ratio to maximum bandwidth for each kernel type.
       </li>
       <li class="li">
        There is not much performance difference, although the coalesced version is slightly faster.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-472569" xml:lang="en-US">
     <a name="50401371_pgfId-472569" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-472569" name="50401371_pgfId-472569" shape="rect">
       3.1.5 Alignment 3-14
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The program in See Unaligned Access Using float1 shows how the performance of a simple, unaligned access (float1) of this kernel varies as the size of offset varies.
       </li>
       <li class="li">
        Each transfer was large (16 MB).
       </li>
       <li class="li">
        The performance gain by adjusting alignment is small, so generally this is not an important consideration on AMD GPUs.
       </li>
       <li class="li">
        See Bandwidths Including Unaligned Access lists the effective bandwidth and ratio to maximum bandwidth for each kernel type.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-472647" xml:lang="en-US">
     <a name="50401371_pgfId-472647" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-472647" name="50401371_pgfId-472647" shape="rect">
       3.1.6 Summary of Copy Performance 3-16
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The performance of a copy can vary greatly, depending on how the code is written.
       </li>
       <li class="li">
        The measured bandwidth for these copies varies from a low of 0.3 GB/s, to a high of 127 GB/s.
       </li>
       <li class="li">
        The recommended order of steps to improve performance is: Examine the data-set sizes and launch dimensions to see if you can eliminate bank conflicts.
       </li>
       <li class="li">
        Try to use float4 instead of float1.
       </li>
       <li class="li">
        Try to change the access pattern to allow write coalescing.
       </li>
       <li class="li">
        This is important on some hardware platforms, but only of limited importance for AMD GPU devices.
       </li>
       <li class="li">
        Finally, look at changing the access pattern to allow data alignment.
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="50401371_pgfId-481974" xml:lang="en-US">
    <a name="50401371_pgfId-481974" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-481974" name="50401371_pgfId-481974" shape="rect">
      3.2 Local Memory (LDS) Optimization 3-16
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       AMD Evergreen GPUs include a Local Data Store (LDS) cache, which accelerates local memory accesses.
      </li>
      <li class="li">
       LDS is not supported in OpenCL on AMD R700-family GPUs.
      </li>
      <li class="li">
       LDS provides high-bandwidth access (more than 10X higher than global memory), efficient data transfers between work-items in a work-group, and high-performance atomic support.
      </li>
      <li class="li">
       Local memory offers significant advantages when the data is re-used; for example, subsequent accesses can read from local memory, thus reducing global memory bandwidth.
      </li>
      <li class="li">
       Another advantage is that local memory does not require coalescing.
      </li>
      <li class="li">
       To determine local memory size: All AMD Evergreen GPUs contain a 32K LDS for each compute unit.
      </li>
      <li class="li">
       On high-end GPUs, the LDS contains 32-banks, each bank is four bytes wide and 256 bytes deep; the bank address is determined by bits 6:2 in the address.
      </li>
      <li class="li">
       On lower-end GPUs, the LDS contains 16 banks, each bank is still 4 bytes in size, and the bank used is determined by bits 5:2 in the address.
      </li>
      <li class="li">
       As shown below, programmers should carefully control the bank bits to avoid bank conflicts as much as possible.
      </li>
      <li class="li">
       In a single cycle, local memory can service a request for each bank (up to 32 accesses each cycle on the ATI Radeon  HD 5870 GPU).
      </li>
      <li class="li">
       For an ATI Radeon  HD 5870 GPU, this delivers a memory bandwidth of over 100 GB/s for each compute unit, and more than 2 TB/s for the whole chip.
      </li>
      <li class="li">
       This is more than 14X the global memory bandwidth.
      </li>
      <li class="li">
       However, accesses that map to the same bank are serialized and serviced on consecutive cycles.
      </li>
      <li class="li">
       A wavefront that generates bank conflicts stalls on the compute unit until all LDS accesses have completed.
      </li>
      <li class="li">
       The GPU reprocesses the wavefront on subsequent cycles, enabling only the lanes receiving data, until all the conflicting accesses complete.
      </li>
      <li class="li">
       The bank with the most conflicting accesses determines the latency for the wavefront to complete the local memory operation.
      </li>
      <li class="li">
       The worst case occurs when all 64 work-items map to the same bank, since each access then is serviced at a rate of one per clock cycle; this case takes 64 cycles to complete the local memory access for the wavefront.
      </li>
      <li class="li">
       A program with a large number of bank conflicts (as measured by the LDSBankConflict performance counter) might benefit from using the constant or image memory rather than LDS.
      </li>
      <li class="li">
       Thus, the key to effectively using the local cache memory is to control the access pattern so that accesses generated on the same cycle map to different banks in the local memory.
      </li>
      <li class="li">
       One notable exception is that accesses to the same address (even though they have the same bits 6:2) can be broadcast to all requestors and do not generate a bank conflict.
      </li>
      <li class="li">
       The LDS hardware examines the requests generated over two cycles (32 work-items of execution) for bank conflicts.
      </li>
      <li class="li">
       Ensure, as much as possible, that the memory requests generated from a quarter-wavefront avoid bank conflicts by using unique address bits 6:2.
      </li>
      <li class="li">
       A simple sequential address pattern, where each work-item reads a float2 value from LDS, generates a conflict-free access pattern on the ATI Radeon  HD 5870 GPU.
      </li>
      <li class="li">
       Note that a sequential access pattern, where each work-item reads a float4 value from LDS, uses only half the banks on each cycle on the ATI Radeon  HD 5870 GPU and delivers half the performance of the float access pattern.
      </li>
      <li class="li">
       Each stream processor can generate up to two 4-byte LDS requests per cycle.
      </li>
      <li class="li">
       Byte and short reads consume four bytes of LDS bandwidth.
      </li>
      <li class="li">
       Since each stream processor can execute five operations (or four, depending on the GPU type) in the VLIW each cycle (typically requiring 10-15 input operands), two local memory requests might not provide enough bandwidth to service the entire instruction.
      </li>
      <li class="li">
       Developers can use the large register file: each compute unit has 256 kB of register space available (8X the LDS size) and can provide up to twelve 4-byte values/cycle (6X the LDS bandwidth).
      </li>
      <li class="li">
       Registers do not offer the same indexing flexibility as does the LDS, but for some algorithms this can be overcome with loop unrolling and explicit addressing.
      </li>
      <li class="li">
       LDS reads require one ALU operation to initiate them.
      </li>
      <li class="li">
       Each operation can initiate two loads of up to four bytes each.
      </li>
      <li class="li">
       The CodeXL GPU Profiler provides the following performance counter to help optimize local memory usage: LDSBankConflict : The percentage of time accesses to the LDS are stalled due to bank conflicts relative to GPU Time.
      </li>
      <li class="li">
       In the ideal case, there are no bank conflicts in the local memory access, and this number is zero.
      </li>
      <li class="li">
       Local memory is software-controlled “scratchpad” memory.
      </li>
      <li class="li">
       In contrast, caches typically used on CPUs monitor the access stream and automatically capture recent accesses in a tagged cache.
      </li>
      <li class="li">
       The scratchpad allows the kernel to explicitly load items into the memory; they exist in local memory until the kernel replaces them, or until the work-group ends.
      </li>
      <li class="li">
       To declare a block of local memory, use the __local keyword; for example: These declarations can be either in the parameters to the kernel call or in the body of the kernel.
      </li>
      <li class="li">
       The __local syntax allocates a single block of memory, which is shared across all work-items in the workgroup.
      </li>
      <li class="li">
       To write data into local memory, write it into an array allocated with __local .
      </li>
      <li class="li">
       For example: A typical access pattern is for each work-item to collaboratively write to the local memory: each work-item writes a subsection, and as the work-items execute in parallel they write the entire array.
      </li>
      <li class="li">
       Combined with proper consideration for the access pattern and bank alignment, these collaborative write approaches can lead to highly efficient memory accessing.
      </li>
      <li class="li">
       Local memory is consistent across work-items only at a work-group barrier; thus, before reading the values written collaboratively, the kernel must include a barrier() instruction.
      </li>
      <li class="li">
       The following example is a simple kernel section that collaboratively writes, then reads from, local memory: __kernel void localMemoryExample (__global float *In, __global float *Out) { __local float localBuffer[64]; uint tx = get_local_id(0); uint gx = get_global_id(0); // Initialize local memory: // Copy from this work-group’s section of global memory to local: // Each work-item writes one element; together they write it all localBuffer[tx] = In[gx]; // Ensure writes have completed: barrier(CLK_LOCAL_MEM_FENCE); // Toy computation to compute a partial factorial, shows re-use from local float f = localBuffer[tx]; for (uint i=tx+1; i&lt;64; i++) { f *= localBuffer[i]; } Out[gx] = f; } Note the host code cannot read from, or write to, local memory.
      </li>
      <li class="li">
       Only the kernel can access local memory.
      </li>
      <li class="li">
       Local memory is consistent across work-items only at a work-group barrier; thus, before reading the values written collaboratively, the kernel must include a barrier() instruction.
      </li>
      <li class="li">
       An important optimization is the case where the local work-group size is less than, or equal to, the wavefront size.
      </li>
      <li class="li">
       Because the wavefront executes as an atomic unit, the explicit barrier operation is not required.
      </li>
      <li class="li">
       The compiler automatically removes these barriers if the kernel specifies a reqd_work_group_size (see section 5.8 of the OpenCL Specification) that is less than the wavefront size.
      </li>
      <li class="li">
       Developers are strongly encouraged to include the barriers where appropriate, and rely on the compiler to remove the barriers when possible, rather than manually removing the barriers() .
      </li>
      <li class="li">
       This technique results in more portable code, including the ability to run kernels on CPU devices.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="50401371_pgfId-448213" xml:lang="en-US">
    <a name="50401371_pgfId-448213" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-448213" name="50401371_pgfId-448213" shape="rect">
      3.3 Constant Memory Optimization 3-19
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       The AMD implementation of OpenCL provides three levels of performance for the “constant” memory type.
      </li>
      <li class="li">
       Very high bandwidth can be attained when the compiler has available the constant address at compile time and can embed the constant address into the instruction.
      </li>
      <li class="li">
       Each processing element can load up to 4×4-byte direct-addressed constant values each cycle.
      </li>
      <li class="li">
       Typically, these cases are limited to simple non-array constants and function parameters.
      </li>
      <li class="li">
       The GPU loads the constants into a hardware cache at the beginning of the clause that uses the constants.
      </li>
      <li class="li">
       The cache is a tagged cache, typically each 8k blocks is shared among four compute units.
      </li>
      <li class="li">
       If the constant data is already present in the constant cache, the load is serviced by the cache and does not require any global memory bandwidth.
      </li>
      <li class="li">
       The constant cache size for each device varies from 4k to 48k per GPU.
      </li>
      <li class="li">
       Same Index Hardware acceleration also takes place when all work-items in a wavefront reference the same constant address.
      </li>
      <li class="li">
       In this case, the data is loaded from memory one time, stored in the L1 cache, and then broadcast to all wave-fronts.
      </li>
      <li class="li">
       This can reduce significantly the required memory bandwidth.
      </li>
      <li class="li">
       Varying Index More sophisticated addressing patterns, including the case where each work-item accesses different indices, are not hardware accelerated and deliver the same performance as a global memory read with the potential for cache hits.
      </li>
      <li class="li">
       To further improve the performance of the AMD OpenCL stack, two methods allow users to take advantage of hardware constant buffers.
      </li>
      <li class="li">
       These are: Per-pointer attribute specifying the maximum pointer size.
      </li>
      <li class="li">
       This is specified using the max_constant_size(N) attribute.
      </li>
      <li class="li">
       The attribute form conforms to section 6.10 of the OpenCL 1.0 specification.
      </li>
      <li class="li">
       This attribute is restricted to top-level kernel function arguments in the constant address space.
      </li>
      <li class="li">
       This restriction prevents a pointer of one size from being passed as an argument to a function that declares a different size.
      </li>
      <li class="li">
       It informs the compiler that indices into the pointer remain inside this range and it is safe to allocate a constant buffer in hardware, if it fits.
      </li>
      <li class="li">
       Using a constant pointer that goes outside of this range results in undefined behavior.
      </li>
      <li class="li">
       All allocations are aligned on the 16-byte boundary.
      </li>
      <li class="li">
       For example: A kernel that uses constant buffers must use CL_DEVICE_MAX_CONSTANT_ARGS to query the device for the maximum number of constant buffers the kernel can support.
      </li>
      <li class="li">
       This value might differ from the maximum number of hardware constant buffers available.
      </li>
      <li class="li">
       In this case, if the number of hardware constant buffers is less than the CL_DEVICE_MAX_CONSTANT_ARGS , the compiler allocates the largest constant buffers in hardware first and allocates the rest of the constant buffers in global memory.
      </li>
      <li class="li">
       As an optimization, if a constant pointer A uses n bytes of memory, where n is less than 64 kB, and constant pointer B uses m bytes of memory, where m is less than (64 kB – n) bytes of memory, the compiler can allocate the constant buffer pointers in a single hardware constant buffer.
      </li>
      <li class="li">
       This optimization can be applied recursively by treating the resulting allocation as a single allocation and finding the next smallest constant pointer that fits within the space left in the constant buffer.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="50401371_pgfId-449206" xml:lang="en-US">
    <a name="50401371_pgfId-449206" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-449206" name="50401371_pgfId-449206" shape="rect">
      3.4 OpenCL Memory Resources: Capacity and Performance 3-20
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       See Hardware Performance Parameters summarizes the hardware capacity and associated performance for the structures associated with the five OpenCL Memory Types.
      </li>
      <li class="li">
       This information specific to the ATI Radeon  HD5870 GPUs with 1 GB video memory.
      </li>
      <li class="li">
       The compiler tries to map private memory allocations to the pool of GPRs in the GPU.
      </li>
      <li class="li">
       In the event GPRs are not available, private memory is mapped to the “scratch” region, which has the same performance as global memory.
      </li>
      <li class="li">
       See Resource Limits on Active Wavefronts, has more information on register allocation and identifying when the compiler uses the scratch region.
      </li>
      <li class="li">
       GPRs provide the highest-bandwidth access of any hardware resource.
      </li>
      <li class="li">
       In addition to reading up to 48 bytes/cycle from the register file, the hardware can access results produced in the previous cycle (through the Previous Vector/Previous Scalar register) without consuming any register file bandwidth.
      </li>
      <li class="li">
       GPRs have some restrictions about which register ports can be read on each cycle; but generally, these are not exposed to the OpenCL programmer.
      </li>
      <li class="li">
       Same-indexed constants can be cached in the L1 and L2 cache.
      </li>
      <li class="li">
       Note that “same-indexed” refers to the case where all work-items in the wavefront reference the same constant index on the same cycle.
      </li>
      <li class="li">
       The performance shown assumes an L1 cache hit.
      </li>
      <li class="li">
       Varying-indexed constants use the same path as global memory access and are subject to the same bank and alignment constraints described in See Global Memory Optimization.
      </li>
      <li class="li">
       The L1 and L2 caches are currently only enabled for images and same-indexed constants.
      </li>
      <li class="li">
       As of SDK 2.4, read only buffers can be cached in L1 and L2.
      </li>
      <li class="li">
       To enable this, the developer must indicate to the compiler that the buffer is read only and does not alias with other buffers.
      </li>
      <li class="li">
       For example, use: The const indicates to the compiler that mypointerName is read only from the kernel, and the restrict attribute indicates to the compiler that no other pointer aliases with mypointerName .
      </li>
      <li class="li">
       The L1 cache can service up to four address request per cycle, each delivering up to 16 bytes.
      </li>
      <li class="li">
       The bandwidth shown assumes an access size of 16 bytes; smaller access sizes/requests result in a lower peak bandwidth for the L1 cache.
      </li>
      <li class="li">
       Using float4 with images increases the request size and can deliver higher L1 cache bandwidth.
      </li>
      <li class="li">
       Each memory channel on the GPU contains an L2 cache that can deliver up to 64 bytes/cycle.
      </li>
      <li class="li">
       The ATI Radeon  HD 5870 GPU has eight memory channels; thus, it can deliver up to 512bytes/cycle; divided among 320 stream cores, this provides up to ~1.6 bytes/cycle for each stream core.
      </li>
      <li class="li">
       Global Memory bandwidth is limited by external pins, not internal bus bandwidth.
      </li>
      <li class="li">
       The ATI Radeon  HD 5870 GPU supports up to 153 GB/s of memory bandwidth which is an average of 0.6 bytes/cycle for each stream core.
      </li>
      <li class="li">
       Note that See Hardware Performance Parameters shows the performance for the ATI Radeon  HD 5870 GPU.
      </li>
      <li class="li">
       The “Size/Compute Unit” column and many of the bandwidths/processing element apply to all Evergreen-class GPUs; however, the “Size/GPU” column and the bandwidths for varying-indexed constant, L2, and global memory vary across different GPU devices.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="50401371_pgfId-487708" xml:lang="en-US">
    <a name="50401371_pgfId-487708" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-487708" name="50401371_pgfId-487708" shape="rect">
      3.5 Using LDS or L1 Cache 3-22
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       There are a number of considerations when deciding between LDS and L1 cache for a given algorithm.
      </li>
      <li class="li">
       LDS supports read/modify/write operations, as well as atomics.
      </li>
      <li class="li">
       It is well-suited for code that requires fast read/write, read/modify/write, or scatter operations that otherwise are directed to global memory.
      </li>
      <li class="li">
       On current AMD hardware, L1 is part of the read path; hence, it is suited to cache-read-sensitive algorithms, such as matrix multiplication or convolution.
      </li>
      <li class="li">
       LDS is typically larger than L1 (for example: 32 kB vs 8 kB on Cypress).
      </li>
      <li class="li">
       If it is not possible to obtain a high L1 cache hit rate for an algorithm, the larger LDS size can help.
      </li>
      <li class="li">
       The theoretical LDS peak bandwidth is 2 TB/s, compared to L1 at 1 TB/sec.
      </li>
      <li class="li">
       Currently, OpenCL is limited to 1 TB/sec LDS bandwidth.
      </li>
      <li class="li">
       The native data type for L1 is a four-vector of 32-bit words.
      </li>
      <li class="li">
       On L1, fill and read addressing are linked.
      </li>
      <li class="li">
       It is important that L1 is initially filled from global memory with a coalesced access pattern; once filled, random accesses come at no extra processing cost.
      </li>
      <li class="li">
       Currently, the native format of LDS is a 32-bit word.
      </li>
      <li class="li">
       The theoretical LDS peak bandwidth is achieved when each thread operates on a two-vector of 32-bit words (16 threads per clock operate on 32 banks).
      </li>
      <li class="li">
       If an algorithm requires coalesced 32-bit quantities, it maps well to LDS.
      </li>
      <li class="li">
       The use of four-vectors or larger can lead to bank conflicts.
      </li>
      <li class="li">
       From an application point of view, filling LDS from global memory, and reading from it, are independent operations that can use independent addressing.
      </li>
      <li class="li">
       Thus, LDS can be used to explicitly convert a scattered access pattern to a coalesced pattern for read and write to global memory.
      </li>
      <li class="li">
       Or, by taking advantage of the LDS read broadcast feature, LDS can be filled with a coalesced pattern from global memory, followed by all threads iterating through the same LDS words simultaneously.
      </li>
      <li class="li">
       LDS is shared between the work-items in a work-group.
      </li>
      <li class="li">
       Sharing across work-groups is not possible because OpenCL does not guarantee that LDS is in a particular state at the beginning of work-group execution.
      </li>
      <li class="li">
       L1 content, on the other hand, is independent of work-group execution, so that successive work-groups can share the content in the L1 cache of a given Vector ALU.
      </li>
      <li class="li">
       However, it currently is not possible to explicitly control L1 sharing across work-groups.
      </li>
      <li class="li">
       The use of LDS is linked to GPR usage and wavefront-per-Vector ALU count.
      </li>
      <li class="li">
       Better sharing efficiency requires a larger work-group, so that more work items share the same LDS.
      </li>
      <li class="li">
       Compiling kernels for larger work groups typically results in increased register use, so that fewer wavefronts can be scheduled simultaneously per Vector ALU.
      </li>
      <li class="li">
       This, in turn, reduces memory latency hiding.
      </li>
      <li class="li">
       Requesting larger amounts of LDS per work-group results in fewer wavefronts per Vector ALU, with the same effect.
      </li>
      <li class="li">
       LDS typically involves the use of barriers, with a potential performance impact.
      </li>
      <li class="li">
       This is true even for read-only use cases, as LDS must be explicitly filled in from global memory (after which a barrier is required before reads can commence).
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="50401371_pgfId-487709" xml:lang="en-US">
    <a name="50401371_pgfId-487709" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-487709" name="50401371_pgfId-487709" shape="rect">
      3.6 NDRange and Execution Range Optimization 3-23
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       Probably the most effective way to exploit the potential performance of the GPU is to provide enough threads to keep the device completely busy.
      </li>
      <li class="li">
       The programmer specifies a three-dimensional NDRange over which to execute the kernel; bigger problems with larger NDRanges certainly help to more effectively use the machine.
      </li>
      <li class="li">
       The programmer also controls how the global NDRange is divided into local ranges, as well as how much work is done in each work-item, and which resources (registers and local memory) are used by the kernel.
      </li>
      <li class="li">
       All of these can play a role in how the work is balanced across the machine and how well it is used.
      </li>
      <li class="li">
       This section introduces the concept of latency hiding, how many wavefronts are required to hide latency on AMD GPUs, how the resource usage in the kernel can impact the active wavefronts, and how to choose appropriate global and local work-group dimensions.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-473708" xml:lang="en-US">
     <a name="50401371_pgfId-473708" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-473708" name="50401371_pgfId-473708" shape="rect">
       3.6.1 Hiding ALU and Memory Latency 3-23
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The read-after-write latency for most arithmetic operations (a floating-point add, for example) is only eight cycles.
       </li>
       <li class="li">
        For most AMD GPUs, each compute unit can execute 16 VLIW instructions on each cycle.
       </li>
       <li class="li">
        Each wavefront consists of 64 work-items; each compute unit executes a quarter-wavefront on each cycle, and the entire wavefront is executed in four consecutive cycles.
       </li>
       <li class="li">
        Thus, to hide eight cycles of latency, the program must schedule two wavefronts.
       </li>
       <li class="li">
        The compute unit executes the first wavefront on four consecutive cycles; it then immediately switches and executes the other wavefront for four cycles.
       </li>
       <li class="li">
        Eight cycles have elapsed, and the ALU result from the first wavefront is ready, so the compute unit can switch back to the first wavefront and continue execution.
       </li>
       <li class="li">
        Compute units running two wavefronts (128 threads) completely hide the ALU pipeline latency.
       </li>
       <li class="li">
        Global memory reads generate a reference to the off-chip memory and experience a latency of 300 to 600 cycles.
       </li>
       <li class="li">
        The wavefront that generates the global memory access is made idle until the memory request completes.
       </li>
       <li class="li">
        During this time, the compute unit can process other independent wavefronts, if they are available.
       </li>
       <li class="li">
        Kernel execution time also plays a role in hiding memory latency: longer kernels keep the functional units busy and effectively hide more latency.
       </li>
       <li class="li">
        To better understand this concept, consider a global memory access which takes 400 cycles to execute.
       </li>
       <li class="li">
        Assume the compute unit contains many other wavefronts, each of which performs five ALU instructions before generating another global memory reference.
       </li>
       <li class="li">
        As discussed previously, the hardware executes each instruction in the wavefront in four cycles; thus, all five instructions occupy the ALU for 20 cycles.
       </li>
       <li class="li">
        Note the compute unit interleaves two of these wavefronts and executes the five instructions from both wavefronts (10 total instructions) in 40 cycles.
       </li>
       <li class="li">
        To fully hide the 400 cycles of latency, the compute unit requires (400/40) = 10 pairs of wavefronts, or 20 total wavefronts.
       </li>
       <li class="li">
        If the wavefront contains 10 instructions rather than 5, the wavefront pair would consume 80 cycles of latency, and only 10 wavefronts would be required to hide the 400 cycles of latency.
       </li>
       <li class="li">
        Generally, it is not possible to predict how the compute unit schedules the available wavefronts, and thus it is not useful to try to predict exactly which ALU block executes when trying to hide latency.
       </li>
       <li class="li">
        Instead, consider the overall ratio of ALU operations to fetch operations – this metric is reported by the CodeXL GPU Profiler in the ALUFetchRatio counter.
       </li>
       <li class="li">
        Each ALU operation keeps the compute unit busy for four cycles, so you can roughly divide 500 cycles of latency by ( 4*ALUFetchRatio ) to determine how many wavefronts must be in-flight to hide that latency.
       </li>
       <li class="li">
        Additionally, a low value for the ALUBusy performance counter can indicate that the compute unit is not providing enough wavefronts to keep the execution resources in full use.
       </li>
       <li class="li">
        (This counter also can be low if the kernel exhausts the available DRAM bandwidth.
       </li>
       <li class="li">
        In this case, generating more wavefronts does not improve performance; it can reduce performance by creating more contention.)
       </li>
       <li class="li">
        Increasing the wavefronts/compute unit does not indefinitely improve performance; once the GPU has enough wavefronts to hide latency, additional active wavefronts provide little or no performance benefit.
       </li>
       <li class="li">
        A closely related metric to wavefronts/compute unit is “occupancy,” which is defined as the ratio of active wavefronts to the maximum number of possible wavefronts supported by the hardware.
       </li>
       <li class="li">
        Many of the important optimization targets and resource limits are expressed in wavefronts/compute units, so this section uses this metric rather than the related “occupancy” term.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-452280" xml:lang="en-US">
     <a name="50401371_pgfId-452280" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-452280" name="50401371_pgfId-452280" shape="rect">
       3.6.2 Resource Limits on Active Wavefronts 3-24
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        AMD GPUs have two important global resource constraints that limit the number of in-flight wavefronts: Each compute unit supports a maximum of eight work-groups.
       </li>
       <li class="li">
        Recall that AMD OpenCL supports up to 256 work-items (four wavefronts) per work-group; effectively, this means each compute unit can support up to 32 wavefronts.
       </li>
       <li class="li">
        Each GPU has a global (across all compute units) limit on the number of active wavefronts.
       </li>
       <li class="li">
        The GPU hardware is generally effective at balancing the load across available compute units.
       </li>
       <li class="li">
        Thus, it is useful to convert this global limit into an average wavefront/compute unit so that it can be compared to the other limits discussed in this section.
       </li>
       <li class="li">
        For example, the ATI Radeon  HD 5870 GPU has a global limit of 496 wavefronts, shared among 20 compute units.
       </li>
       <li class="li">
        Thus, it supports an average of 24.8 wavefronts/compute unit.
       </li>
       <li class="li">
        Some AMD GPUs support up to 96 wavefronts/compute unit.
       </li>
       <li class="li">
        These limits are largely properties of the hardware and, thus, difficult for developers to control directly.
       </li>
       <li class="li">
        Fortunately, these are relatively generous limits.
       </li>
       <li class="li">
        Frequently, the register and LDS usage in the kernel determines the limit on the number of active wavefronts/compute unit, and these can be controlled by the developer.
       </li>
      </ul>
     </div>
     <div class="topic concept nested4" id="50401371_pgfId-452285" xml:lang="en-US">
      <a name="50401371_pgfId-452285" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-452285" name="50401371_pgfId-452285" shape="rect">
        GPU Registers 3-25
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Each compute unit provides 16384 GP registers, and each register contains 4×32-bit values (either single-precision floating point or a 32-bit integer).
        </li>
        <li class="li">
         The total register size is 256 kB of storage per compute unit.
        </li>
        <li class="li">
         These registers are shared among all active wavefronts on the compute unit; each kernel allocates only the registers it needs from the shared pool.
        </li>
        <li class="li">
         This is unlike a CPU, where each thread is assigned a fixed set of architectural registers.
        </li>
        <li class="li">
         However, using many registers in a kernel depletes the shared pool and eventually causes the hardware to throttle the maximum number of active wavefronts.
        </li>
        <li class="li">
         See Impact of Register Type on Wavefronts/CU shows how the registers used in the kernel impacts the register-limited wavefronts/compute unit.
        </li>
        <li class="li">
         For example, a kernel that uses 30 registers (120×32-bit values) can run with eight active wavefronts on each compute unit.
        </li>
        <li class="li">
         Because of the global limits described earlier, each compute unit is limited to 32 wavefronts; thus, kernels can use up to seven registers (28 values) without affecting the number of wavefronts/compute unit.
        </li>
        <li class="li">
         Finally, note that in addition to the GPRs shown in the table, each kernel has access to four clause temporary registers.
        </li>
        <li class="li">
         AMD provides the following tools to examine the number of general-purpose registers (GPRs) used by the kernel.
        </li>
        <li class="li">
         The CodeXL GPU Profiler displays the number of GPRs used by the kernel.
        </li>
        <li class="li">
         Alternatively, the CodeXL GPU Profiler generates the ISA dump (described in See Analyzing Processor Kernels), which then can be searched for the string :NUM_GPRS .
        </li>
        <li class="li">
         The AMD APP KernelAnalyzer2 also shows the GPR used by the kernel, across a wide variety of GPU compilation targets.
        </li>
        <li class="li">
         The compiler generates spill code (shuffling values to, and from, memory) if it cannot fit all the live values into registers.
        </li>
        <li class="li">
         Spill code uses long-latency global memory and can have a large impact on performance.
        </li>
        <li class="li">
         The CodeXL GPU Profiler reports the static number of register spills in the ScratchReg field.
        </li>
        <li class="li">
         Generally, it is a good idea to re-write the algorithm to use fewer GPRs, or tune the work-group dimensions specified at launch time to expose more registers/kernel to the compiler, in order to reduce the scratch register usage to 0.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401371_pgfId-458289" xml:lang="en-US">
      <a name="50401371_pgfId-458289" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-458289" name="50401371_pgfId-458289" shape="rect">
        Specifying the Default Work-Group Size at Compile-Time 3-26
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The number of registers used by a work-item is determined when the kernel is compiled.
        </li>
        <li class="li">
         The user later specifies the size of the work-group.
        </li>
        <li class="li">
         Ideally, the OpenCL compiler knows the size of the work-group at compile-time, so it can make optimal register allocation decisions.
        </li>
        <li class="li">
         Without knowing the work-group size, the compiler must assume an upper-bound size to avoid allocating more registers in the work-item than the hardware actually contains.
        </li>
        <li class="li">
         For example, if the compiler allocates 70 registers for the work-item, See Impact of Register Type on Wavefronts/CU shows that only three wavefronts (192 work-items) are supported.
        </li>
        <li class="li">
         If the user later launches the kernel with a work-group size of four wavefronts (256 work-items), the launch fails because the work-group requires 70*256=17920 registers, which is more than the hardware allows.
        </li>
        <li class="li">
         To prevent this from happening, the compiler performs the register allocation with the conservative assumption that the kernel is launched with the largest work-group size (256 work-items).
        </li>
        <li class="li">
         The compiler guarantees that the kernel does not use more than 62 registers (the maximum number of registers which supports a work-group with four wave-fronts), and generates low-performing register spill code, if necessary.
        </li>
        <li class="li">
         Fortunately, OpenCL provides a mechanism to specify a work-group size that the compiler can use to optimize the register allocation.
        </li>
        <li class="li">
         In particular, specifying a smaller work-group size at compile time allows the compiler to allocate more registers for each kernel, which can avoid spill code and improve performance.
        </li>
        <li class="li">
         The kernel attribute syntax is: Section 6.7.2 of the OpenCL specification explains the attribute in more detail.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401371_pgfId-458253" xml:lang="en-US">
      <a name="50401371_pgfId-458253" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-458253" name="50401371_pgfId-458253" shape="rect">
        Local Memory (LDS) Size 3-27
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         In addition to registers, shared memory can also serve to limit the active wavefronts/compute unit.
        </li>
        <li class="li">
         Each compute unit has 32k of LDS, which is shared among all active work-groups.
        </li>
        <li class="li">
         LDS is allocated on a per-work-group granularity, so it is possible (and useful) for multiple wavefronts to share the same local memory allocation.
        </li>
        <li class="li">
         However, large LDS allocations eventually limits the number of workgroups that can be active.
        </li>
        <li class="li">
         See Effect of LDS Usage on Wavefronts/CU provides more details about how LDS usage can impact the wavefronts/compute unit.
        </li>
        <li class="li">
         Assumes each work-group uses four wavefronts (the maximum supported by the AMD OpenCL SDK).
        </li>
        <li class="li">
         AMD provides the following tools to examine the amount of LDS used by the kernel: The CodeXL GPU Profiler displays the LDS usage.
        </li>
        <li class="li">
         See the LocalMem counter.
        </li>
        <li class="li">
         Alternatively, use the CodeXL GPU Profiler to generate the ISA dump (described in See Analyzing Processor Kernels), then search for the string SQ_LDS_ALLOC:SIZE in the ISA dump.
        </li>
        <li class="li">
         Note that the value is shown in hexadecimal format.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-458820" xml:lang="en-US">
     <a name="50401371_pgfId-458820" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-458820" name="50401371_pgfId-458820" shape="rect">
       3.6.3 Partitioning the Work 3-28
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        In OpenCL, each kernel executes on an index point that exists in a global NDRange.
       </li>
       <li class="li">
        The partition of the NDRange can have a significant impact on performance; thus, it is recommended that the developer explicitly specify the global ( #work-groups ) and local ( #work-items/work-group ) dimensions, rather than rely on OpenCL to set these automatically (by setting local_work_size to NULL in clEnqueueNDRangeKernel ).
       </li>
       <li class="li">
        This section explains the guidelines for partitioning at the global, local, and work/kernel levels.
       </li>
      </ul>
     </div>
     <div class="topic concept nested4" id="50401371_pgfId-452491" xml:lang="en-US">
      <a name="50401371_pgfId-452491" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-452491" name="50401371_pgfId-452491" shape="rect">
        Global Work Size 3-28
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         OpenCL does not explicitly limit the number of work-groups that can be submitted with a clEnqueueNDRangeKernel command.
        </li>
        <li class="li">
         The hardware limits the available in-flight threads, but the OpenCL SDK automatically partitions a large number of work-groups into smaller pieces that the hardware can process.
        </li>
        <li class="li">
         For some large workloads, the amount of memory available to the GPU can be a limitation; the problem might require so much memory capacity that the GPU cannot hold it all.
        </li>
        <li class="li">
         In these cases, the programmer must partition the workload into multiple clEnqueueNDRangeKernel commands.
        </li>
        <li class="li">
         The available device memory can be obtained by querying clDeviceInfo .
        </li>
        <li class="li">
         At a minimum, ensure that the workload contains at least as many work-groups as the number of compute units in the hardware.
        </li>
        <li class="li">
         Work-groups cannot be split across multiple compute units, so if the number of work-groups is less than the available compute units, some units are idle.
        </li>
        <li class="li">
         Evergreen and Northern Islands GPUs have 2-24 compute units.
        </li>
        <li class="li">
         (Use clGetDeviceInfo(…CL_DEVICE_MAX_COMPUTE_UNITS) to determine the value dynamically).
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401371_pgfId-452494" xml:lang="en-US">
      <a name="50401371_pgfId-452494" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-452494" name="50401371_pgfId-452494" shape="rect">
        Local Work Size (#Work-Items per Work-Group) 3-28
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         OpenCL limits the number of work-items in each group.
        </li>
        <li class="li">
         Call clDeviceInfo with the CL_DEVICE_MAX_WORK_GROUP_SIZE to determine the maximum number of work-groups supported by the hardware.
        </li>
        <li class="li">
         Currently, AMD GPUs with SDK 2.1 return 256 as the maximum number of work-items per work-group.
        </li>
        <li class="li">
         Note the number of work-items is the product of all work-group dimensions; for example, a work-group with dimensions 32×16 requires 512 work-items, which is not allowed with the current AMD OpenCL SDK.
        </li>
        <li class="li">
         The fundamental unit of work on AMD GPUs is called a wavefront.
        </li>
        <li class="li">
         Each wavefront consists of 64 work-items; thus, the optimal local work size is an integer multiple of 64 (specifically 64, 128, 192, or 256) work-items per work-group.
        </li>
        <li class="li">
         Work-items in the same work-group can share data through LDS memory and also use high-speed local atomic operations.
        </li>
        <li class="li">
         Thus, larger work-groups enable more work-items to efficiently share data, which can reduce the amount of slower global communication.
        </li>
        <li class="li">
         However, larger work-groups reduce the number of global work-groups, which, for small workloads, could result in idle compute units.
        </li>
        <li class="li">
         Generally, larger work-groups are better as long as the global range is big enough to provide 1-2 Work-Groups for each compute unit in the system; for small workloads it generally works best to reduce the work-group size in order to avoid idle compute units.
        </li>
        <li class="li">
         Note that it is possible to make the decision dynamically, when the kernel is launched, based on the launch dimensions and the target device characteristics.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401371_pgfId-452498" xml:lang="en-US">
      <a name="50401371_pgfId-452498" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-452498" name="50401371_pgfId-452498" shape="rect">
        Moving Work to the Kernel 3-29
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Often, work can be moved from the work-group into the kernel.
        </li>
        <li class="li">
         For example, a matrix multiply where each work-item computes a single element in the output array can be written so that each work-item generates multiple elements.
        </li>
        <li class="li">
         This technique can be important for effectively using the processing elements available in the five-wide (or four-wide, depending on the GPU type) VLIW processing engine (see the ALUPacking performance counter reported by the CodeXL GPU Profiler).
        </li>
        <li class="li">
         The mechanics of this technique often is as simple as adding a for loop around the kernel, so that the kernel body is run multiple times inside this loop, then adjusting the global work size to reduce the work-items.
        </li>
        <li class="li">
         Typically, the local work-group is unchanged, and the net effect of moving work into the kernel is that each work-group does more effective processing, and fewer global work-groups are required.
        </li>
        <li class="li">
         When moving work to the kernel, often it is best to combine work-items that are separated by 16 in the NDRange index space, rather than combining adjacent work-items.
        </li>
        <li class="li">
         Combining the work-items in this fashion preserves the memory access patterns optimal for global and local memory accesses.
        </li>
        <li class="li">
         For example, consider a kernel where each kernel accesses one four-byte element in array A.
        </li>
        <li class="li">
         The resulting access pattern is: If we naively combine four adjacent work-items to increase the work processed per kernel, so that the first work-item accesses array elements A+0 to A+3 on successive cycles, the overall access pattern is: This pattern shows that on the first cycle the access pattern contains “holes.” Also, this pattern results in bank conflicts on the LDS.
        </li>
        <li class="li">
         A better access pattern is to combine four work-items so that the first work-item accesses array elements A+0, A+16, A+32, and A+48.
        </li>
        <li class="li">
         The resulting access pattern is: Note that this access patterns preserves the sequentially-increasing addressing of the original kernel and generates efficient global and LDS memory references.
        </li>
        <li class="li">
         Increasing the processing done by the kernels can allow more processing to be done on the fixed pool of local memory available to work-groups.
        </li>
        <li class="li">
         For example, consider a case where an algorithm requires 32×32 elements of shared memory.
        </li>
        <li class="li">
         If each work-item processes only one element, it requires 1024 work-items/work-group, which exceeds the maximum limit.
        </li>
        <li class="li">
         Instead, each kernel can be written to process four elements, and a work-group of 16×16 work-items could be launched to process the entire array.
        </li>
        <li class="li">
         A related example is a blocked algorithm, such as a matrix multiply; the performance often scales with the size of the array that can be cached and used to block the algorithm.
        </li>
        <li class="li">
         By moving processing tasks into the kernel, the kernel can use the available local memory rather than being limited by the work-items/work-group.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401371_pgfId-457158" xml:lang="en-US">
      <a name="50401371_pgfId-457158" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-457158" name="50401371_pgfId-457158" shape="rect">
        Work-Group Dimensions vs Size 3-30
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The local NDRange can contain up to three dimensions, here labeled X, Y, and Z.
        </li>
        <li class="li">
         The X dimension is returned by get_local_id(0) , Y is returned by get_local_id(1) , and Z is returned by get_local_id(2) .
        </li>
        <li class="li">
         The GPU hardware schedules the kernels so that the X dimensions moves fastest as the work-items are packed into wavefronts.
        </li>
        <li class="li">
         For example, the 128 threads in a 2D work-group of dimension 32×4 (X=32 and Y=4) would be packed into two wavefronts as follows (notation shown in X,Y order): The total number of work-items in the work-group is typically the most important parameter to consider, in particular when optimizing to hide latency by increasing wavefronts/compute unit.
        </li>
        <li class="li">
         However, the choice of XYZ dimensions for the same overall work-group size can have the following second-order effects.
        </li>
        <li class="li">
         Work-items in the same quarter-wavefront execute on the same cycle in the processing engine.
        </li>
        <li class="li">
         Thus, global memory coalescing and local memory bank conflicts can be impacted by dimension, particularly if the fast-moving X dimension is small.
        </li>
        <li class="li">
         Typically, it is best to choose an X dimension of at least 16, then optimize the memory patterns for a block of 16 work-items which differ by 1 in the X dimension.
        </li>
        <li class="li">
         Work-items in the same wavefront have the same program counter and execute the same instruction on each cycle.
        </li>
        <li class="li">
         The packing order can be important if the kernel contains divergent branches.
        </li>
        <li class="li">
         If possible, pack together work-items that are likely to follow the same direction when control-flow is encountered.
        </li>
        <li class="li">
         For example, consider an image-processing kernel where each work-item processes one pixel, and the control-flow depends on the color of the pixel.
        </li>
        <li class="li">
         It might be more likely that a square of 8×8 pixels is the same color than a 64×1 strip; thus, the 8×8 would see less divergence and higher performance.
        </li>
        <li class="li">
         When in doubt, a square 16×16 work-group size is a good start.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-452785" xml:lang="en-US">
     <a name="50401371_pgfId-452785" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-452785" name="50401371_pgfId-452785" shape="rect">
       3.6.4 Optimizing for Cedar 3-31
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        To focus the discussion, this section has used specific hardware characteristics that apply to most of the Evergreen series.
       </li>
       <li class="li">
        The value Evergreen part, referred to as Cedar and used in products such as the ATI Radeon  HD 5450 GPU, has different architecture characteristics, as shown below.
       </li>
       <li class="li">
        Note the maximum workgroup size can be obtained with clGetDeviceInfo…(…,CL_DEVICE_MAX_WORK_GROUP_SIZE,…) .
       </li>
       <li class="li">
        Applications must ensure that the requested kernel launch dimensions that are fewer than the threshold reported by this API call.
       </li>
       <li class="li">
        The difference in total register size can impact the compiled code and cause register spill code for kernels that were tuned for other devices.
       </li>
       <li class="li">
        One technique that can be useful is to specify the required work-group size as 128 (half the default of 256).
       </li>
       <li class="li">
        In this case, the compiler has the same number of registers available as for other devices and uses the same number of registers.
       </li>
       <li class="li">
        The developer must ensure that the kernel is launched with the reduced work size (128) on Cedar-class devices.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-457368" xml:lang="en-US">
     <a name="50401371_pgfId-457368" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-457368" name="50401371_pgfId-457368" shape="rect">
       3.6.5 Summary of NDRange Optimizations 3-32
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        As shown above, execution range optimization is a complex topic with many interacting variables and which frequently requires some experimentation to determine the optimal values.
       </li>
       <li class="li">
        Some general guidelines are: Select the work-group size to be a multiple of 64, so that the wavefronts are fully populated.
       </li>
       <li class="li">
        Always provide at least two wavefronts (128 work-items) per compute unit.
       </li>
       <li class="li">
        For a ATI Radeon  HD 5870 GPU, this implies 40 wave-fronts or 2560 work-items.
       </li>
       <li class="li">
        If necessary, reduce the work-group size (but not below 64 work-items) to provide work-groups for all compute units in the system.
       </li>
       <li class="li">
        Latency hiding depends on both the number of wavefronts/compute unit, as well as the execution time for each kernel.
       </li>
       <li class="li">
        Generally, two to eight wavefronts/compute unit is desirable, but this can vary significantly, depending on the complexity of the kernel and the available memory bandwidth.
       </li>
       <li class="li">
        The CodeXL GPU Profiler and associated performance counters can help to select an optimal value.
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="50401371_pgfId-463371" xml:lang="en-US">
    <a name="50401371_pgfId-463371" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-463371" name="50401371_pgfId-463371" shape="rect">
      3.7 Using Multiple OpenCL Devices 3-32
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       The AMD OpenCL runtime supports both CPU and GPU devices.
      </li>
      <li class="li">
       This section introduces techniques for appropriately partitioning the workload and balancing it across the devices in the system.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-463382" xml:lang="en-US">
     <a name="50401371_pgfId-463382" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-463382" name="50401371_pgfId-463382" shape="rect">
       3.7.1 CPU and GPU Devices 3-32
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        See CPU and GPU Performance Characteristics lists some key performance characteristics of two exemplary CPU and GPU devices: a quad-core AMD Phenom II X4 processor running at 2.8 GHz, and a mid-range ATI Radeon  5670 GPU running at 750 MHz.
       </li>
       <li class="li">
        The “best” device in each characteristic is highlighted, and the ratio of the best/other device is shown in the final column.
       </li>
       <li class="li">
        The GPU excels at high-throughput: the peak execution rate (measured in FLOPS) is 7X higher than the CPU, and the memory bandwidth is 2.5X higher than the CPU.
       </li>
       <li class="li">
        The GPU also consumes approximately 65% the power of the CPU; thus, for this comparison, the power efficiency in flops/watt is 10X higher.
       </li>
       <li class="li">
        While power efficiency can vary significantly with different devices, GPUs generally provide greater power efficiency (flops/watt) than CPUs because they optimize for throughput and eliminate hardware designed to hide latency.
       </li>
       <li class="li">
        Conversely, CPUs excel at latency-sensitive tasks.
       </li>
       <li class="li">
        For example, an integer add is 30X faster on the CPU than on the GPU.
       </li>
       <li class="li">
        This is a product of both the CPUs higher clock rate (2800 MHz vs 750 MHz for this comparison), as well as the operation latency; the CPU is optimized to perform an integer add in just one cycle, while the GPU requires eight cycles.
       </li>
       <li class="li">
        The CPU also has a latency-optimized path to DRAM, while the GPU optimizes for bandwidth and relies on many in-flight threads to hide the latency.
       </li>
       <li class="li">
        The ATI Radeon  HD 5670 GPU, for example, supports more than 15,000 in-flight threads and can switch to a new thread in a single cycle.
       </li>
       <li class="li">
        The CPU supports only four hardware threads, and thread-switching requires saving and restoring the CPU registers from memory.
       </li>
       <li class="li">
        The GPU requires many active threads to both keep the execution resources busy, as well as provide enough threads to hide the long latency of cache misses.
       </li>
       <li class="li">
        Each GPU thread has its own register state, which enables the fast single-cycle switching between threads.
       </li>
       <li class="li">
        Also, GPUs can be very efficient at gather/scatter operations: each thread can load from any arbitrary address, and the registers are completely decoupled from the other threads.
       </li>
       <li class="li">
        This is substantially more flexible and higher-performing than a classic Vector ALU-style architecture (such as SSE on the CPU), which typically requires that data be accessed from contiguous and aligned memory locations.
       </li>
       <li class="li">
        SSE supports instructions that write parts of a register (for example, MOVLPS and MOVHPS , which write the upper and lower halves, respectively, of an SSE register), but these instructions generate additional microarchitecture dependencies and frequently require additional pack instructions to format the data correctly.
       </li>
       <li class="li">
        In contrast, each GPU thread shares the same program counter with 63 other threads in a wavefront.
       </li>
       <li class="li">
        Divergent control-flow on a GPU can be quite expensive and can lead to significant under-utilization of the GPU device.
       </li>
       <li class="li">
        When control flow substantially narrows the number of valid work-items in a wave-front, it can be faster to use the CPU device.
       </li>
       <li class="li">
        CPUs also tend to provide significantly more on-chip cache than GPUs.
       </li>
       <li class="li">
        In this example, the CPU device contains 512k L2 cache/core plus a 6 MB L3 cache that is shared among all cores, for a total of 8 MB of cache.
       </li>
       <li class="li">
        In contrast, the GPU device contains only 128 k cache shared by the five compute units.
       </li>
       <li class="li">
        The larger CPU cache serves both to reduce the average memory latency and to reduce memory bandwidth in cases where data can be re-used from the caches.
       </li>
       <li class="li">
        Finally, note the approximate 9X difference in kernel launch latency.
       </li>
       <li class="li">
        The GPU launch time includes both the latency through the software stack, as well as the time to transfer the compiled kernel and associated arguments across the PCI-express bus to the discrete GPU.
       </li>
       <li class="li">
        Notably, the launch time does not include the time to compile the kernel.
       </li>
       <li class="li">
        The CPU can be the device-of-choice for small, quick-running problems when the overhead to launch the work on the GPU outweighs the potential speedup.
       </li>
       <li class="li">
        Often, the work size is data-dependent, and the choice of device can be data-dependent as well.
       </li>
       <li class="li">
        For example, an image-processing algorithm may run faster on the GPU if the images are large, but faster on the CPU when the images are small.
       </li>
       <li class="li">
        The differences in performance characteristics present interesting optimization opportunities.
       </li>
       <li class="li">
        Workloads that are large and data parallel can run orders of magnitude faster on the GPU, and at higher power efficiency.
       </li>
       <li class="li">
        Serial or small parallel workloads (too small to efficiently use the GPU resources) often run significantly faster on the CPU devices.
       </li>
       <li class="li">
        In some cases, the same algorithm can exhibit both types of workload.
       </li>
       <li class="li">
        A simple example is a reduction operation such as a sum of all the elements in a large array.
       </li>
       <li class="li">
        The beginning phases of the operation can be performed in parallel and run much faster on the GPU.
       </li>
       <li class="li">
        The end of the operation requires summing together the partial sums that were computed in parallel; eventually, the width becomes small enough so that the overhead to parallelize outweighs the computation cost, and it makes sense to perform a serial add.
       </li>
       <li class="li">
        For these serial operations, the CPU can be significantly faster than the GPU.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-463540" xml:lang="en-US">
     <a name="50401371_pgfId-463540" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-463540" name="50401371_pgfId-463540" shape="rect">
       3.7.2 When to Use Multiple Devices 3-35
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        One of the features of GPU computing is that some algorithms can run substantially faster and at better energy efficiency compared to a CPU device.
       </li>
       <li class="li">
        Also, once an algorithm has been coded in the data-parallel task style for OpenCL, the same code typically can scale to run on GPUs with increasing compute capability (that is more compute units) or even multiple GPUs (with a little more work).
       </li>
       <li class="li">
        For some algorithms, the advantages of the GPU (high computation throughput, latency hiding) are offset by the advantages of the CPU (low latency, caches, fast launch time), so that the performance on either devices is similar.
       </li>
       <li class="li">
        This case is more common for mid-range GPUs and when running more mainstream algorithms.
       </li>
       <li class="li">
        If the CPU and the GPU deliver similar performance, the user can get the benefit of either improved power efficiency (by running on the GPU) or higher peak performance (use both devices).
       </li>
       <li class="li">
        Usually, when the data size is small, it is faster to use the CPU because the start-up time is quicker than on the GPU due to a smaller driver overhead and avoiding the need to copy buffers from the host to the device.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-463544" xml:lang="en-US">
     <a name="50401371_pgfId-463544" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-463544" name="50401371_pgfId-463544" shape="rect">
       3.7.3 Partitioning Work for Multiple Devices 3-35
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        By design, each OpenCL command queue can only schedule work on a single OpenCL device.
       </li>
       <li class="li">
        Thus, using multiple devices requires the developer to create a separate queue for each device, then partition the work between the available command queues.
       </li>
       <li class="li">
        A simple scheme for partitioning work between devices would be to statically determine the relative performance of each device, partition the work so that faster devices received more work, launch all the kernels, and then wait for them to complete.
       </li>
       <li class="li">
        In practice, however, this rarely yields optimal performance.
       </li>
       <li class="li">
        The relative performance of devices can be difficult to determine, in particular for kernels whose performance depends on the data input.
       </li>
       <li class="li">
        Further, the device performance can be affected by dynamic frequency scaling, OS thread scheduling decisions, or contention for shared resources, such as shared caches and DRAM bandwidth.
       </li>
       <li class="li">
        Simple static partitioning algorithms which “guess wrong” at the beginning can result in significantly lower performance, since some devices finish and become idle while the whole system waits for the single, unexpectedly slow device.
       </li>
       <li class="li">
        For these reasons, a dynamic scheduling algorithm is recommended.
       </li>
       <li class="li">
        In this approach, the workload is partitioned into smaller parts that are periodically scheduled onto the hardware.
       </li>
       <li class="li">
        As each device completes a part of the workload, it requests a new part to execute from the pool of remaining work.
       </li>
       <li class="li">
        Faster devices, or devices which work on easier parts of the workload, request new input faster, resulting in a natural workload balancing across the system.
       </li>
       <li class="li">
        The approach creates some additional scheduling and kernel submission overhead, but dynamic scheduling generally helps avoid the performance cliff from a single bad initial scheduling decision, as well as higher performance in real-world system environments (since it can adapt to system conditions as the algorithm runs).
       </li>
       <li class="li">
        Multi-core runtimes, such as Cilk, have already introduced dynamic scheduling algorithms for multi-core CPUs, and it is natural to consider extending these scheduling algorithms to GPUs as well as CPUs.
       </li>
       <li class="li">
        A GPU introduces several new aspects to the scheduling process: Heterogeneous Compute Devices Most existing multi-core schedulers target only homogenous computing devices.
       </li>
       <li class="li">
        When scheduling across both CPU and GPU devices, the scheduler must be aware that the devices can have very different performance characteristics (10X or more) for some algorithms.
       </li>
       <li class="li">
        To some extent, dynamic scheduling is already designed to deal with heterogeneous workloads (based on data input the same algorithm can have very different performance, even when run on the same device), but a system with heterogeneous devices makes these cases more common and more extreme.
       </li>
       <li class="li">
        Here are some suggestions for these situations.
       </li>
       <li class="li">
        The scheduler should support sending different workload sizes to different devices.
       </li>
       <li class="li">
        GPUs typically prefer larger grain sizes, and higher-performing GPUs prefer still larger grain sizes.
       </li>
       <li class="li">
        The scheduler should be conservative about allocating work until after it has examined how the work is being executed.
       </li>
       <li class="li">
        In particular, it is important to avoid the performance cliff that occurs when a slow device is assigned an important long-running task.
       </li>
       <li class="li">
        One technique is to use small grain allocations at the beginning of the algorithm, then switch to larger grain allocations when the device characteristics are well-known.
       </li>
       <li class="li">
        As a special case of the above rule, when the devices are substantially different in performance (perhaps 10X), load-balancing has only a small potential performance upside, and the overhead of scheduling the load probably eliminates the advantage.
       </li>
       <li class="li">
        In the case where one device is far faster than everything else in the system, use only the fast device.
       </li>
       <li class="li">
        The scheduler must balance small-grain-size (which increase the adaptiveness of the schedule and can efficiently use heterogeneous devices) with larger grain sizes (which reduce scheduling overhead).
       </li>
       <li class="li">
        Note that the grain size must be large enough to efficiently use the GPU.
       </li>
       <li class="li">
        Asynchronous Launch OpenCL devices are designed to be scheduled asynchronously from a command-queue.
       </li>
       <li class="li">
        The host application can enqueue multiple kernels, flush the kernels so they begin executing on the device, then use the host core for other work.
       </li>
       <li class="li">
        The AMD OpenCL implementation uses a separate thread for each command-queue, so work can be transparently scheduled to the GPU in the background.
       </li>
       <li class="li">
        One situation that should be avoided is starving the high-performance GPU devices.
       </li>
       <li class="li">
        This can occur if the physical CPU core, which must re-fill the device queue, is itself being used as a device.
       </li>
       <li class="li">
        A simple approach to this problem is to dedicate a physical CPU core for scheduling chores.
       </li>
       <li class="li">
        The device fission extension (see the Extensions appendix of the AMD OpenCL User Guide) can be used to reserve a core for scheduling.
       </li>
       <li class="li">
        For example, on a quad-core device, device fission can be used to create an OpenCL device with only three cores.
       </li>
       <li class="li">
        Another approach is to schedule enough work to the device so that it can tolerate latency in additional scheduling.
       </li>
       <li class="li">
        Here, the scheduler maintains a watermark of uncompleted work that has been sent to the device, and refills the queue when it drops below the watermark.
       </li>
       <li class="li">
        This effectively increase the grain size, but can be very effective at reducing or eliminating device starvation.
       </li>
       <li class="li">
        Developers cannot directly query the list of commands in the OpenCL command queues; however, it is possible to pass an event to each clEnqueue call that can be queried, in order to determine the execution status (in particular the command completion time); developers also can maintain their own queue of outstanding requests.
       </li>
       <li class="li">
        For many algorithms, this technique can be effective enough at hiding latency so that a core does not need to be reserved for scheduling.
       </li>
       <li class="li">
        In particular, algorithms where the work-load is largely known up-front often work well with a deep queue and watermark.
       </li>
       <li class="li">
        Algorithms in which work is dynamically created may require a dedicated thread to provide low-latency scheduling.
       </li>
       <li class="li">
        Data Location Discrete GPUs use dedicated high-bandwidth memory that exists in a separate address space.
       </li>
       <li class="li">
        Moving data between the device address space and the host requires time-consuming transfers over a relatively slow PCI-Express bus.
       </li>
       <li class="li">
        Schedulers should be aware of this cost and, for example, attempt to schedule work that consumes the result on the same device producing it.
       </li>
       <li class="li">
        CPU and GPU devices share the same memory bandwidth, which results in additional interactions of kernel executions.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-463566" xml:lang="en-US">
     <a name="50401371_pgfId-463566" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-463566" name="50401371_pgfId-463566" shape="rect">
       3.7.4 Synchronization Caveats 3-37
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The OpenCL functions that enqueue work ( clEnqueueNDRangeKernel ) merely enqueue the requested work in the command queue; they do not cause it to begin executing.
       </li>
       <li class="li">
        Execution begins when the user executes a synchronizing command, such as clFlush or clWaitForEvents .
       </li>
       <li class="li">
        Enqueuing several commands before flushing can enable the host CPU to batch together the command submission, which can reduce launch overhead.
       </li>
       <li class="li">
        Command-queues that are configured to execute in-order are guaranteed to complete execution of each command before the next command begins.
       </li>
       <li class="li">
        This synchronization guarantee can often be leveraged to avoid explicit clWaitForEvents() calls between command submissions.
       </li>
       <li class="li">
        Using clWaitForEvents() requires intervention by the host CPU and additional synchronization cost between the host and the GPU; by leveraging the in-order queue property, back-to-back kernel executions can be efficiently handled directly on the GPU hardware.
       </li>
       <li class="li">
        AMD Evergreen GPUs currently do not support the simultaneous execution of multiple kernels.
       </li>
       <li class="li">
        For efficient execution, design a single kernel to use all the available execution resources on the GPU.
       </li>
       <li class="li">
        The AMD OpenCL implementation spawns a new thread to manage each command queue.
       </li>
       <li class="li">
        Thus, the OpenCL host code is free to manage multiple devices from a single host thread.
       </li>
       <li class="li">
        Note that clFinish is a blocking operation; the thread that calls clFinish blocks until all commands in the specified command-queue have been processed and completed.
       </li>
       <li class="li">
        If the host thread is managing multiple devices, it is important to call clFlush for each command-queue before calling clFinish , so that the commands are flushed and execute in parallel on the devices.
       </li>
       <li class="li">
        Otherwise, the first call to clFinish blocks, the commands on the other devices are not flushed, and the devices appear to execute serially rather than in parallel.
       </li>
       <li class="li">
        For low-latency CPU response, it can be more efficient to use a dedicated spin loop and not call clFinish() Calling clFinish() indicates that the application wants to wait for the GPU, putting the thread to sleep.
       </li>
       <li class="li">
        For low latency, the application should use clFlush() , followed by a loop to wait for the event to complete.
       </li>
       <li class="li">
        This is also true for blocking maps.
       </li>
       <li class="li">
        The application should use non-blocking maps followed by a loop waiting on the event.
       </li>
       <li class="li">
        The following provides sample code for this.
       </li>
       <li class="li">
        if (sleep) { // this puts host thread to sleep, useful if power is a consideration or overhead is not a concern clFinish(cmd_queue_); } else { // this keeps the host thread awake, useful if latency is a concern clFlush(cmd_queue_); error_ = clGetEventInfo(event, CL_EVENT_COMMAND_EXECUTION_STATUS, sizeof(cl_int), &amp;eventStatus, NULL); while (eventStatus &gt; 0) { error_ = clGetEventInfo(event, CL_EVENT_COMMAND_EXECUTION_STATUS, sizeof(cl_int), &amp;eventStatus, NULL); Sleep(0); // be nice to other threads, allow scheduler to find other work if possible // Choose your favorite way to yield, SwitchToThread() for example, in place of Sleep(0) } }
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-463571" xml:lang="en-US">
     <a name="50401371_pgfId-463571" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-463571" name="50401371_pgfId-463571" shape="rect">
       3.7.5 GPU and CPU Kernels 3-38
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        While OpenCL provides functional portability so that the same kernel can run on any device, peak performance for each device is typically obtained by tuning the OpenCL kernel for the target device.
       </li>
       <li class="li">
        Code optimized for the Cypress device (the ATI Radeon ™ HD 5870 GPU) typically runs well across other members of the Evergreen family.
       </li>
       <li class="li">
        There are some differences in cache size and LDS bandwidth that might impact some kernels.
       </li>
       <li class="li">
        The Cedar ASIC has a smaller wavefront width and fewer registers (see See Optimizing for Cedar, for optimization information specific to this device).
       </li>
       <li class="li">
        As described in See Clause Boundaries, CPUs and GPUs have very different performance characteristics, and some of these impact how one writes an optimal kernel.
       </li>
       <li class="li">
        Notable differences include: The Vector ALU floating point resources in a CPU (SSE) require the use of vectorized types (float4) to enable packed SSE code generation and extract good performance from the Vector ALU hardware.
       </li>
       <li class="li">
        The GPU VLIW hardware is more flexible and can efficiently use the floating-point hardware even without the explicit use of float4.
       </li>
       <li class="li">
        See See VLIW and SSE Packing, for more information and examples; however, code that can use float4 often generates hi-quality code for both the CPU and the AMD GPUs.
       </li>
       <li class="li">
        The AMD OpenCL CPU implementation runs work-items from the same work-group back-to-back on the same physical CPU core.
       </li>
       <li class="li">
        For optimally coalesced memory patterns, a common access pattern for GPU-optimized algorithms is for work-items in the same wavefront to access memory locations from the same cache line.
       </li>
       <li class="li">
        On a GPU, these work-items execute in parallel and generate a coalesced access pattern.
       </li>
       <li class="li">
        On a CPU, the first work-item runs to completion (or until hitting a barrier) before switching to the next.
       </li>
       <li class="li">
        Generally, if the working set for the data used by a work-group fits in the CPU caches, this access pattern can work efficiently: the first work-item brings a line into the cache hierarchy, which the other work-items later hit.
       </li>
       <li class="li">
        For large working-sets that exceed the capacity of the cache hierarchy, this access pattern does not work as efficiently; each work-item refetches cache lines that were already brought in by earlier work-items but were evicted from the cache hierarchy before being used.
       </li>
       <li class="li">
        Note that AMD CPUs typically provide 512k to 2 MB of L2+L3 cache for each compute unit.
       </li>
       <li class="li">
        CPUs do not contain any hardware resources specifically designed to accelerate local memory accesses.
       </li>
       <li class="li">
        On a CPU, local memory is mapped to the same cacheable DRAM used for global memory, and there is no performance benefit from using the __local qualifier.
       </li>
       <li class="li">
        The additional memory operations to write to LDS, and the associated barrier operations can reduce performance.
       </li>
       <li class="li">
        One notable exception is when local memory is used to pack values to avoid non-coalesced memory patterns.
       </li>
       <li class="li">
        CPU devices only support a small number of hardware threads, typically two to eight.
       </li>
       <li class="li">
        Small numbers of active work-group sizes reduce the CPU switching overhead, although for larger kernels this is a second-order effect.
       </li>
       <li class="li">
        For a balanced solution that runs reasonably well on both devices, developers are encouraged to write the algorithm using float4 vectorization.
       </li>
       <li class="li">
        The GPU is more sensitive to algorithm tuning; it also has higher peak performance potential.
       </li>
       <li class="li">
        Thus, one strategy is to target optimizations to the GPU and aim for reasonable performance on the CPU.
       </li>
       <li class="li">
        For peak performance on all devices, developers can choose to use conditional compilation for key code loops in the kernel, or in some cases even provide two separate kernels.
       </li>
       <li class="li">
        Even with device-specific kernel optimizations, the surrounding host code for allocating memory, launching kernels, and interfacing with the rest of the program generally only needs to be written once.
       </li>
       <li class="li">
        Another approach is to leverage a CPU-targeted routine written in a standard high-level language, such as C++.
       </li>
       <li class="li">
        In some cases, this code path may already exist for platforms that do not support an OpenCL device.
       </li>
       <li class="li">
        The program uses OpenCL for GPU devices, and the standard routine for CPU devices.
       </li>
       <li class="li">
        Load-balancing between devices can still leverage the techniques described in See Partitioning Work for Multiple Devices.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-463581" xml:lang="en-US">
     <a name="50401371_pgfId-463581" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-463581" name="50401371_pgfId-463581" shape="rect">
       3.7.6 Contexts and Devices 3-40
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The AMD OpenCL program creates at least one context, and each context can contain multiple devices.
       </li>
       <li class="li">
        Thus, developers must choose whether to place all devices in the same context or create a new context for each device.
       </li>
       <li class="li">
        Generally, it is easier to extend a context to support additional devices rather than duplicating the context for each device: buffers are allocated at the context level (and automatically across all devices), programs are associated with the context, and kernel compilation (via clBuildProgram ) can easily be done for all devices in a context.
       </li>
       <li class="li">
        However, with current OpenCL implementations, creating a separate context for each device provides more flexibility, especially in that buffer allocations can be targeted to occur on specific devices.
       </li>
       <li class="li">
        Generally, placing the devices in the same context is the preferred solution.
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="50401371_pgfId-451154" xml:lang="en-US">
    <a name="50401371_pgfId-451154" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-451154" name="50401371_pgfId-451154" shape="rect">
      3.8 Instruction Selection Optimizations 3-41
     </a>
    </h3>
    <div class="topic concept nested3" id="50401371_pgfId-459510" xml:lang="en-US">
     <a name="50401371_pgfId-459510" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-459510" name="50401371_pgfId-459510" shape="rect">
       3.8.1 Instruction Bandwidths 3-41
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        See Instruction Throughput (Operations/Cycle for Each Stream Processor) lists the throughput of instructions for GPUs.
       </li>
       <li class="li">
        Note that single precision MAD operations have five times the throughput of the double-precision rate, and that double-precision is only supported on the AMD Radeon™ HD69XX devices.
       </li>
       <li class="li">
        The use of single-precision calculation is encouraged, if that precision is acceptable.
       </li>
       <li class="li">
        Single-precision data is also half the size of double-precision, which requires less chip bandwidth and is not as demanding on the cache structures.
       </li>
       <li class="li">
        Generally, the throughput and latency for 32-bit integer operations is the same as for single-precision floating point operations.
       </li>
       <li class="li">
        24-bit integer MULs and MADs have five times the throughput of 32-bit integer multiplies.
       </li>
       <li class="li">
        24-bit unsigned integers are natively supported only on the Evergreen family of devices and later.
       </li>
       <li class="li">
        Signed 24-bit integers are supported only on the Northern Island family of devices and later.
       </li>
       <li class="li">
        The use of OpenCL built-in functions for mul24 and mad24 is encouraged.
       </li>
       <li class="li">
        Note that mul24 can be useful for array indexing operations.
       </li>
       <li class="li">
        Packed 16-bit and 8-bit operations are not natively supported; however, in cases where it is known that no overflow will occur, some algorithms may be able to effectively pack 2 to 4 values into the 32-bit registers natively supported by the hardware.
       </li>
       <li class="li">
        The MAD instruction is an IEEE-compliant multiply followed by an IEEE-compliant add; it has the same accuracy as two separate MUL/ADD operations.
       </li>
       <li class="li">
        No special compiler flags are required for the compiler to convert separate MUL/ADD operations to use the MAD instruction.
       </li>
       <li class="li">
        See Instruction Throughput (Operations/Cycle for Each Stream Processor) shows the throughput for each stream processing core.
       </li>
       <li class="li">
        To obtain the peak throughput for the whole device, multiply the number of stream cores and the engine clock.
       </li>
       <li class="li">
        For example, according to See Instruction Throughput (Operations/Cycle for Each Stream Processor), a Cypress device can perform two double-precision ADD operations/cycle in each stream core.
       </li>
       <li class="li">
        An ATI Radeon  HD 5870 GPU has 320 Stream Cores and an engine clock of 850 MHz, so the entire GPU has a throughput rate of (2*320*850 MHz) = 544 GFlops for double-precision adds.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-459722" xml:lang="en-US">
     <a name="50401371_pgfId-459722" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-459722" name="50401371_pgfId-459722" shape="rect">
       3.8.2 AMD Media Instructions 3-42
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        AMD provides a set of media instructions for accelerating media processing.
       </li>
       <li class="li">
        Notably, the sum-of-absolute differences (SAD) operation is widely used in motion estimation algorithms.
       </li>
       <li class="li">
        For a brief listing and description of the AMD media operations, see the Extensions appendix of the AMD OpenCL User Guide.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-459778" xml:lang="en-US">
     <a name="50401371_pgfId-459778" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-459778" name="50401371_pgfId-459778" shape="rect">
       3.8.3 Math Libraries 3-42
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        OpenCL supports two types of math library operation: native_function() and function() .
       </li>
       <li class="li">
        Native_functions are generally supported in hardware and can run substantially faster, although at somewhat lower accuracy.
       </li>
       <li class="li">
        The accuracy for the non-native functions is specified in section 7.4 of the OpenCL Specification.
       </li>
       <li class="li">
        The accuracy for the native functions is implementation-defined.
       </li>
       <li class="li">
        Developers are encouraged to use the native functions when performance is more important than precision.
       </li>
       <li class="li">
        See Native Speedup Factor lists the native speedup factor for certain functions.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-459906" xml:lang="en-US">
     <a name="50401371_pgfId-459906" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-459906" name="50401371_pgfId-459906" shape="rect">
       3.8.4 VLIW and SSE Packing 3-43
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Each stream core in the AMD GPU is programmed with a five-wide (or four-wide, depending on the GPU type) VLIW instruction.
       </li>
       <li class="li">
        Efficient use of the GPU hardware requires that the kernel contain enough parallelism to fill all five processing elements; serial dependency chains are scheduled into separate instructions.
       </li>
       <li class="li">
        A classic technique for exposing more parallelism to the compiler is loop unrolling.
       </li>
       <li class="li">
        To assist the compiler in disambiguating memory addresses so that loads can be combined, developers should cluster load and store operations.
       </li>
       <li class="li">
        In particular, re-ordering the code to place stores in adjacent code lines can improve performance.
       </li>
       <li class="li">
        See Unmodified Loop shows an example of unrolling a loop and then clustering the stores.
       </li>
       <li class="li">
        See Kernel Unrolled 4X is the same loop unrolled 4x.
       </li>
       <li class="li">
        See Unrolled Loop with Stores Clustered shows and example of an unrolled loop with clustered stores.
       </li>
       <li class="li">
        Unrolling the loop to expose the underlying parallelism typically allows the GPU compiler to pack the instructions into the slots in the VLIW word.
       </li>
       <li class="li">
        For best results, unrolling by a factor of at least 5 (perhaps 8 to preserve power-of-two factors) may deliver best performance.
       </li>
       <li class="li">
        Unrolling increases the number of required registers, so some experimentation may be required.
       </li>
       <li class="li">
        The CPU back-end requires the use of vector types (float4) to vectorize and generate packed SSE instructions.
       </li>
       <li class="li">
        To vectorize the loop above, use float4 for the array arguments.
       </li>
       <li class="li">
        Obviously, this transformation is only valid in the case where the array elements accessed on each loop iteration are adjacent in memory.
       </li>
       <li class="li">
        The explicit use of float4 can also improve the GPU performance, since it clearly identifies contiguous 16-byte memory operations that can be more efficiently coalesced.
       </li>
       <li class="li">
        See Unrolled Kernel Using float4 for Vectorization is an example of an unrolled kernel that uses float4 for vectorization.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-451159" xml:lang="en-US">
     <a name="50401371_pgfId-451159" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-451159" name="50401371_pgfId-451159" shape="rect">
       3.8.5 Compiler Optimizations 3-45
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The OpenCL compiler currently recognizes a few patterns and transforms them into a single instruction.
       </li>
       <li class="li">
        By following these patterns, a developer can generate highly efficient code.
       </li>
       <li class="li">
        The currently accepted patterns are: Bitfield extract on signed/unsigned integers.
       </li>
       <li class="li">
        where B and C are compile time constants, A is a 8/16/32bit integer type, and C is a mask.
       </li>
       <li class="li">
        Bitfield insert on signed/unsigned integers where B and E have no conflicting bits ( B^E == 0 ), B, C, E, and F are compile-time constants, and B and E are masks.
       </li>
       <li class="li">
        The first bit set in B is greater than the number of bits in E plus the first bit set in E, or the first bit set in E is greater than the number of bits in B plus the first bit set in B.
       </li>
       <li class="li">
        If B, C, E, or F are equivalent to the value 0, this optimization is also supported.
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="50401371_pgfId-517108" xml:lang="en-US">
    <a name="50401371_pgfId-517108" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-517108" name="50401371_pgfId-517108" shape="rect">
      3.9 Clause Boundaries 3-46
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       AMD GPUs groups instructions into clauses.
      </li>
      <li class="li">
       These are broken at control-flow boundaries when: the instruction type changes (for example, from FETCH to ALU), or if the clause contains the maximum amount of operations (the maximum size for an ALU clause is 128 operations).
      </li>
      <li class="li">
       ALU and LDS access instructions are placed in the same clause.
      </li>
      <li class="li">
       FETCH, ALU/LDS, and STORE instructions are placed into separate clauses.
      </li>
      <li class="li">
       The GPU schedules a pair of wavefronts (referred to as the “even” and “odd” wavefront).
      </li>
      <li class="li">
       The even wavefront executes for four cycles (each cycle executes a quarter-wavefront); then, the odd wavefront executes for four cycles.
      </li>
      <li class="li">
       While the odd wavefront is executing, the even wavefront accesses the register file and prepares operands for execution.
      </li>
      <li class="li">
       This fixed interleaving of two wavefronts allows the hardware to efficiently hide the eight-cycle register-read latencies.
      </li>
      <li class="li">
       With the exception of the special treatment for even/odd wavefronts, the GPU scheduler only switches wavefronts on clause boundaries.
      </li>
      <li class="li">
       Latency within a clause results in stalls on the hardware.
      </li>
      <li class="li">
       For example, a wavefront that generates an LDS bank conflict stalls on the compute unit until the LDS access completes; the hardware does not try to hide this stall by switching to another available wavefront.
      </li>
      <li class="li">
       ALU dependencies on memory operations are handled at the clause level.
      </li>
      <li class="li">
       Specifically, an ALU clause can be marked as dependent on a FETCH clause.
      </li>
      <li class="li">
       All FETCH operations in the clause must complete before the ALU clause begins execution.
      </li>
      <li class="li">
       Switching to another clause in the same wavefront requires approximately 40 cycles.
      </li>
      <li class="li">
       The hardware immediately schedules another wavefront if one is available, so developers are encouraged to provide multiple wavefronts/compute unit.
      </li>
      <li class="li">
       The cost to switch clauses is far less than the memory latency; typically, if the program is designed to hide memory latency, it hides the clause latency as well.
      </li>
      <li class="li">
       The address calculations for FETCH and STORE instructions execute on the same hardware in the compute unit as do the ALU clauses.
      </li>
      <li class="li">
       The address calculations for memory operations consumes the same executions resources that are used for floating-point computations.
      </li>
      <li class="li">
       The ISA dump shows the clause boundaries.
      </li>
      <li class="li">
       See the example shown below.
      </li>
      <li class="li">
       For more information on clauses, see the AMD Evergreen-Family ISA Microcode And Instructions (v1.0b) and the AMD R600/R700/Evergreen Assembly Language Format documents.
      </li>
      <li class="li">
       The following is an example disassembly showing clauses.
      </li>
      <li class="li">
       There are 13 clauses in the kernel.
      </li>
      <li class="li">
       The first clause is an ALU clause and has 6 instructions.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="50401371_pgfId-520751" xml:lang="en-US">
    <a name="50401371_pgfId-520751" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-520751" name="50401371_pgfId-520751" shape="rect">
      3.10 Additional Performance Guidance 3-48
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       This section is a collection of performance tips for GPU compute and AMD-specific optimizations.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-448804" xml:lang="en-US">
     <a name="50401371_pgfId-448804" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-448804" name="50401371_pgfId-448804" shape="rect">
       3.10.1 Loop Unroll  pragma  3-48
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The compiler directive #pragma unroll &lt;unroll-factor&gt; can be placed immediately prior to a loop as a hint to the compiler to unroll a loop.
       </li>
       <li class="li">
        &lt;unroll-factor&gt; must be a positive integer, 1 or greater.
       </li>
       <li class="li">
        When &lt;unroll-factor&gt; is 1, loop unrolling is disabled.
       </li>
       <li class="li">
        When &lt;unroll-factor&gt; is 2 or greater, the compiler uses this as a hint for the number of times the loop is to be unrolled.
       </li>
       <li class="li">
        Examples for using this loop follow.
       </li>
       <li class="li">
        No unrolling example: #pragma unroll 1 for (int i = 0; i &lt; n; i++) { … } Partial unrolling example: #pragma unroll 4 for (int i = 0; i &lt; 128; i++) { … } Currently, the unroll pragma requires that the loop boundaries can be determined at compile time.
       </li>
       <li class="li">
        Both loop bounds must be known at compile time.
       </li>
       <li class="li">
        If n is not given, it is equivalent to the number of iterations of the loop when both loop bounds are known.
       </li>
       <li class="li">
        If the unroll-factor is not specified, and the compiler can determine the loop count, the compiler fully unrolls the loop.
       </li>
       <li class="li">
        If the unroll-factor is not specified, and the compiler cannot determine the loop count, the compiler does no unrolling.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-495342" xml:lang="en-US">
     <a name="50401371_pgfId-495342" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-495342" name="50401371_pgfId-495342" shape="rect">
       3.10.2 Memory Tiling 3-48
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        There are many possible physical memory layouts for images.
       </li>
       <li class="li">
        AMD Accelerated Parallel Processing devices can access memory in a tiled or in a linear arrangement.
       </li>
       <li class="li">
        Linear – A linear layout format arranges the data linearly in memory such that element addresses are sequential.
       </li>
       <li class="li">
        This is the layout that is familiar to CPU programmers.
       </li>
       <li class="li">
        This format must be used for OpenCL buffers; it can be used for images.
       </li>
       <li class="li">
        Tiled – A tiled layout format has a pre-defined sequence of element blocks arranged in sequential memory addresses (see See One Example of a Tiled Layout Format for a conceptual illustration).
       </li>
       <li class="li">
        A microtile consists of ABIJ; a macrotile consists of the top-left 16 squares for which the arrows are red.
       </li>
       <li class="li">
        Only images can use this format.
       </li>
       <li class="li">
        Translating from user address space to the tiled arrangement is transparent to the user.
       </li>
       <li class="li">
        Tiled memory layouts provide an optimized memory access pattern to make more efficient use of the RAM attached to the GPU compute device.
       </li>
       <li class="li">
        This can contribute to lower latency.
       </li>
       <li class="li">
        Memory access patterns in compute kernels are usually different from those in the pixel shaders.
       </li>
       <li class="li">
        Whereas the access pattern for pixel shaders is in a hierarchical, space-filling curve pattern and is tuned for tiled memory performance (generally for textures), the access pattern for a compute kernel is linear across each row before moving to the next row in the global id space.
       </li>
       <li class="li">
        This has an effect on performance, since pixel shaders have implicit blocking, and compute kernels do not.
       </li>
       <li class="li">
        If accessing a tiled image, best performance is achieved if the application tries to use workgroups as a simple blocking strategy.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-446673" xml:lang="en-US">
     <a name="50401371_pgfId-446673" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-446673" name="50401371_pgfId-446673" shape="rect">
       3.10.3 General Tips 3-49
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Using dynamic pointer assignment in kernels that are executed on the GPU cause inefficient code generation.
       </li>
       <li class="li">
        Many OpenCL specification compiler options that are accepted by the AMD OpenCL compiler are not implemented.
       </li>
       <li class="li">
        The implemented options are -D , -I , w , Werror , -clsingle-precision-constant , -cl-opt-disable , and -cl-fp32-correctly-rounded-divide-sqrt .
       </li>
       <li class="li">
        Avoid declaring global arrays on the kernel’s stack frame as these typically cannot be allocated in registers and require expensive global memory operations.
       </li>
       <li class="li">
        Use predication rather than control-flow.
       </li>
       <li class="li">
        The predication allows the GPU to execute both paths of execution in parallel, which can be faster than attempting to minimize the work through clever control-flow.
       </li>
       <li class="li">
        The reason for this is that if no memory operation exists in a ?
       </li>
       <li class="li">
        : operator (also called a ternary operator), this operation is translated into a single cmov_logical instruction, which is executed in a single cycle.
       </li>
       <li class="li">
        An example of this is: Replace this with: In the first block of code, this translates into an IF/ELSE/ENDIF sequence of CF clauses, each taking ~40 cycles.
       </li>
       <li class="li">
        The math inside the control flow adds two cycles if the control flow is divergent, and one cycle if it is not.
       </li>
       <li class="li">
        This code executes in ~120 cycles.
       </li>
       <li class="li">
        In the second block of code, the ?
       </li>
       <li class="li">
        : operator executes in an ALU clause, so no extra CF instructions are generated.
       </li>
       <li class="li">
        Since the instructions are sequentially dependent, this block of code executes in three cycles, for a ~40x speed improvement.
       </li>
       <li class="li">
        To see this, the first cycle is the (A&gt;B) comparison, the result of which is input to the second cycle, which is the cmov_logical factor, bool, 1, -1.
       </li>
       <li class="li">
        The final cycle is a MAD instruction that: mad C, factor, D, C. If the ratio between CF clauses and ALU instructions is low, this is a good pattern to remove the control flow.
       </li>
       <li class="li">
        Loop Unrolling OpenCL kernels typically are high instruction-per-clock applications.
       </li>
       <li class="li">
        Thus, the overhead to evaluate control-flow and execute branch instructions can consume a significant part of resource that otherwise can be used for high-throughput compute operations.
       </li>
       <li class="li">
        The AMD Accelerated Parallel Processing OpenCL compiler performs simple loop unrolling optimizations; however, for more complex loop unrolling, it may be beneficial to do this manually.
       </li>
       <li class="li">
        If possible, create a reduced-size version of your data set for easier debugging and faster turn-around on performance experimentation.
       </li>
       <li class="li">
        GPUs do not have automatic caching mechanisms and typically scale well as resources are added.
       </li>
       <li class="li">
        In many cases, performance optimization for the reduced-size data implementation also benefits the full-size algorithm.
       </li>
       <li class="li">
        When tuning an algorithm, it is often beneficial to code a simple but accurate algorithm that is retained and used for functional comparison.
       </li>
       <li class="li">
        GPU tuning can be an iterative process, so success requires frequent experimentation, verification, and performance measurement.
       </li>
       <li class="li">
        The profiler and analysis tools report statistics on a per-kernel granularity.
       </li>
       <li class="li">
        To narrow the problem further, it might be useful to remove or comment-out sections of code, then re-run the timing and profiling tool.
       </li>
       <li class="li">
        Writing code with dynamic pointer assignment should be avoided on the GPU.
       </li>
       <li class="li">
        For example: kernel void dyn_assign(global int* a, global int* b, global int* c) { global int* d; size_t idx = get_global_id(0); if (idx &amp; 1) { d = b; } else { d = c; } a[idx] = d[idx]; } This is inefficient because the GPU compiler must know the base pointer that every load comes from and in this situation, the compiler cannot determine what ‘d’ points to.
       </li>
       <li class="li">
        So, both B and C are assigned to the same GPU resource, removing the ability to do certain optimizations.
       </li>
       <li class="li">
        If the algorithm allows changing the work-group size, it is possible to get better performance by using larger work-groups (more work-items in each work-group) because the workgroup creation overhead is reduced.
       </li>
       <li class="li">
        On the other hand, the OpenCL CPU runtime uses a task-stealing algorithm at the work-group level, so when the kernel execution time differs because it contains conditions and/or loops of varying number of iterations, it might be better to increase the number of work-groups.
       </li>
       <li class="li">
        This gives the runtime more flexibility in scheduling work-groups to idle CPU cores.
       </li>
       <li class="li">
        Experimentation might be needed to reach optimal work-group size.
       </li>
       <li class="li">
        Since the AMD OpenCL runtime supports only in-order queuing, using clFinish() on a queue and queuing a blocking command gives the same result.
       </li>
       <li class="li">
        The latter saves the overhead of another API command.
       </li>
       <li class="li">
        For example: clEnqueueWriteBuffer(myCQ, buff, CL_FALSE, 0, buffSize, input, 0, NULL, NULL); clFinish(myCQ); is equivalent, for the AMD OpenCL runtime, to: clEnqueueWriteBuffer(myCQ, buff, CL_TRUE, 0, buffSize, input, 0, NULL, NULL);
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-521164" xml:lang="en-US">
     <a name="50401371_pgfId-521164" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-521164" name="50401371_pgfId-521164" shape="rect">
       3.10.4 Guidance for CUDA Programmers Using OpenCL 3-51
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Porting from CUDA to OpenCL is relatively straightforward.
       </li>
       <li class="li">
        Multiple vendors have documents describing how to do this, including AMD: https://developer.amd.com/documentation/articles/pages/OpenCL-and-the-ATI-Stream-v2.0-Beta.aspx#four Some specific performance recommendations which differ from other GPU architectures: Use a workgroup size that is a multiple of 64.
       </li>
       <li class="li">
        CUDA code can use a workgroup size of 32; this uses only half the available compute resources on an ATI Radeon  HD 5870 GPU.
       </li>
       <li class="li">
        Vectorization can lead to substantially greater efficiency.
       </li>
       <li class="li">
        The ALUPacking counter provided by the Profiler can track how well the kernel code is using the five-wide (or four-wide, depending on the GPU type) VLIW unit.
       </li>
       <li class="li">
        Values below 70 percent may indicate that dependencies are preventing the full use of the processor.
       </li>
       <li class="li">
        For some kernels, vectorization can be used to increase efficiency and improve kernel performance.
       </li>
       <li class="li">
        AMD GPUs have a very high single-precision flops capability (2.72 teraflops in a single ATI Radeon  HD 5870 GPU).
       </li>
       <li class="li">
        Algorithms that benefit from such throughput can deliver excellent performance on AMD Accelerated Parallel Processing hardware.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-446698" xml:lang="en-US">
     <a name="50401371_pgfId-446698" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-446698" name="50401371_pgfId-446698" shape="rect">
       3.10.5 Guidance for CPU Programmers Using OpenCL to Program GPUs 3-52
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        OpenCL is the industry-standard toolchain for programming GPUs and parallel devices from many vendors.
       </li>
       <li class="li">
        It is expected that many programmers skilled in CPU programming will program GPUs for the first time using OpenCL.
       </li>
       <li class="li">
        This section provides some guidance for experienced programmers who are programming a GPU for the first time.
       </li>
       <li class="li">
        It specifically highlights the key differences in optimization strategy.
       </li>
       <li class="li">
        Study the local memory (LDS) optimizations.
       </li>
       <li class="li">
        These greatly affect the GPU performance.
       </li>
       <li class="li">
        Note the difference in the organization of local memory on the GPU as compared to the CPU cache.
       </li>
       <li class="li">
        Local memory is shared by many work-items (64 on Cypress).
       </li>
       <li class="li">
        This contrasts with a CPU cache that normally is dedicated to a single work-item.
       </li>
       <li class="li">
        GPU kernels run well when they collaboratively load the shared memory.
       </li>
       <li class="li">
        GPUs have a large amount of raw compute horsepower, compared to memory bandwidth and to “control flow” bandwidth.
       </li>
       <li class="li">
        This leads to some high-level differences in GPU programming strategy.
       </li>
       <li class="li">
        A CPU-optimized algorithm may test branching conditions to minimize the workload.
       </li>
       <li class="li">
        On a GPU, it is frequently faster simply to execute the workload.
       </li>
       <li class="li">
        A CPU-optimized version can use memory to store and later load pre-computed values.
       </li>
       <li class="li">
        On a GPU, it frequently is faster to recompute values rather than saving them in registers.
       </li>
       <li class="li">
        Per-thread registers are a scarce resource on the CPU; in contrast, GPUs have many available per-thread register resources.
       </li>
       <li class="li">
        Use float4 and the OpenCL built-ins for vector types ( vload , vstore , etc.).
       </li>
       <li class="li">
        These enable the AMD Accelerated Parallel Processing OpenCL implementation to generate efficient, packed SSE instructions when running on the CPU.
       </li>
       <li class="li">
        Vectorization is an optimization that benefits both the AMD CPU and GPU.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-521316" xml:lang="en-US">
     <a name="50401371_pgfId-521316" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-521316" name="50401371_pgfId-521316" shape="rect">
       3.10.6 Optimizing Kernel Code 3-53
      </a>
     </h3>
     <div class="topic concept nested4" id="50401371_pgfId-521317" xml:lang="en-US">
      <a name="50401371_pgfId-521317" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-521317" name="50401371_pgfId-521317" shape="rect">
        Using Vector Data Types 3-53
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The CPU contains a vector unit, which can be efficiently used if the developer is writing the code using vector data types.
        </li>
        <li class="li">
         For architectures before Bulldozer, the instruction set is called SSE, and the vector width is 128 bits.
        </li>
        <li class="li">
         For Bulldozer, there the instruction set is called AVX, for which the vector width is increased to 256 bits.
        </li>
        <li class="li">
         Using four-wide vector types (int4, float4, etc.)
        </li>
        <li class="li">
         is preferred, even with Bulldozer.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401371_pgfId-521255" xml:lang="en-US">
      <a name="50401371_pgfId-521255" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-521255" name="50401371_pgfId-521255" shape="rect">
        Local Memory 3-53
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The CPU does not benefit much from local memory; sometimes it is detrimental to performance.
        </li>
        <li class="li">
         As local memory is emulated on the CPU by using the caches, accessing local memory and global memory are the same speed, assuming the information from the global memory is in the cache.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401371_pgfId-521257" xml:lang="en-US">
      <a name="50401371_pgfId-521257" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-521257" name="50401371_pgfId-521257" shape="rect">
        Using Special CPU Instructions 3-53
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The Bulldozer family of CPUs supports FMA4 instructions, exchanging instructions of the form a*b+c with fma(a,b,c) or mad(a,b,c) allows for the use of the special hardware instructions for multiplying and adding.
        </li>
        <li class="li">
         There also is hardware support for OpenCL functions that give the new hardware implementation of rotating.
        </li>
        <li class="li">
         For example: can be written as a composition of mad instructions which use fused multiple add (FMA):
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401371_pgfId-521264" xml:lang="en-US">
      <a name="50401371_pgfId-521264" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-521264" name="50401371_pgfId-521264" shape="rect">
        Avoid Barriers When Possible 3-53
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Using barriers in a kernel on the CPU causes a significant performance penalty compared to the same kernel without barriers.
        </li>
        <li class="li">
         Use a barrier only if the kernel requires it for correctness, and consider changing the algorithm to reduce barriers usage.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="50401371_pgfId-521246" xml:lang="en-US">
     <a name="50401371_pgfId-521246" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-521246" name="50401371_pgfId-521246" shape="rect">
       3.10.7 Optimizing Kernels for Evergreen and 69XX-Series GPUs 3-53
      </a>
     </h3>
     <div class="topic concept nested4" id="50401371_pgfId-494703" xml:lang="en-US">
      <a name="50401371_pgfId-494703" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-494703" name="50401371_pgfId-494703" shape="rect">
        Clauses 3-53
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The architecture for the 69XX series of GPUs is clause-based.
        </li>
        <li class="li">
         A clause is similar to a basic block, a sequence of instructions that execute without flow control or I/O.
        </li>
        <li class="li">
         Processor efficiency is determined in large part by the number of instructions in a clause, which is determined by the frequency of branching and I/O at the source-code level.
        </li>
        <li class="li">
         An efficient kernel averages at least 16 or 32 instructions per clause.
        </li>
        <li class="li">
         The AMD APP KernelAnalyzer2 assembler listing lets you view clauses.
        </li>
        <li class="li">
         Try the optimizations listed here from inside the AMD APP KernelAnalyzer2 to see the improvements in performance.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401371_pgfId-494706" xml:lang="en-US">
      <a name="50401371_pgfId-494706" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-494706" name="50401371_pgfId-494706" shape="rect">
        Remove Conditional Assignments 3-54
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         A conditional of the form “if-then-else” generates branching and thus generates one or more clauses.
        </li>
        <li class="li">
         Use the select() function to replace these structures with conditional assignments that do not cause branching.
        </li>
        <li class="li">
         For example: becomes Note that if the body of the if statement contains an I/O, the if statement cannot be eliminated.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401371_pgfId-494711" xml:lang="en-US">
      <a name="50401371_pgfId-494711" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-494711" name="50401371_pgfId-494711" shape="rect">
        Bypass Short-Circuiting 3-54
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         A conditional expression with many terms can compile into a number of clauses due to the C-language requirement that expressions must short circuit.
        </li>
        <li class="li">
         To prevent this, move the expression out of the control flow statement.
        </li>
        <li class="li">
         For example: becomes The same applies to conditional expressions used in loop constructs ( do , while , for ).
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401371_pgfId-494717" xml:lang="en-US">
      <a name="50401371_pgfId-494717" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-494717" name="50401371_pgfId-494717" shape="rect">
        Unroll Small Loops 3-54
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         If the loop bounds are known, and the loop is small (less than 16 or 32 instructions), unrolling the loop usually increases performance.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401371_pgfId-494719" xml:lang="en-US">
      <a name="50401371_pgfId-494719" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-494719" name="50401371_pgfId-494719" shape="rect">
        Avoid Nested  if s 3-54
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Because the GPU is a Vector ALU architecture, there is a cost to executing an if-then-else block because both sides of the branch are evaluated, then one result is retained while the other is discarded.
        </li>
        <li class="li">
         When if blocks are nested, the results are twice as bad; in general, if blocks are nested k levels deep, there 2^k clauses are generated.
        </li>
        <li class="li">
         In this situation, restructure the code to eliminate nesting.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401371_pgfId-494721" xml:lang="en-US">
      <a name="50401371_pgfId-494721" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-494721" name="50401371_pgfId-494721" shape="rect">
        Experiment With  do / while / for Loops 3-55
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         for loops can generate more clauses than equivalent do or while loops.
        </li>
        <li class="li">
         Experiment with these different loop types to find the one with best performance.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="50401371_pgfId-494723" xml:lang="en-US">
      <a name="50401371_pgfId-494723" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/opencl-optimization-guide/#50401371_pgfId-494723" name="50401371_pgfId-494723" shape="rect">
        Do I/O With 4-Word Data 3-55
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The native hardware I/O transaction size is four words (float4, int4 types).
        </li>
        <li class="li">
         Avoid I/Os with smaller data, and rewrite the kernel to use the native size data.
        </li>
        <li class="li">
         Kernel performance increases, and only 25% as many work items need to be dispatched.
        </li>
       </ul>
      </div>
     </div>
    </div>
   </div>
  </div>
 </article>
</div>
 {% endblock %} 
