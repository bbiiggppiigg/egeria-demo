{% extends "cuda/base.html" %} 
 {% block sitenav %}
<nav id="site-nav">
 <div class="category" state="0">
  <a href="http://{{host}}:{{port}}/{{docname}}/raw">
   Optimization Guide
  </a>
 </div>
 <div class="category" state="0">
  <a href="http://{{host}}:{{port}}/{{docname}}/summary">
   Optimization Guide Summary
  </a>
 </div>
 <ul>
  <li>
   <div class="section-link" state="1">
    <a href="#introduction">
     1. Introduction
    </a>
   </div>
   <ul>
    <li>
     <div class="section-link" state="2">
      <a href="#from-graphics-processing-to-general-purpose-parallel-computing">
       1.1. From Graphics Processing to General Purpose Parallel Computing
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#cuda-general-purpose-parallel-computing-architecture">
       1.2. CUDA®: A General-Purpose Parallel Computing
                           Platform and Programming Model
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#scalable-programming-model">
       1.3. A Scalable Programming Model
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#document-structure">
       1.4. Document Structure
      </a>
     </div>
    </li>
   </ul>
  </li>
  <li>
   <div class="section-link" state="1">
    <a href="#programming-model">
     2. Programming Model
    </a>
   </div>
   <ul>
    <li>
     <div class="section-link" state="2">
      <a href="#kernels">
       2.1. Kernels
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#thread-hierarchy">
       2.2. Thread Hierarchy
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#memory-hierarchy">
       2.3. Memory Hierarchy
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#heterogeneous-programming">
       2.4. Heterogeneous Programming
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#compute-capability">
       2.5. Compute Capability
      </a>
     </div>
    </li>
   </ul>
  </li>
  <li>
   <div class="section-link" state="1">
    <a href="#programming-interface">
     3. Programming Interface
    </a>
   </div>
   <ul>
    <li>
     <div class="section-link" state="2">
      <a href="#compilation-with-nvcc">
       3.1. Compilation with NVCC
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#compilation-workflow">
         3.1.1. Compilation Workflow
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#offline-compilation">
           3.1.1.1. Offline Compilation
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#just-in-time-compilation">
           3.1.1.2. Just-in-Time Compilation
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#binary-compatibility">
         3.1.2. Binary Compatibility
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#ptx-compatibility">
         3.1.3. PTX Compatibility
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#application-compatibility">
         3.1.4. Application Compatibility
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#c-cplusplus-compatibility">
         3.1.5. C/C++ Compatibility
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#sixtyfour-bit-compatibility">
         3.1.6. 64-Bit Compatibility
        </a>
       </div>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#cuda-c-runtime">
       3.2. CUDA C Runtime
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#initialization">
         3.2.1. Initialization
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#device-memory">
         3.2.2. Device Memory
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#shared-memory">
         3.2.3. Shared Memory
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#page-locked-host-memory">
         3.2.4. Page-Locked Host Memory
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#portable-memory">
           3.2.4.1. Portable Memory
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#write-combining-memory">
           3.2.4.2. Write-Combining Memory
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#mapped-memory">
           3.2.4.3. Mapped Memory
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#asynchronous-concurrent-execution">
         3.2.5. Asynchronous Concurrent Execution
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#concurrent-execution-host-device">
           3.2.5.1. Concurrent Execution between Host and Device
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#concurrent-kernel-execution">
           3.2.5.2. Concurrent Kernel Execution
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#overlap-of-data-transfer-and-kernel-execution">
           3.2.5.3. Overlap of Data Transfer and Kernel Execution
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#concurrent-data-transfers">
           3.2.5.4. Concurrent Data Transfers
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#streams">
           3.2.5.5. Streams
          </a>
         </div>
         <ul>
          <li>
           <div class="section-link" state="5">
            <a href="#creation-and-destruction-streams">
             3.2.5.5.1. Creation and Destruction
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#default-stream">
             3.2.5.5.2. Default Stream
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#explicit-synchronization">
             3.2.5.5.3. Explicit Synchronization
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#implicit-synchronization">
             3.2.5.5.4. Implicit Synchronization
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#overlapping-behavior">
             3.2.5.5.5. Overlapping Behavior
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#stream-callbacks">
             3.2.5.5.6. Callbacks
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#stream-priorities">
             3.2.5.5.7. Stream Priorities
            </a>
           </div>
          </li>
         </ul>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#events">
           3.2.5.6. Events
          </a>
         </div>
         <ul>
          <li>
           <div class="section-link" state="5">
            <a href="#creation-and-destruction-events">
             3.2.5.6.1. Creation and Destruction
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#elapsed-time">
             3.2.5.6.2. Elapsed Time
            </a>
           </div>
          </li>
         </ul>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#synchronous-calls">
           3.2.5.7. Synchronous Calls
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#multi-device-system">
         3.2.6. Multi-Device System
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#device-enumeration">
           3.2.6.1. Device Enumeration
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#device-selection">
           3.2.6.2. Device Selection
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#stream-and-event-behavior">
           3.2.6.3. Stream and Event Behavior
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#peer-to-peer-memory-access">
           3.2.6.4. Peer-to-Peer Memory Access
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#peer-to-peer-memory-copy">
           3.2.6.5. Peer-to-Peer Memory Copy
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#unified-virtual-address-space">
         3.2.7. Unified Virtual Address Space
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#interprocess-communication">
         3.2.8. Interprocess Communication
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#error-checking">
         3.2.9. Error Checking
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#call-stack">
         3.2.10. Call Stack
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#texture-and-surface-memory">
         3.2.11. Texture and Surface Memory
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#texture-memory">
           3.2.11.1. Texture Memory
          </a>
         </div>
         <ul>
          <li>
           <div class="section-link" state="5">
            <a href="#texture-object-api">
             3.2.11.1.1. Texture Object API
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#texture-reference-api">
             3.2.11.1.2. Texture Reference API
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#sixteen-bit-floating-point-textures">
             3.2.11.1.3. 16-Bit Floating-Point Textures
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#layered-textures">
             3.2.11.1.4. Layered Textures
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#cubemap-textures">
             3.2.11.1.5. Cubemap Textures
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#cubemap-layered-textures">
             3.2.11.1.6. Cubemap Layered Textures
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#texture-gather">
             3.2.11.1.7. Texture Gather
            </a>
           </div>
          </li>
         </ul>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surface-memory">
           3.2.11.2. Surface Memory
          </a>
         </div>
         <ul>
          <li>
           <div class="section-link" state="5">
            <a href="#surface-object-api">
             3.2.11.2.1. Surface Object API
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#surface-reference-api">
             3.2.11.2.2. Surface Reference API
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#cubemap-surfaces">
             3.2.11.2.3. Cubemap Surfaces
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#cubemap-layered-surfaces">
             3.2.11.2.4. Cubemap Layered Surfaces
            </a>
           </div>
          </li>
         </ul>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#cuda-arrays">
           3.2.11.3. CUDA Arrays
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#read-write-coherency">
           3.2.11.4. Read/Write Coherency
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#graphics-interoperability">
         3.2.12. Graphics Interoperability
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#opengl-interoperability">
           3.2.12.1. OpenGL Interoperability
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#direct3d-interoperability">
           3.2.12.2. Direct3D Interoperability
          </a>
         </div>
         <ul>
          <li>
           <div class="section-link" state="5">
            <a href="#direct3d-9-version">
             3.2.12.2.1. Direct3D 9 Version
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#direct3d-10-version">
             3.2.12.2.2. Direct3D 10 Version
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#direct3d-11-version">
             3.2.12.2.3. Direct3D 11 Version
            </a>
           </div>
          </li>
         </ul>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#sli-interoperability">
           3.2.12.3. SLI Interoperability
          </a>
         </div>
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#versioning-and-compatibility">
       3.3. Versioning and Compatibility
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#compute-modes">
       3.4. Compute Modes
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#mode-switches">
       3.5. Mode Switches
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#tesla-compute-cluster-mode-for-windows">
       3.6. Tesla Compute Cluster Mode for Windows
      </a>
     </div>
    </li>
   </ul>
  </li>
  <li>
   <div class="section-link" state="1">
    <a href="#hardware-implementation">
     4. Hardware Implementation
    </a>
   </div>
   <ul>
    <li>
     <div class="section-link" state="2">
      <a href="#simt-architecture">
       4.1. SIMT Architecture
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#hardware-multithreading">
       4.2. Hardware Multithreading
      </a>
     </div>
    </li>
   </ul>
  </li>
  <li>
   <div class="section-link" state="1">
    <a href="#performance-guidelines">
     5. Performance Guidelines
    </a>
   </div>
   <ul>
    <li>
     <div class="section-link" state="2">
      <a href="#overall-performance-optimization-strategies">
       5.1. Overall Performance Optimization Strategies
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#maximize-utilization">
       5.2. Maximize Utilization
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#application-level">
         5.2.1. Application Level
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#device-level">
         5.2.2. Device Level
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#multiprocessor-level">
         5.2.3. Multiprocessor Level
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#occupancy-calculator">
           5.2.3.1. Occupancy Calculator
          </a>
         </div>
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#maximize-memory-throughput">
       5.3. Maximize Memory Throughput
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#data-transfer-between-host-and-device">
         5.3.1. Data Transfer between Host and Device
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#device-memory-accesses">
         5.3.2. Device Memory Accesses
        </a>
       </div>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#maximize-instruction-throughput">
       5.4. Maximize Instruction Throughput
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#arithmetic-instructions">
         5.4.1. Arithmetic Instructions
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#control-flow-instructions">
         5.4.2. Control Flow Instructions
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#synchronization-instruction">
         5.4.3. Synchronization Instruction
        </a>
       </div>
      </li>
     </ul>
    </li>
   </ul>
  </li>
  <li>
   <div class="section-link" state="1">
    <a href="#cuda-enabled-gpus">
     A. CUDA-Enabled GPUs
    </a>
   </div>
  </li>
  <li>
   <div class="section-link" state="1">
    <a href="#c-language-extensions">
     B. C Language Extensions
    </a>
   </div>
   <ul>
    <li>
     <div class="section-link" state="2">
      <a href="#function-type-qualifiers">
       B.1. Function Type Qualifiers
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#device-function-qualifier">
         B.1.1. __device__
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#global">
         B.1.2. __global__
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#host">
         B.1.3. __host__
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#noinline-and-forceinline">
         B.1.4. __noinline__ and __forceinline__
        </a>
       </div>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#variable-type-qualifiers">
       B.2. Variable Type Qualifiers
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#device-variable-qualifier">
         B.2.1. __device__
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#constant">
         B.2.2. __constant__
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#shared">
         B.2.3. __shared__
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#managed">
         B.2.4. __managed__
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#restrict">
         B.2.5. __restrict__
        </a>
       </div>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#built-in-vector-types">
       B.3. Built-in Vector Types
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#vector-types">
         B.3.1. char, short, int, long, longlong, float, double
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#dim3">
         B.3.2. dim3
        </a>
       </div>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#built-in-variables">
       B.4. Built-in Variables
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#griddim">
         B.4.1. gridDim
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#blockidx">
         B.4.2. blockIdx
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#blockdim">
         B.4.3. blockDim
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#threadidx">
         B.4.4. threadIdx
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#warpsize">
         B.4.5. warpSize
        </a>
       </div>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#memory-fence-functions">
       B.5. Memory Fence Functions
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#synchronization-functions">
       B.6. Synchronization Functions
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#mathematical-functions">
       B.7. Mathematical Functions
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#texture-functions">
       B.8. Texture Functions
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#texture-object-api-appendix">
         B.8.1. Texture Object API
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#tex1dfetch-object">
           B.8.1.1. tex1Dfetch()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex1d-object">
           B.8.1.2. tex1D()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex1dlod-object">
           B.8.1.3. tex1DLod()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex1dgrad-object">
           B.8.1.4. tex1DGrad()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex2d-object">
           B.8.1.5. tex2D()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex2dlod-object">
           B.8.1.6. tex2DLod()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex2dgrad-object">
           B.8.1.7. tex2DGrad()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex3d-object">
           B.8.1.8. tex3D()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex3dlod-object">
           B.8.1.9. tex3DLod()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex3dgrad-object">
           B.8.1.10. tex3DGrad()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex1dlayered-object">
           B.8.1.11. tex1DLayered()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex1dlayeredlod-object">
           B.8.1.12. tex1DLayeredLod()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex1dlayeredgrad-object">
           B.8.1.13. tex1DLayeredGrad()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex2dlayered-object">
           B.8.1.14. tex2DLayered()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex2dlayeredlod-object">
           B.8.1.15. tex2DLayeredLod()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex2dlayeredgrad-object">
           B.8.1.16. tex2DLayeredGrad()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#texcubemap-object">
           B.8.1.17. texCubemap()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#texcubemaplod-object">
           B.8.1.18. texCubemapLod()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#texcubemaplayered-object">
           B.8.1.19. texCubemapLayered()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#texcubemaplayeredlod-object">
           B.8.1.20. texCubemapLayeredLod()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex2dgather-object">
           B.8.1.21. tex2Dgather()
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#texture-reference-api-appendix">
         B.8.2. Texture Reference API
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#tex1dfetch">
           B.8.2.1. tex1Dfetch()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex1d">
           B.8.2.2. tex1D()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex1dlod">
           B.8.2.3. tex1DLod()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex1dgrad">
           B.8.2.4. tex1DGrad()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex2d">
           B.8.2.5. tex2D()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex2dlod">
           B.8.2.6. tex2DLod()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex2dgrad">
           B.8.2.7. tex2DGrad()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex3d">
           B.8.2.8. tex3D()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex3dlod">
           B.8.2.9. tex3DLod()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex3dgrad">
           B.8.2.10. tex3DGrad()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex1dlayered">
           B.8.2.11. tex1DLayered()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex1dlayeredlod">
           B.8.2.12. tex1DLayeredLod()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex1dlayeredgrad">
           B.8.2.13. tex1DLayeredGrad()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex2dlayered">
           B.8.2.14. tex2DLayered()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex2dlayeredlod">
           B.8.2.15. tex2DLayeredLod()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex2dlayeredgrad">
           B.8.2.16. tex2DLayeredGrad()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#texcubemap">
           B.8.2.17. texCubemap()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#texcubemaplod">
           B.8.2.18. texCubemapLod()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#texcubemaplayered">
           B.8.2.19. texCubemapLayered()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#texcubemaplayeredlod">
           B.8.2.20. texCubemapLayeredLod()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#tex2dgather">
           B.8.2.21. tex2Dgather()
          </a>
         </div>
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#surface-functions">
       B.9. Surface Functions
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#surface-object-api-appendix">
         B.9.1. Surface Object API
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#surf1dread-object">
           B.9.1.1. surf1Dread()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surf1dwrite-object">
           B.9.1.2. surf1Dwrite
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surf2dread-object">
           B.9.1.3. surf2Dread()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surf2dwrite-object">
           B.9.1.4. surf2Dwrite()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surf3dread-object">
           B.9.1.5. surf3Dread()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surf3dwrite-object">
           B.9.1.6. surf3Dwrite()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surf1dlayeredread-object">
           B.9.1.7. surf1DLayeredread()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surf1dlayeredwrite-object">
           B.9.1.8. surf1DLayeredwrite()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surf2dlayeredread-object">
           B.9.1.9. surf2DLayeredread()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surf2dlayeredwrite-object">
           B.9.1.10. surf2DLayeredwrite()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surfcubemapread-object">
           B.9.1.11. surfCubemapread()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surfcubemapwrite-object">
           B.9.1.12. surfCubemapwrite()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surfcubemaplayeredread-object">
           B.9.1.13. surfCubemapLayeredread()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surfcubemaplayeredwrite-object">
           B.9.1.14. surfCubemapLayeredwrite()
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#surface-reference-api-appendix">
         B.9.2. Surface Reference API
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#surf1dread">
           B.9.2.1. surf1Dread()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surf1dwrite">
           B.9.2.2. surf1Dwrite
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surf2dread">
           B.9.2.3. surf2Dread()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surf2dwrite">
           B.9.2.4. surf2Dwrite()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surf3dread">
           B.9.2.5. surf3Dread()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surf3dwrite">
           B.9.2.6. surf3Dwrite()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surf1dlayeredread">
           B.9.2.7. surf1DLayeredread()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surf1dlayeredwrite">
           B.9.2.8. surf1DLayeredwrite()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surf2dlayeredread">
           B.9.2.9. surf2DLayeredread()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surf2dlayeredwrite">
           B.9.2.10. surf2DLayeredwrite()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surfcubemapread">
           B.9.2.11. surfCubemapread()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surfcubemapwrite">
           B.9.2.12. surfCubemapwrite()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surfcubemaplayeredread">
           B.9.2.13. surfCubemapLayeredread()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#surfcubemaplayeredwrite">
           B.9.2.14. surfCubemapLayeredwrite()
          </a>
         </div>
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#ldg-function">
       B.10. Read-Only Data Cache Load Function
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#time-function">
       B.11. Time Function
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#atomic-functions">
       B.12. Atomic Functions
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#arithmetic-functions">
         B.12.1. Arithmetic Functions
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#atomicadd">
           B.12.1.1. atomicAdd()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#atomicsub">
           B.12.1.2. atomicSub()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#atomicexch">
           B.12.1.3. atomicExch()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#atomicmin">
           B.12.1.4. atomicMin()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#atomicmax">
           B.12.1.5. atomicMax()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#atomicinc">
           B.12.1.6. atomicInc()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#atomicdec">
           B.12.1.7. atomicDec()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#atomiccas">
           B.12.1.8. atomicCAS()
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#bitwise-functions">
         B.12.2. Bitwise Functions
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#atomicand">
           B.12.2.1. atomicAnd()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#atomicor">
           B.12.2.2. atomicOr()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#atomicxor">
           B.12.2.3. atomicXor()
          </a>
         </div>
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#warp-vote-functions">
       B.13. Warp Vote Functions
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#warp-shuffle-functions">
       B.14. Warp Shuffle Functions
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#synopsis">
         B.14.1. Synopsis
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#warp-description">
         B.14.2. Description
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#return-value">
         B.14.3. Return Value
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#warp-notes">
         B.14.4. Notes
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#warp-examples">
         B.14.5. Examples
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#warp-examples-broadcast">
           B.14.5.1. Broadcast of a single value across a warp
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#warp-examples-inclusive">
           B.14.5.2. Inclusive plus-scan across sub-partitions of 8 threads
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#warp-examples-reduction">
           B.14.5.3. Reduction across a warp
          </a>
         </div>
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#profiler-counter-function">
       B.15. Profiler Counter Function
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#assertion">
       B.16. Assertion
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#formatted-output">
       B.17. Formatted Output
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#format-specifiers">
         B.17.1. Format Specifiers
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#limitations">
         B.17.2. Limitations
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#associated-host-side-api">
         B.17.3. Associated Host-Side API
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#examples">
         B.17.4. Examples
        </a>
       </div>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#dynamic-global-memory-allocation-and-operations">
       B.18. Dynamic Global Memory Allocation and Operations
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#heap-memory-allocation">
         B.18.1. Heap Memory Allocation
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#interoperability-host-memory-api">
         B.18.2. Interoperability with Host Memory API
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#examples-per-thread">
         B.18.3. Examples
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#per-thread-allocation">
           B.18.3.1. Per Thread Allocation
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#per-thread-block-allocation">
           B.18.3.2. Per Thread Block Allocation
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#allocation-persisting-kernel-launches">
           B.18.3.3. Allocation Persisting Between Kernel Launches
          </a>
         </div>
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#execution-configuration">
       B.19. Execution Configuration
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#launch-bounds">
       B.20. Launch Bounds
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#pragma-unroll">
       B.21. #pragma unroll
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#simd-video">
       B.22. SIMD Video Instructions
      </a>
     </div>
    </li>
   </ul>
  </li>
  <li>
   <div class="section-link" state="1">
    <a href="#cuda-dynamic-parallelism">
     C. CUDA Dynamic Parallelism
    </a>
   </div>
   <ul>
    <li>
     <div class="section-link" state="2">
      <a href="#introduction-cuda-dynamic-parallelism">
       C.1. Introduction
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#overview">
         C.1.1. Overview
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#glossary">
         C.1.2. Glossary
        </a>
       </div>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#execution-environment-and-memory-model">
       C.2. Execution Environment and Memory Model
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#execution-environment">
         C.2.1. Execution Environment
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#parent-and-child-grids">
           C.2.1.1. Parent and Child Grids
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#scope-of-cuda-primitives">
           C.2.1.2. Scope of CUDA Primitives
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#synchronization">
           C.2.1.3. Synchronization
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#streams-and-events">
           C.2.1.4. Streams and Events
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#ordering-and-concurrency">
           C.2.1.5. Ordering and Concurrency
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#device-management">
           C.2.1.6. Device Management
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#memory-model">
         C.2.2. Memory Model
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#coherence-and-consistency">
           C.2.2.1. Coherence and Consistency
          </a>
         </div>
         <ul>
          <li>
           <div class="section-link" state="5">
            <a href="#global-memory">
             C.2.2.1.1. Global Memory
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#zero-copy-memory">
             C.2.2.1.2. Zero Copy Memory
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#constant-memory">
             C.2.2.1.3. Constant Memory
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#shared-and-local-memory">
             C.2.2.1.4. Shared and Local Memory
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#local-memory">
             C.2.2.1.5. Local Memory
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#texture-memory-cdp">
             C.2.2.1.6. Texture Memory
            </a>
           </div>
          </li>
         </ul>
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#programming-interface-cdp">
       C.3. Programming Interface
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#cuda-c-cplusplus">
         C.3.1. CUDA C/C++ Reference
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#device-side-kernel-launch">
           C.3.1.1. Device-Side Kernel Launch
          </a>
         </div>
         <ul>
          <li>
           <div class="section-link" state="5">
            <a href="#launches-are-asynchronous">
             C.3.1.1.1. Launches are Asynchronous
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#launch-environment-configuration">
             C.3.1.1.2. Launch Environment Configuration
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#launch-from-host-device-functions">
             C.3.1.1.3. Launch from __host__ __device__ Functions
            </a>
           </div>
          </li>
         </ul>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#streams-cdp">
           C.3.1.2. Streams
          </a>
         </div>
         <ul>
          <li>
           <div class="section-link" state="5">
            <a href="#implicit-null-stream">
             C.3.1.2.1. The Implicit (NULL) Stream
            </a>
           </div>
          </li>
         </ul>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#events-cdp">
           C.3.1.3. Events
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#synchronization-programming-interface">
           C.3.1.4. Synchronization
          </a>
         </div>
         <ul>
          <li>
           <div class="section-link" state="5">
            <a href="#block-wide-synchronization">
             C.3.1.4.1. Block Wide Synchronization
            </a>
           </div>
          </li>
         </ul>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#device-management-programming">
           C.3.1.5. Device Management
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#memory-declarations">
           C.3.1.6. Memory Declarations
          </a>
         </div>
         <ul>
          <li>
           <div class="section-link" state="5">
            <a href="#device-and-constant-memory">
             C.3.1.6.1. Device and Constant Memory
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#textures-and-surfaces">
             C.3.1.6.2. Textures &amp; Surfaces
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#shared-memory-variable-declarations">
             C.3.1.6.3. Shared Memory Variable Declarations
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#symbol-addresses">
             C.3.1.6.4. Symbol Addresses
            </a>
           </div>
          </li>
         </ul>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#api-errors-and-launch-failures">
           C.3.1.7. API Errors and Launch Failures
          </a>
         </div>
         <ul>
          <li>
           <div class="section-link" state="5">
            <a href="#launch-setup-apis">
             C.3.1.7.1. Launch Setup APIs
            </a>
           </div>
          </li>
         </ul>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#api-reference">
           C.3.1.8. API Reference
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#device-side-launch-from-ptx">
         C.3.2. Device-side Launch from PTX
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#kernel-launch-apis">
           C.3.2.1. Kernel Launch APIs
          </a>
         </div>
         <ul>
          <li>
           <div class="section-link" state="5">
            <a href="#cudalaunchdevice">
             C.3.2.1.1. cudaLaunchDevice
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#cudagetparameterbuffer">
             C.3.2.1.2. cudaGetParameterBuffer
            </a>
           </div>
          </li>
         </ul>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#parameter-buffer-layout">
           C.3.2.2. Parameter Buffer Layout
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#toolkit-support-for-dynamic-parallelism">
         C.3.3. Toolkit Support for Dynamic Parallelism
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#including-device-runtime-api-in-cuda-code">
           C.3.3.1. Including Device Runtime API in CUDA Code
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#compiling-and-linking">
           C.3.3.2. Compiling and Linking
          </a>
         </div>
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#programming-guidelines">
       C.4. Programming Guidelines
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#basics">
         C.4.1. Basics
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#performance">
         C.4.2. Performance
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#synchronization-performance">
           C.4.2.1. Synchronization
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#dynamic-parallelism-enabled-kernel-overhead">
           C.4.2.2. Dynamic-parallelism-enabled Kernel Overhead
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#implementation-restrictions-and-limitations">
         C.4.3. Implementation Restrictions and Limitations
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#runtime">
           C.4.3.1. Runtime
          </a>
         </div>
         <ul>
          <li>
           <div class="section-link" state="5">
            <a href="#memory-footprint">
             C.4.3.1.1. Memory Footprint
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#nesting-and-synchronization-depth">
             C.4.3.1.2. Nesting and Synchronization Depth
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#pending-kernel-launches">
             C.4.3.1.3. Pending Kernel Launches
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#configuration-options">
             C.4.3.1.4. Configuration Options
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#memory-allocation-and-lifetime">
             C.4.3.1.5. Memory Allocation and Lifetime
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#sm-id-and-warp-id">
             C.4.3.1.6. SM Id and Warp Id
            </a>
           </div>
          </li>
          <li>
           <div class="section-link" state="5">
            <a href="#ecc-errors">
             C.4.3.1.7. ECC Errors
            </a>
           </div>
          </li>
         </ul>
        </li>
       </ul>
      </li>
     </ul>
    </li>
   </ul>
  </li>
  <li>
   <div class="section-link" state="1">
    <a href="#mathematical-functions-appendix">
     D. Mathematical Functions
    </a>
   </div>
   <ul>
    <li>
     <div class="section-link" state="2">
      <a href="#standard-functions">
       D.1. Standard Functions
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#intrinsic-functions">
       D.2. Intrinsic Functions
      </a>
     </div>
    </li>
   </ul>
  </li>
  <li>
   <div class="section-link" state="1">
    <a href="#c-cplusplus-language-support">
     E. C/C++ Language Support
    </a>
   </div>
   <ul>
    <li>
     <div class="section-link" state="2">
      <a href="#language-features">
       E.1. C++11 Language Features
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#restrictions">
       E.2. Restrictions
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#host-compiler-extensions">
         E.2.1. Host Compiler Extensions
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#preprocessor-symbols">
         E.2.2. Preprocessor Symbols
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#cuda-arch-macro">
           E.2.2.1. __CUDA_ARCH__
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#qualifiers">
         E.2.3. Qualifiers
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#device-memory-qualifiers">
           E.2.3.1. Device Memory Qualifiers
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#managed-qualifier">
           E.2.3.2. __managed__ Qualifier
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#volatile-qualifier">
           E.2.3.3. Volatile Qualifier
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#pointers">
         E.2.4. Pointers
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#operators">
         E.2.5. Operators
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#assignment-operator">
           E.2.5.1. Assignment Operator
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#address-operator">
           E.2.5.2. Address Operator
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#rtti">
         E.2.6. Run Time Type Information (RTTI)
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#exception-handling">
         E.2.7. Exception Handling
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#standard-library">
         E.2.8. Standard Library
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#functions">
         E.2.9. Functions
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#external-linkage">
           E.2.9.1. External Linkage
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#compiler-generated-functions">
           E.2.9.2. Compiler generated functions
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#function-parameters">
           E.2.9.3. Function Parameters
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#static-variables-function">
           E.2.9.4. Static Variables within Function
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#function-pointers">
           E.2.9.5. Function Pointers
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#function-recursion">
           E.2.9.6. Function Recursion
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#classes">
         E.2.10. Classes
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#data-members">
           E.2.10.1. Data Members
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#function-members">
           E.2.10.2. Function Members
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#virtual-functions">
           E.2.10.3. Virtual Functions
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#virtual-base-classes">
           E.2.10.4. Virtual Base Classes
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#anon-union">
           E.2.10.5. Anonymous Unions
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#windows-specific">
           E.2.10.6. Windows-Specific
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#templates">
         E.2.11. Templates
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#trigraph-digraph">
         E.2.12. Trigraphs and Digraphs
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#const-variables">
         E.2.13. Const-qualified variables
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#cpp11">
         E.2.14. C++11 Features
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#lambda-expressions">
           E.2.14.1. Lambda Expressions
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#initializer-list">
           E.2.14.2. std::initializer_list
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#rvalue-references">
           E.2.14.3. Rvalue references
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#constexpr-functions">
           E.2.14.4. Constexpr functions and function templates
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#constexpr-variables">
           E.2.14.5. Constexpr variables
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#inline-namespaces">
           E.2.14.6. Inline namespaces
          </a>
         </div>
         <ul>
          <li>
           <div class="section-link" state="5">
            <a href="#inline-unnamed-namespaces">
             E.2.14.6.1. Inline unnamed namespaces
            </a>
           </div>
          </li>
         </ul>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#thread-local">
           E.2.14.7. thread_local
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#cpp11-global">
           E.2.14.8. __global__ functions and function templates
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#cpp11-device-variable">
           E.2.14.9. __device__/__constant__/__shared__ variables
          </a>
         </div>
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#polymorphic-function-wrappers">
       E.3. Polymorphic Function Wrappers
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#extended-lambda">
       E.4. Experimental Feature: Extended Lambdas
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#extended-lambda-traits">
         E.4.1. Extended Lambda Type Traits
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#extended-lambda-restrictions">
         E.4.2. Extended Lambda Restrictions
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#host-device-lambda-notes">
         E.4.3. Notes on __host__ __device__  lambdas
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#star-this-capture">
         E.4.4. *this Capture By Value
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#extended-lambda-notes">
         E.4.5. Additional Notes
        </a>
       </div>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#code-samples">
       E.5. Code Samples
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#data-aggregation-class">
         E.5.1. Data Aggregation Class
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#derived-class">
         E.5.2. Derived Class
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#class-template">
         E.5.3. Class Template
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#function-template">
         E.5.4. Function Template
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#functor-class">
         E.5.5. Functor Class
        </a>
       </div>
      </li>
     </ul>
    </li>
   </ul>
  </li>
  <li>
   <div class="section-link" state="1">
    <a href="#texture-fetching">
     F. Texture Fetching
    </a>
   </div>
   <ul>
    <li>
     <div class="section-link" state="2">
      <a href="#nearest-point-sampling">
       F.1. Nearest-Point Sampling
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#linear-filtering">
       F.2. Linear Filtering
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#table-lookup">
       F.3. Table Lookup
      </a>
     </div>
    </li>
   </ul>
  </li>
  <li>
   <div class="section-link" state="1">
    <a href="#compute-capabilities">
     G. Compute Capabilities
    </a>
   </div>
   <ul>
    <li>
     <div class="section-link" state="2">
      <a href="#features-and-technical-specifications">
       G.1. Features and Technical Specifications
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#floating-point-standard">
       G.2. Floating-Point Standard
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#compute-capability-2-x">
       G.3. Compute Capability 2.x
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#architecture-2-x">
         G.3.1. Architecture
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#global-memory-2-x">
         G.3.2. Global Memory
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#shared-memory-2-x">
         G.3.3. Shared Memory
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#constant-memory-2-x">
         G.3.4. Constant Memory
        </a>
       </div>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#compute-capability-3-0">
       G.4. Compute Capability 3.x
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#architecture-3-0">
         G.4.1. Architecture
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#global-memory-3-0">
         G.4.2. Global Memory
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#shared-memory-3-0">
         G.4.3. Shared Memory
        </a>
       </div>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#compute-capability-5-x">
       G.5. Compute Capability 5.x
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#architecture-5-x">
         G.5.1. Architecture
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#global-memory-5-x">
         G.5.2. Global Memory
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#shared-memory-5-x">
         G.5.3. Shared Memory
        </a>
       </div>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#compute-capability-6-x">
       G.6. Compute Capability 6.x
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#architecture-6-x">
         G.6.1. Architecture
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#global-memory-6-x">
         G.6.2. Global Memory
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#shared-memory-6-x">
         G.6.3. Shared Memory
        </a>
       </div>
      </li>
     </ul>
    </li>
   </ul>
  </li>
  <li>
   <div class="section-link" state="1">
    <a href="#driver-api">
     H. Driver API
    </a>
   </div>
   <ul>
    <li>
     <div class="section-link" state="2">
      <a href="#context">
       H.1. Context
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#module">
       H.2. Module
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#kernel-execution">
       H.3. Kernel Execution
      </a>
     </div>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#interoperability-between-runtime-and-driver-apis">
       H.4. Interoperability between Runtime and Driver APIs
      </a>
     </div>
    </li>
   </ul>
  </li>
  <li>
   <div class="section-link" state="1">
    <a href="#env-vars">
     I. CUDA Environment Variables
    </a>
   </div>
  </li>
  <li>
   <div class="section-link" state="1">
    <a href="#um-unified-memory-programming-hd">
     J. Unified Memory Programming
    </a>
   </div>
   <ul>
    <li>
     <div class="section-link" state="2">
      <a href="#um-introduction">
       J.1. Unified Memory Introduction
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#um-simplifying">
         J.1.1. Simplifying GPU Programming
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#um-data-migration">
         J.1.2. Data Migration and Coherency
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#um-oversubscription">
         J.1.3. GPU Memory Oversubscription
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#um-multi-gpu">
         J.1.4. Multi-GPU Support
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#um-requirements">
         J.1.5. System Requirements
        </a>
       </div>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#um-programming-model-hd">
       J.2. Programming Model
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#um-opt-in">
         J.2.1. Managed Memory Opt In
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#um-explicit-allocation">
           J.2.1.1. Explicit Allocation Using cudaMallocManaged()
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#um-global-scope">
           J.2.1.2. Global-Scope Managed Variables Using __managed__
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#um-coherency-hd">
         J.2.2. Coherency and Concurrency
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#um-gpu-exclusive">
           J.2.2.1. GPU Exclusive Access To Managed Memory
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#um-explicit-synchronization">
           J.2.2.2. Explicit Synchronization and Logical GPU Activity
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#um-managing-data">
           J.2.2.3. Managing Data Visibility and Concurrent CPU + GPU Access with Streams
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#um-stream-association">
           J.2.2.4. Stream Association Examples
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#um-stream-attach">
           J.2.2.5. Stream Attach With Multithreaded Host Programs
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#um-advanced-modular">
           J.2.2.6. Advanced Topic: Modular Programs and Data Access Constraints
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#um-memcpy-memset">
           J.2.2.7. Memcpy()/Memset() Behavior With Managed Memory
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#um-language-integration">
         J.2.3. Language Integration
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#um-host-program-errors">
           J.2.3.1. Host Program Errors with __managed__ Variables
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#um-querying-um-hd">
         J.2.4. Querying Unified Memory Support
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#um-device-properties">
           J.2.4.1. Device Properties
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#um-pointer-attributes">
           J.2.4.2. Pointer Attributes
          </a>
         </div>
        </li>
       </ul>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#um-advanced-topics-hd">
         J.2.5. Advanced Topics
        </a>
       </div>
       <ul>
        <li>
         <div class="section-link" state="4">
          <a href="#um-managed-memory">
           J.2.5.1. Managed Memory with Multi-GPU Programs on pre-6.x Architectures
          </a>
         </div>
        </li>
        <li>
         <div class="section-link" state="4">
          <a href="#um-fork-managed-memory">
           J.2.5.2. Using fork() with Managed Memory
          </a>
         </div>
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li>
     <div class="section-link" state="2">
      <a href="#um-performance-tuning">
       J.3. Performance Tuning
      </a>
     </div>
     <ul>
      <li>
       <div class="section-link" state="3">
        <a href="#um-tuning-prefetch">
         J.3.1. Data Prefetching
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#um-tuning-usage">
         J.3.2. Data Usage Hints
        </a>
       </div>
      </li>
      <li>
       <div class="section-link" state="3">
        <a href="#um-querying-usage">
         J.3.3. Querying Usage Attributes
        </a>
       </div>
      </li>
     </ul>
    </li>
   </ul>
  </li>
 </ul>
</nav>
 {% endblock %} 
{% block content %}
<div id="contents-container">
 <article id="contents">
  <div class="topic concept nested1" id="introduction" xml:lang="en-US">
   <a name="introduction" shape="rect">
   </a>
   <h2 class="title topictitle1">
    <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#introduction" name="introduction" shape="rect">
     1. Introduction
    </a>
   </h2>
   <div class="topic concept nested2" id="from-graphics-processing-to-general-purpose-parallel-computing" xml:lang="en-US">
    <a name="from-graphics-processing-to-general-purpose-parallel-computing" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#from-graphics-processing-to-general-purpose-parallel-computing" name="from-graphics-processing-to-general-purpose-parallel-computing" shape="rect">
      1.1. From Graphics Processing to General Purpose Parallel Computing
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       Driven by the insatiable market demand for realtime, high-definition 3D graphics, the programmable Graphic Processor Unit or GPU has evolved into a highly parallel, multithreaded, manycore processor with tremendous computational horsepower and very high memory bandwidth, as illustrated by Figure 1 and Figure 2.
      </li>
      <li class="li">
       The reason behind the discrepancy in floating-point capability between the CPU and the GPU is that the GPU is specialized for compute-intensive, highly parallel computation - exactly what graphics rendering is about - and therefore designed such that more transistors are devoted to data processing rather than data caching and flow control, as schematically illustrated by Figure 3.
      </li>
      <li class="li">
       More specifically, the GPU is especially well-suited to address problems that can be expressed as data-parallel computations - the same program is executed on many data elements in parallel - with high arithmetic intensity - the ratio of arithmetic operations to memory operations.
      </li>
      <li class="li">
       Because the same program is executed for each data element, there is a lower requirement for sophisticated flow control, and because it is executed on many data elements and has high arithmetic intensity, the memory access latency can be hidden with calculations instead of big data caches.
      </li>
      <li class="li">
       Data-parallel processing maps data elements to parallel processing threads.
      </li>
      <li class="li">
       Many applications that process large data sets can use a data-parallel programming model to speed up the computations.
      </li>
      <li class="li">
       In 3D rendering, large sets of pixels and vertices are mapped to parallel threads.
      </li>
      <li class="li">
       Similarly, image and media processing applications such as post-processing of rendered images, video encoding and decoding, image scaling, stereo vision, and pattern recognition can map image blocks and pixels to parallel processing threads.
      </li>
      <li class="li">
       In fact, many algorithms outside the field of image rendering and processing are accelerated by data-parallel processing, from general signal processing or physics simulation to computational finance or computational biology.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="cuda-general-purpose-parallel-computing-architecture" xml:lang="en-US">
    <a name="cuda-general-purpose-parallel-computing-architecture" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#cuda-general-purpose-parallel-computing-architecture" name="cuda-general-purpose-parallel-computing-architecture" shape="rect">
      1.2. CUDA®: A General-Purpose Parallel Computing
                           Platform and Programming Model
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       In November 2006, NVIDIA introduced CUDA®, a general purpose parallel computing platform and programming model that leverages the parallel compute engine in NVIDIA GPUs to solve many complex computational problems in a more efficient way than on a CPU.
      </li>
      <li class="li">
       CUDA comes with a software environment that allows developers to use C as a high-level programming language.
      </li>
      <li class="li">
       As illustrated by Figure 4, other languages, application programming interfaces, or directives-based approaches are supported, such as FORTRAN, DirectCompute, OpenACC.
      </li>
      <li class="li">
       .
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="scalable-programming-model" xml:lang="en-US">
    <a name="scalable-programming-model" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#scalable-programming-model" name="scalable-programming-model" shape="rect">
      1.3. A Scalable Programming Model
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       The advent of multicore CPUs and manycore GPUs means that mainstream processor chips are now parallel systems.
      </li>
      <li class="li">
       Furthermore, their parallelism continues to scale with Moore's law.
      </li>
      <li class="li">
       The challenge is to develop application software that transparently scales its parallelism to leverage the increasing number of processor cores, much as 3D graphics applications transparently scale their parallelism to manycore GPUs with widely varying numbers of cores.
      </li>
      <li class="li">
       The CUDA parallel programming model is designed to overcome this challenge while maintaining a low learning curve for programmers familiar with standard programming languages such as C. At its core are three key abstractions - a hierarchy of thread groups, shared memories, and barrier synchronization - that are simply exposed to the programmer as a minimal set of language extensions.
      </li>
      <li class="li">
       These abstractions provide fine-grained data parallelism and thread parallelism, nested within coarse-grained data parallelism and task parallelism.
      </li>
      <li class="li">
       They guide the programmer to partition the problem into coarse sub-problems that can be solved independently in parallel by blocks of threads, and each sub-problem into finer pieces that can be solved cooperatively in parallel by all threads within the block.
      </li>
      <li class="li">
       This decomposition preserves language expressivity by allowing threads to cooperate when solving each sub-problem, and at the same time enables automatic scalability.
      </li>
      <li class="li">
       Indeed, each block of threads can be scheduled on any of the available multiprocessors within a GPU, in any order, concurrently or sequentially, so that a compiled CUDA program can execute on any number of multiprocessors as illustrated by Figure 5, and only the runtime system needs to know the physical multiprocessor count.
      </li>
      <li class="li">
       This scalable programming model allows the GPU architecture to span a wide market range by simply scaling the number of multiprocessors and memory partitions: from the high-performance enthusiast GeForce GPUs and professional Quadro and Tesla computing products to a variety of inexpensive, mainstream GeForce GPUs (see CUDA-Enabled GPUs for a list of all CUDA-enabled GPUs).
      </li>
      <li class="li">
       A GPU is built around an array of Streaming Multiprocessors (SMs) (see Hardware Implementation for more details).
      </li>
      <li class="li">
       A multithreaded program is partitioned into blocks of threads that execute independently from each other, so that a GPU with more multiprocessors will automatically execute the program in less time than a GPU with fewer multiprocessors.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="document-structure" xml:lang="en-US">
    <a name="document-structure" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#document-structure" name="document-structure" shape="rect">
      1.4. Document Structure
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       This document is organized into the following chapters: Chapter Introduction is a general introduction to CUDA.
      </li>
      <li class="li">
       Chapter Programming Model outlines the CUDA programming model.
      </li>
      <li class="li">
       Chapter Programming Interface describes the programming interface.
      </li>
      <li class="li">
       Chapter Hardware Implementation describes the hardware implementation.
      </li>
      <li class="li">
       Chapter Performance Guidelines gives some guidance on how to achieve maximum performance.
      </li>
      <li class="li">
       Appendix CUDA-Enabled GPUs lists all CUDA-enabled devices.
      </li>
      <li class="li">
       Appendix C Language Extensions is a detailed description of all extensions to the C language.
      </li>
      <li class="li">
       Appendix Mathematical Functions lists the mathematical functions supported in CUDA.
      </li>
      <li class="li">
       Appendix C/C++ Language Support lists the C++ features supported in device code.
      </li>
      <li class="li">
       Appendix Texture Fetching gives more details on texture fetching Appendix Compute Capabilities gives the technical specifications of various devices, as well as more architectural details.
      </li>
      <li class="li">
       Appendix Driver API introduces the low-level driver API.
      </li>
      <li class="li">
       Appendix CUDA Environment Variables lists all the CUDA environment variables.
      </li>
     </ul>
    </div>
   </div>
  </div>
  <div class="topic concept nested1" id="programming-model" xml:lang="en-US">
   <a name="programming-model" shape="rect">
   </a>
   <h2 class="title topictitle1">
    <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#programming-model" name="programming-model" shape="rect">
     2. Programming Model
    </a>
   </h2>
   <div class="body conbody">
    <ul class="ul">
     <li class="li">
      This chapter introduces the main concepts behind the CUDA programming model by outlining how they are exposed in C. An extensive description of CUDA C is given in Programming Interface.
     </li>
     <li class="li">
      Full code for the vector addition example used in this chapter and the next can be found in the vectorAdd CUDA sample.
     </li>
    </ul>
   </div>
   <div class="topic concept nested2" id="kernels" xml:lang="en-US">
    <a name="kernels" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#kernels" name="kernels" shape="rect">
      2.1. Kernels
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       CUDA C extends C by allowing the programmer to define C functions, called kernels, that, when called, are executed N times in parallel by N different CUDA threads, as opposed to only once like regular C functions.
      </li>
      <li class="li">
       A kernel is defined using the __global__ declaration specifier and the number of CUDA threads that execute that kernel for a given kernel call is specified using a new &lt;&lt;&lt;...&gt;&gt;&gt;execution configuration syntax (see C Language Extensions).
      </li>
      <li class="li">
       Each thread that executes the kernel is given a unique thread ID that is accessible within the kernel through the built-in threadIdx variable.
      </li>
      <li class="li">
       As an illustration, the following sample code adds two vectors A and B of size N and stores the result into vector C: Here, each of the N threads that execute VecAdd() performs one pair-wise addition.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="thread-hierarchy" xml:lang="en-US">
    <a name="thread-hierarchy" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#thread-hierarchy" name="thread-hierarchy" shape="rect">
      2.2. Thread Hierarchy
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       For convenience, threadIdx is a 3-component vector, so that threads can be identified using a one-dimensional, two-dimensional, or three-dimensional thread index, forming a one-dimensional, two-dimensional, or three-dimensional block of threads, called a thread block.
      </li>
      <li class="li">
       This provides a natural way to invoke computation across the elements in a domain such as a vector, matrix, or volume.
      </li>
      <li class="li">
       The index of a thread and its thread ID relate to each other in a straightforward way: For a one-dimensional block, they are the same; for a two-dimensional block of size (Dx, Dy),the thread ID of a thread of index (x, y) is (x + y Dx); for a three-dimensional block of size (Dx, Dy, Dz), the thread ID of a thread of index (x, y, z) is (x + y Dx + z Dx Dy).
      </li>
      <li class="li">
       As an example, the following code adds two matrices A and B of size NxN and stores the result into matrix C: There is a limit to the number of threads per block, since all threads of a block are expected to reside on the same processor core and must share the limited memory resources of that core.
      </li>
      <li class="li">
       On current GPUs, a thread block may contain up to 1024 threads.
      </li>
      <li class="li">
       However, a kernel can be executed by multiple equally-shaped thread blocks, so that the total number of threads is equal to the number of threads per block times the number of blocks.
      </li>
      <li class="li">
       Blocks are organized into a one-dimensional, two-dimensional, or three-dimensional grid of thread blocks as illustrated by Figure 6.
      </li>
      <li class="li">
       The number of thread blocks in a grid is usually dictated by the size of the data being processed or the number of processors in the system, which it can greatly exceed.
      </li>
      <li class="li">
       The number of threads per block and the number of blocks per grid specified in the &lt;&lt;&lt;...&gt;&gt;&gt; syntax can be of type int or dim3.
      </li>
      <li class="li">
       Two-dimensional blocks or grids can be specified as in the example above.
      </li>
      <li class="li">
       Each block within the grid can be identified by a one-dimensional, two-dimensional, or three-dimensional index accessible within the kernel through the built-in blockIdx variable.
      </li>
      <li class="li">
       The dimension of the thread block is accessible within the kernel through the built-in blockDim variable.
      </li>
      <li class="li">
       Extending the previous MatAdd() example to handle multiple blocks, the code becomes as follows.
      </li>
      <li class="li">
       A thread block size of 16x16 (256 threads), although arbitrary in this case, is a common choice.
      </li>
      <li class="li">
       The grid is created with enough blocks to have one thread per matrix element as before.
      </li>
      <li class="li">
       For simplicity, this example assumes that the number of threads per grid in each dimension is evenly divisible by the number of threads per block in that dimension, although that need not be the case.
      </li>
      <li class="li">
       Thread blocks are required to execute independently: It must be possible to execute them in any order, in parallel or in series.
      </li>
      <li class="li">
       This independence requirement allows thread blocks to be scheduled in any order across any number of cores as illustrated by Figure 5, enabling programmers to write code that scales with the number of cores.
      </li>
      <li class="li">
       Threads within a block can cooperate by sharing data through some shared memory and by synchronizing their execution to coordinate memory accesses.
      </li>
      <li class="li">
       More precisely, one can specify synchronization points in the kernel by calling the __syncthreads() intrinsic function; __syncthreads() acts as a barrier at which all threads in the block must wait before any is allowed to proceed.
      </li>
      <li class="li">
       Shared Memory gives an example of using shared memory.
      </li>
      <li class="li">
       For efficient cooperation, the shared memory is expected to be a low-latency memory near each processor core (much like an L1 cache) and __syncthreads() is expected to be lightweight.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="memory-hierarchy" xml:lang="en-US">
    <a name="memory-hierarchy" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#memory-hierarchy" name="memory-hierarchy" shape="rect">
      2.3. Memory Hierarchy
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       CUDA threads may access data from multiple memory spaces during their execution as illustrated by Figure 7.
      </li>
      <li class="li">
       Each thread has private local memory.
      </li>
      <li class="li">
       Each thread block has shared memory visible to all threads of the block and with the same lifetime as the block.
      </li>
      <li class="li">
       All threads have access to the same global memory.
      </li>
      <li class="li">
       There are also two additional read-only memory spaces accessible by all threads: the constant and texture memory spaces.
      </li>
      <li class="li">
       The global, constant, and texture memory spaces are optimized for different memory usages (see Device Memory Accesses).
      </li>
      <li class="li">
       Texture memory also offers different addressing modes, as well as data filtering, for some specific data formats (see Texture and Surface Memory).
      </li>
      <li class="li">
       The global, constant, and texture memory spaces are persistent across kernel launches by the same application.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="heterogeneous-programming" xml:lang="en-US">
    <a name="heterogeneous-programming" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#heterogeneous-programming" name="heterogeneous-programming" shape="rect">
      2.4. Heterogeneous Programming
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       As illustrated by Figure 8, the CUDA programming model assumes that the CUDA threads execute on a physically separate device that operates as a coprocessor to the host running the C program.
      </li>
      <li class="li">
       This is the case, for example, when the kernels execute on a GPU and the rest of the C program executes on a CPU.
      </li>
      <li class="li">
       The CUDA programming model also assumes that both the host and the device maintain their own separate memory spaces in DRAM, referred to as host memory and device memory, respectively.
      </li>
      <li class="li">
       Therefore, a program manages the global, constant, and texture memory spaces visible to kernels through calls to the CUDA runtime (described in Programming Interface).
      </li>
      <li class="li">
       This includes device memory allocation and deallocation as well as data transfer between host and device memory.
      </li>
      <li class="li">
       Serial code executes on the host while parallel code executes on the device.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="compute-capability" xml:lang="en-US">
    <a name="compute-capability" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#compute-capability" name="compute-capability" shape="rect">
      2.5. Compute Capability
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       The compute capability of a device is represented by a version number, also sometimes called its "SM version".
      </li>
      <li class="li">
       This version number identifies the features supported by the GPU hardware and is used by applications at runtime to determine which hardware features and/or instructions are available on the present GPU.
      </li>
      <li class="li">
       The compute capability comprises a major revision number X and a minor revision number Y and is denoted by X.Y.
      </li>
      <li class="li">
       Devices with the same major revision number are of the same core architecture.
      </li>
      <li class="li">
       The major revision number is 5 for devices based on the Maxwell architecture, 3 for devices based on the Kepler architecture, 2 for devices based on the Fermi architecture, and 1 for devices based on the Tesla architecture.
      </li>
      <li class="li">
       The minor revision number corresponds to an incremental improvement to the core architecture, possibly including new features.
      </li>
      <li class="li">
       CUDA-Enabled GPUs lists of all CUDA-enabled devices along with their compute capability.
      </li>
      <li class="li">
       Compute Capabilities gives the technical specifications of each compute capability.
      </li>
      <li class="li">
       The compute capability version of a particular GPU should not be confused with the CUDA version (e.g., CUDA 5.5, CUDA 6, CUDA 6.5), which is the version of the CUDA software platform.
      </li>
      <li class="li">
       The CUDA platform is used by application developers to create applications that run on many generations of GPU architectures, including future GPU architectures yet to be invented.
      </li>
      <li class="li">
       While new versions of the CUDA platform often add native support for a new GPU architecture by supporting the compute capability version of that architecture, new versions of the CUDA platform typically also include software features that are independent of hardware generation.
      </li>
      <li class="li">
       The Tesla architecture is no longer supported starting with CUDA 7.0.
      </li>
     </ul>
    </div>
   </div>
  </div>
  <div class="topic concept nested1" id="programming-interface" xml:lang="en-US">
   <a name="programming-interface" shape="rect">
   </a>
   <h2 class="title topictitle1">
    <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#programming-interface" name="programming-interface" shape="rect">
     3. Programming Interface
    </a>
   </h2>
   <div class="body conbody">
    <ul class="ul">
     <li class="li">
      CUDA C provides a simple path for users familiar with the C programming language to easily write programs for execution by the device.
     </li>
     <li class="li">
      It consists of a minimal set of extensions to the C language and a runtime library.
     </li>
     <li class="li">
      The core language extensions have been introduced in Programming Model.
     </li>
     <li class="li">
      They allow programmers to define a kernel as a C function and use some new syntax to specify the grid and block dimension each time the function is called.
     </li>
     <li class="li">
      A complete description of all extensions can be found in C Language Extensions.
     </li>
     <li class="li">
      Any source file that contains some of these extensions must be compiled with nvcc as outlined in Compilation with NVCC.
     </li>
     <li class="li">
      The runtime is introduced in Compilation Workflow.
     </li>
     <li class="li">
      It provides C functions that execute on the host to allocate and deallocate device memory, transfer data between host memory and device memory, manage systems with multiple devices, etc.
     </li>
     <li class="li">
      A complete description of the runtime can be found in the CUDA reference manual.
     </li>
     <li class="li">
      The runtime is built on top of a lower-level C API, the CUDA driver API, which is also accessible by the application.
     </li>
     <li class="li">
      The driver API provides an additional level of control by exposing lower-level concepts such as CUDA contexts - the analogue of host processes for the device - and CUDA modules - the analogue of dynamically loaded libraries for the device.
     </li>
     <li class="li">
      Most applications do not use the driver API as they do not need this additional level of control and when using the runtime, context and module management are implicit, resulting in more concise code.
     </li>
     <li class="li">
      The driver API is introduced in Driver API and fully described in the reference manual.
     </li>
    </ul>
   </div>
   <div class="topic concept nested2" id="compilation-with-nvcc" xml:lang="en-US">
    <a name="compilation-with-nvcc" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#compilation-with-nvcc" name="compilation-with-nvcc" shape="rect">
      3.1. Compilation with NVCC
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       Kernels can be written using the CUDA instruction set architecture, called PTX, which is described in the PTX reference manual.
      </li>
      <li class="li">
       It is however usually more effective to use a high-level programming language such as C. In both cases, kernels must be compiled into binary code by nvcc to execute on the device.
      </li>
      <li class="li">
       nvcc is a compiler driver that simplifies the process of compiling C or PTX code: It provides simple and familiar command line options and executes them by invoking the collection of tools that implement the different compilation stages.
      </li>
      <li class="li">
       This section gives an overview of nvcc workflow and command options.
      </li>
      <li class="li">
       A complete description can be found in the nvcc user manual.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="compilation-workflow" xml:lang="en-US">
     <a name="compilation-workflow" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#compilation-workflow" name="compilation-workflow" shape="rect">
       3.1.1. Compilation Workflow
      </a>
     </h3>
     <div class="topic concept nested4" id="offline-compilation" xml:lang="en-US">
      <a name="offline-compilation" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#offline-compilation" name="offline-compilation" shape="rect">
        3.1.1.1. Offline Compilation
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Source files compiled with nvcc can include a mix of host code (i.e., code that executes on the host) and device code (i.e., code that executes on the device).
        </li>
        <li class="li">
         nvcc's basic workflow consists in separating device code from host code and then: compiling the device code into an assembly form (PTX code) and/or binary form (cubin object), and modifying the host code by replacing the &lt;&lt;&lt;...&gt;&gt;&gt; syntax introduced in Kernels (and described in more details in Execution Configuration) by the necessary CUDA C runtime function calls to load and launch each compiled kernel from the PTX code and/or cubin object.
        </li>
        <li class="li">
         The modified host code is output either as C code that is left to be compiled using another tool or as object code directly by letting nvcc invoke the host compiler during the last compilation stage.
        </li>
        <li class="li">
         Applications can then: Either link to the compiled host code (this is the most common case), Or ignore the modified host code (if any) and use the CUDA driver API (see Driver API) to load and execute the PTX code or cubin object.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="just-in-time-compilation" xml:lang="en-US">
      <a name="just-in-time-compilation" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#just-in-time-compilation" name="just-in-time-compilation" shape="rect">
        3.1.1.2. Just-in-Time Compilation
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Any PTX code loaded by an application at runtime is compiled further to binary code by the device driver.
        </li>
        <li class="li">
         This is called just-in-time compilation.
        </li>
        <li class="li">
         Just-in-time compilation increases application load time, but allows the application to benefit from any new compiler improvements coming with each new device driver.
        </li>
        <li class="li">
         It is also the only way for applications to run on devices that did not exist at the time the application was compiled, as detailed in Application Compatibility.
        </li>
        <li class="li">
         When the device driver just-in-time compiles some PTX code for some application, it automatically caches a copy of the generated binary code in order to avoid repeating the compilation in subsequent invocations of the application.
        </li>
        <li class="li">
         The cache - referred to as compute cache - is automatically invalidated when the device driver is upgraded, so that applications can benefit from the improvements in the new just-in-time compiler built into the device driver.
        </li>
        <li class="li">
         Environment variables are available to control just-in-time compilation as described in CUDA Environment Variables
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="binary-compatibility" xml:lang="en-US">
     <a name="binary-compatibility" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#binary-compatibility" name="binary-compatibility" shape="rect">
       3.1.2. Binary Compatibility
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Binary code is architecture-specific.
       </li>
       <li class="li">
        A cubin object is generated using the compiler option that specifies the targeted architecture: For example, compiling with produces binary code for devices of compute capability 3.5.
       </li>
       <li class="li">
        Binary compatibility is guaranteed from one minor revision to the next one, but not from one minor revision to the previous one or across major revisions.
       </li>
       <li class="li">
        In other words, a cubin object generated for compute capability X.y will only execute on devices of compute capability X.z where z≥y.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="ptx-compatibility" xml:lang="en-US">
     <a name="ptx-compatibility" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#ptx-compatibility" name="ptx-compatibility" shape="rect">
       3.1.3. PTX Compatibility
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Some PTX instructions are only supported on devices of higher compute capabilities.
       </li>
       <li class="li">
        For example, warp shuffle instructions are only supported on devices of compute capability 3.0 and above.
       </li>
       <li class="li">
        The compiler option specifies the compute capability that is assumed when compiling C to PTX code.
       </li>
       <li class="li">
        So, code that contains warp shuffle, for example, must be compiled with (or higher).
       </li>
       <li class="li">
        PTX code produced for some specific compute capability can always be compiled to binary code of greater or equal compute capability.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="application-compatibility" xml:lang="en-US">
     <a name="application-compatibility" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#application-compatibility" name="application-compatibility" shape="rect">
       3.1.4. Application Compatibility
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        To execute code on devices of specific compute capability, an application must load binary or PTX code that is compatible with this compute capability as described in Binary Compatibility and PTX Compatibility.
       </li>
       <li class="li">
        In particular, to be able to execute code on future architectures with higher compute capability (for which no binary code can be generated yet), an application must load PTX code that will be just-in-time compiled for these devices (see Just-in-Time Compilation).
       </li>
       <li class="li">
        Which PTX and binary code gets embedded in a CUDA C application is controlled by the -arch and compiler options or the compiler option as detailed in the nvcc user manual.
       </li>
       <li class="li">
        For example, embeds binary code compatible with compute capability 2.0 and 3.0 (first and second options) and PTX and binary code compatible with compute capability 3.5 (third option).
       </li>
       <li class="li">
        Host code is generated to automatically select at runtime the most appropriate code to load and execute, which, in the above example, will be: 2.0 binary code for devices with compute capability 2.0 and 2.1, 3.0 binary code for devices with compute capability 3.0, 3.5 binary code for devices with compute capability 3.5 and 3.7, PTX code which is compiled to binary code at runtime for devices with compute capability 5.0 and higher.
       </li>
       <li class="li">
        x.cu can have an optimized code path that uses warp shuffle operations, for example, which are only supported in devices of compute capability 3.0 and higher.
       </li>
       <li class="li">
        The __CUDA_ARCH__ macro can be used to differentiate various code paths based on compute capability.
       </li>
       <li class="li">
        It is only defined for device code.
       </li>
       <li class="li">
        When compiling with for example, __CUDA_ARCH__ is equal to 350.
       </li>
       <li class="li">
        Applications using the driver API must compile code to separate files and explicitly load and execute the most appropriate file at runtime.
       </li>
       <li class="li">
        The nvcc user manual lists various shorthand for the , , and compiler options.
       </li>
       <li class="li">
        For example, is a shorthand for (which is the same as ,).
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="c-cplusplus-compatibility" xml:lang="en-US">
     <a name="c-cplusplus-compatibility" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#c-cplusplus-compatibility" name="c-cplusplus-compatibility" shape="rect">
       3.1.5. C/C++ Compatibility
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The front end of the compiler processes CUDA source files according to C++ syntax rules.
       </li>
       <li class="li">
        Full C++ is supported for the host code.
       </li>
       <li class="li">
        However, only a subset of C++ is fully supported for the device code as described in C/C++ Language Support.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="sixtyfour-bit-compatibility" xml:lang="en-US">
     <a name="sixtyfour-bit-compatibility" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#sixtyfour-bit-compatibility" name="sixtyfour-bit-compatibility" shape="rect">
       3.1.6. 64-Bit Compatibility
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The 64-bit version of nvcc compiles device code in 64-bit mode (i.e., pointers are 64-bit).
       </li>
       <li class="li">
        Device code compiled in 64-bit mode is only supported with host code compiled in 64-bit mode.
       </li>
       <li class="li">
        Similarly, the 32-bit version of nvcc compiles device code in 32-bit mode and device code compiled in 32-bit mode is only supported with host code compiled in 32-bit mode.
       </li>
       <li class="li">
        The 32-bit version of nvcc can compile device code in 64-bit mode also using the compiler option.
       </li>
       <li class="li">
        The 64-bit version of nvcc can compile device code in 32-bit mode also using the compiler option.
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="cuda-c-runtime" xml:lang="en-US">
    <a name="cuda-c-runtime" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#cuda-c-runtime" name="cuda-c-runtime" shape="rect">
      3.2. CUDA C Runtime
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       The runtime is implemented in the cudart library, which is linked to the application, either statically via cudart.lib or libcudart.a, or dynamically via cudart.dll or libcudart.so.
      </li>
      <li class="li">
       Applications that require cudart.dll and/or cudart.so for dynamic linking typically include them as part of the application installation package.
      </li>
      <li class="li">
       All its entry points are prefixed with cuda.
      </li>
      <li class="li">
       As mentioned in Heterogeneous Programming, the CUDA programming model assumes a system composed of a host and a device, each with their own separate memory.
      </li>
      <li class="li">
       Device Memory gives an overview of the runtime functions used to manage device memory.
      </li>
      <li class="li">
       Shared Memory illustrates the use of shared memory, introduced in Thread Hierarchy, to maximize performance.
      </li>
      <li class="li">
       Page-Locked Host Memory introduces page-locked host memory that is required to overlap kernel execution with data transfers between host and device memory.
      </li>
      <li class="li">
       Asynchronous Concurrent Execution describes the concepts and API used to enable asynchronous concurrent execution at various levels in the system.
      </li>
      <li class="li">
       Multi-Device System shows how the programming model extends to a system with multiple devices attached to the same host.
      </li>
      <li class="li">
       Error Checking describes how to properly check the errors generated by the runtime.
      </li>
      <li class="li">
       Call Stack mentions the runtime functions used to manage the CUDA C call stack.
      </li>
      <li class="li">
       Texture and Surface Memory presents the texture and surface memory spaces that provide another way to access device memory; they also expose a subset of the GPU texturing hardware.
      </li>
      <li class="li">
       Graphics Interoperability introduces the various functions the runtime provides to interoperate with the two main graphics APIs, OpenGL and Direct3D.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="initialization" xml:lang="en-US">
     <a name="initialization" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#initialization" name="initialization" shape="rect">
       3.2.1. Initialization
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        There is no explicit initialization function for the runtime; it initializes the first time a runtime function is called (more specifically any function other than functions from the device and version management sections of the reference manual).
       </li>
       <li class="li">
        One needs to keep this in mind when timing runtime function calls and when interpreting the error code from the first call into the runtime.
       </li>
       <li class="li">
        During initialization, the runtime creates a CUDA context for each device in the system (see Context for more details on CUDA contexts).
       </li>
       <li class="li">
        This context is the primary context for this device and it is shared among all the host threads of the application.
       </li>
       <li class="li">
        As part of this context creation, the device code is just-in-time compiled if necessary (see Just-in-Time Compilation) and loaded into device memory.
       </li>
       <li class="li">
        This all happens under the hood and the runtime does not expose the primary context to the application.
       </li>
       <li class="li">
        When a host thread calls cudaDeviceReset(), this destroys the primary context of the device the host thread currently operates on (i.e., the current device as defined in Device Selection).
       </li>
       <li class="li">
        The next runtime function call made by any host thread that has this device as current will create a new primary context for this device.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="device-memory" xml:lang="en-US">
     <a name="device-memory" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#device-memory" name="device-memory" shape="rect">
       3.2.2. Device Memory
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        As mentioned in Heterogeneous Programming, the CUDA programming model assumes a system composed of a host and a device, each with their own separate memory.
       </li>
       <li class="li">
        Kernels operate out of device memory, so the runtime provides functions to allocate, deallocate, and copy device memory, as well as transfer data between host memory and device memory.
       </li>
       <li class="li">
        Device memory can be allocated either as linear memory or as CUDA arrays.
       </li>
       <li class="li">
        CUDA arrays are opaque memory layouts optimized for texture fetching.
       </li>
       <li class="li">
        They are described in Texture and Surface Memory.
       </li>
       <li class="li">
        Linear memory exists on the device in a 40-bit address space, so separately allocated entities can reference one another via pointers, for example, in a binary tree.
       </li>
       <li class="li">
        Linear memory is typically allocated using cudaMalloc() and freed using cudaFree() and data transfer between host memory and device memory are typically done using cudaMemcpy().
       </li>
       <li class="li">
        In the vector addition code sample of Kernels, the vectors need to be copied from host memory to device memory: Linear memory can also be allocated through cudaMallocPitch() and cudaMalloc3D().
       </li>
       <li class="li">
        These functions are recommended for allocations of 2D or 3D arrays as it makes sure that the allocation is appropriately padded to meet the alignment requirements described in Device Memory Accesses, therefore ensuring best performance when accessing the row addresses or performing copies between 2D arrays and other regions of device memory (using the cudaMemcpy2D() and cudaMemcpy3D() functions).
       </li>
       <li class="li">
        The returned pitch (or stride) must be used to access array elements.
       </li>
       <li class="li">
        The following code sample allocates a width x height 2D array of floating-point values and shows how to loop over the array elements in device code: The following code sample allocates a width x height x depth 3D array of floating-point values and shows how to loop over the array elements in device code: The reference manual lists all the various functions used to copy memory between linear memory allocated with cudaMalloc(), linear memory allocated with cudaMallocPitch() or cudaMalloc3D(), CUDA arrays, and memory allocated for variables declared in global or constant memory space.
       </li>
       <li class="li">
        The following code sample illustrates various ways of accessing global variables via the runtime API: cudaGetSymbolAddress() is used to retrieve the address pointing to the memory allocated for a variable declared in global memory space.
       </li>
       <li class="li">
        The size of the allocated memory is obtained through cudaGetSymbolSize().
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="shared-memory" xml:lang="en-US">
     <a name="shared-memory" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#shared-memory" name="shared-memory" shape="rect">
       3.2.3. Shared Memory
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        As detailed in Variable Type Qualifiers shared memory is allocated using the __shared__ qualifier.
       </li>
       <li class="li">
        Shared memory is expected to be much faster than global memory as mentioned in Thread Hierarchy and detailed in Shared Memory.
       </li>
       <li class="li">
        Any opportunity to replace global memory accesses by shared memory accesses should therefore be exploited as illustrated by the following matrix multiplication example.
       </li>
       <li class="li">
        The following code sample is a straightforward implementation of matrix multiplication that does not take advantage of shared memory.
       </li>
       <li class="li">
        Each thread reads one row of A and one column of B and computes the corresponding element of C as illustrated in Figure 9.
       </li>
       <li class="li">
        A is therefore read B.width times from global memory and B is read A.height times.
       </li>
       <li class="li">
        The following code sample is an implementation of matrix multiplication that does take advantage of shared memory.
       </li>
       <li class="li">
        In this implementation, each thread block is responsible for computing one square sub-matrix Csub of C and each thread within the block is responsible for computing one element of Csub.
       </li>
       <li class="li">
        As illustrated in Figure 10, Csub is equal to the product of two rectangular matrices: the sub-matrix of A of dimension (A.width, block_size) that has the same row indices as Csub, and the sub-matrix of B of dimension (block_size, A.width )that has the same column indices as Csub.
       </li>
       <li class="li">
        In order to fit into the device's resources, these two rectangular matrices are divided into as many square matrices of dimension block_size as necessary and Csub is computed as the sum of the products of these square matrices.
       </li>
       <li class="li">
        Each of these products is performed by first loading the two corresponding square matrices from global memory to shared memory with one thread loading one element of each matrix, and then by having each thread compute one element of the product.
       </li>
       <li class="li">
        Each thread accumulates the result of each of these products into a register and once done writes the result to global memory.
       </li>
       <li class="li">
        By blocking the computation this way, we take advantage of fast shared memory and save a lot of global memory bandwidth since A is only read (B.width / block_size) times from global memory and B is read (A.height / block_size) times.
       </li>
       <li class="li">
        The Matrix type from the previous code sample is augmented with a stride field, so that sub-matrices can be efficiently represented with the same type.
       </li>
       <li class="li">
        __device__ functions are used to get and set elements and build any sub-matrix from a matrix.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="page-locked-host-memory" xml:lang="en-US">
     <a name="page-locked-host-memory" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#page-locked-host-memory" name="page-locked-host-memory" shape="rect">
       3.2.4. Page-Locked Host Memory
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The runtime provides functions to allow the use of page-locked (also known as pinned) host memory (as opposed to regular pageable host memory allocated by malloc()): cudaHostAlloc() and cudaFreeHost() allocate and free page-locked host memory; cudaHostRegister() page-locks a range of memory allocated by malloc() (see reference manual for limitations).
       </li>
       <li class="li">
        Using page-locked host memory has several benefits: Copies between page-locked host memory and device memory can be performed concurrently with kernel execution for some devices as mentioned in Asynchronous Concurrent Execution.
       </li>
       <li class="li">
        On some devices, page-locked host memory can be mapped into the address space of the device, eliminating the need to copy it to or from device memory as detailed in Mapped Memory.
       </li>
       <li class="li">
        On systems with a front-side bus, bandwidth between host memory and device memory is higher if host memory is allocated as page-locked and even higher if in addition it is allocated as write-combining as described in Write-Combining Memory.
       </li>
       <li class="li">
        Page-locked host memory is a scarce resource however, so allocations in page-locked memory will start failing long before allocations in pageable memory.
       </li>
       <li class="li">
        In addition, by reducing the amount of physical memory available to the operating system for paging, consuming too much page-locked memory reduces overall system performance.
       </li>
       <li class="li">
        The simple zero-copy CUDA sample comes with a detailed document on the page-locked memory APIs.
       </li>
      </ul>
     </div>
     <div class="topic concept nested4" id="portable-memory" xml:lang="en-US">
      <a name="portable-memory" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#portable-memory" name="portable-memory" shape="rect">
        3.2.4.1. Portable Memory
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         A block of page-locked memory can be used in conjunction with any device in the system (see Multi-Device System for more details on multi-device systems), but by default, the benefits of using page-locked memory described above are only available in conjunction with the device that was current when the block was allocated (and with all devices sharing the same unified address space, if any, as described in Unified Virtual Address Space).
        </li>
        <li class="li">
         To make these advantages available to all devices, the block needs to be allocated by passing the flag cudaHostAllocPortable to cudaHostAlloc() or page-locked by passing the flag cudaHostRegisterPortable to cudaHostRegister().
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="write-combining-memory" xml:lang="en-US">
      <a name="write-combining-memory" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#write-combining-memory" name="write-combining-memory" shape="rect">
        3.2.4.2. Write-Combining Memory
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         By default page-locked host memory is allocated as cacheable.
        </li>
        <li class="li">
         It can optionally be allocated as write-combining instead by passing flag cudaHostAllocWriteCombined to cudaHostAlloc().
        </li>
        <li class="li">
         Write-combining memory frees up the host's L1 and L2 cache resources, making more cache available to the rest of the application.
        </li>
        <li class="li">
         In addition, write-combining memory is not snooped during transfers across the PCI Express bus, which can improve transfer performance by up to 40%.
        </li>
        <li class="li">
         Reading from write-combining memory from the host is prohibitively slow, so write-combining memory should in general be used for memory that the host only writes to.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="mapped-memory" xml:lang="en-US">
      <a name="mapped-memory" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#mapped-memory" name="mapped-memory" shape="rect">
        3.2.4.3. Mapped Memory
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         A block of page-locked host memory can also be mapped into the address space of the device by passing flag cudaHostAllocMapped to cudaHostAlloc() or by passing flag cudaHostRegisterMapped to cudaHostRegister().
        </li>
        <li class="li">
         Such a block has therefore in general two addresses: one in host memory that is returned by cudaHostAlloc() or malloc(), and one in device memory that can be retrieved using cudaHostGetDevicePointer() and then used to access the block from within a kernel.
        </li>
        <li class="li">
         The only exception is for pointers allocated with cudaHostAlloc() and when a unified address space is used for the host and the device as mentioned in Unified Virtual Address Space.
        </li>
        <li class="li">
         Accessing host memory directly from within a kernel has several advantages: There is no need to allocate a block in device memory and copy data between this block and the block in host memory; data transfers are implicitly performed as needed by the kernel; There is no need to use streams (see Concurrent Data Transfers) to overlap data transfers with kernel execution; the kernel-originated data transfers automatically overlap with kernel execution.
        </li>
        <li class="li">
         Since mapped page-locked memory is shared between host and device however, the application must synchronize memory accesses using streams or events (see Asynchronous Concurrent Execution) to avoid any potential read-after-write, write-after-read, or write-after-write hazards.
        </li>
        <li class="li">
         To be able to retrieve the device pointer to any mapped page-locked memory, page-locked memory mapping must be enabled by calling cudaSetDeviceFlags() with the cudaDeviceMapHost flag before any other CUDA call is performed.
        </li>
        <li class="li">
         Otherwise, cudaHostGetDevicePointer() will return an error.
        </li>
        <li class="li">
         cudaHostGetDevicePointer() also returns an error if the device does not support mapped page-locked host memory.
        </li>
        <li class="li">
         Applications may query this capability by checking the canMapHostMemory device property (see Device Enumeration), which is equal to 1 for devices that support mapped page-locked host memory.
        </li>
        <li class="li">
         Note that atomic functions (see Atomic Functions) operating on mapped page-locked memory are not atomic from the point of view of the host or other devices.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="asynchronous-concurrent-execution" xml:lang="en-US">
     <a name="asynchronous-concurrent-execution" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#asynchronous-concurrent-execution" name="asynchronous-concurrent-execution" shape="rect">
       3.2.5. Asynchronous Concurrent Execution
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        CUDA exposes the following operations as independent tasks that can operate concurrently with one another: Computation on the host; Computation on the device; Memory transfers from the host to the device; Memory transfers from the device to the host; Memory transfers within the memory of a given device; Memory transfers among devices.
       </li>
       <li class="li">
        The level of concurrency achieved between these operations will depend on the feature set and compute capability of the device as described below.
       </li>
      </ul>
     </div>
     <div class="topic concept nested4" id="concurrent-execution-host-device" xml:lang="en-US">
      <a name="concurrent-execution-host-device" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#concurrent-execution-host-device" name="concurrent-execution-host-device" shape="rect">
        3.2.5.1. Concurrent Execution between Host and Device
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Concurrent host execution is facilitated through asynchronous library functions that return control to the host thread before the device completes the requested task.
        </li>
        <li class="li">
         Using asynchronous calls, many device operations can be queued up together to be executed by the CUDA driver when appropriate device resources are available.
        </li>
        <li class="li">
         This relieves the host thread of much of the responsibility to manage the device, leaving it free for other tasks.
        </li>
        <li class="li">
         The following device operations are asynchronous with respect to the host: Kernel launches; Memory copies within a single device's memory; Memory copies from host to device of a memory block of 64 KB or less; Memory copies performed by functions that are suffixed with Async; Memory set function calls.
        </li>
        <li class="li">
         Programmers can globally disable asynchronicity of kernel launches for all CUDA applications running on a system by setting the CUDA_LAUNCH_BLOCKING environment variable to 1.
        </li>
        <li class="li">
         This feature is provided for debugging purposes only and should not be used as a way to make production software run reliably.
        </li>
        <li class="li">
         Kernel launches are synchronous if hardware counters are collected via a profiler (Nsight, Visual Profiler) unless concurrent kernel profiling is enabled.
        </li>
        <li class="li">
         Async memory copies will also be synchronous if they involve host memory that is not page-locked.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="concurrent-kernel-execution" xml:lang="en-US">
      <a name="concurrent-kernel-execution" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#concurrent-kernel-execution" name="concurrent-kernel-execution" shape="rect">
        3.2.5.2. Concurrent Kernel Execution
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Some devices of compute capability 2.x and higher can execute multiple kernels concurrently.
        </li>
        <li class="li">
         Applications may query this capability by checking the concurrentKernels device property (see Device Enumeration), which is equal to 1 for devices that support it.
        </li>
        <li class="li">
         The maximum number of kernel launches that a device can execute concurrently depends on its compute capability and is listed in Table 13.
        </li>
        <li class="li">
         A kernel from one CUDA context cannot execute concurrently with a kernel from another CUDA context.
        </li>
        <li class="li">
         Kernels that use many textures or a large amount of local memory are less likely to execute concurrently with other kernels.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="overlap-of-data-transfer-and-kernel-execution" xml:lang="en-US">
      <a name="overlap-of-data-transfer-and-kernel-execution" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#overlap-of-data-transfer-and-kernel-execution" name="overlap-of-data-transfer-and-kernel-execution" shape="rect">
        3.2.5.3. Overlap of Data Transfer and Kernel Execution
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Some devices can perform an asynchronous memory copy to or from the GPU concurrently with kernel execution.
        </li>
        <li class="li">
         Applications may query this capability by checking the asyncEngineCount device property (see Device Enumeration), which is greater than zero for devices that support it.
        </li>
        <li class="li">
         If host memory is involved in the copy, it must be page-locked.
        </li>
        <li class="li">
         It is also possible to perform an intra-device copy simultaneously with kernel execution (on devices that support the concurrentKernels device property) and/or with copies to or from the device (for devices that support the asyncEngineCount property).
        </li>
        <li class="li">
         Intra-device copies are initiated using the standard memory copy functions with destination and source addresses residing on the same device.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="concurrent-data-transfers" xml:lang="en-US">
      <a name="concurrent-data-transfers" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#concurrent-data-transfers" name="concurrent-data-transfers" shape="rect">
        3.2.5.4. Concurrent Data Transfers
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Some devices of compute capability 2.x and higher can overlap copies to and from the device.
        </li>
        <li class="li">
         Applications may query this capability by checking the asyncEngineCount device property (see Device Enumeration), which is equal to 2 for devices that support it.
        </li>
        <li class="li">
         In order to be overlapped, any host memory involved in the transfers must be page-locked.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="streams" xml:lang="en-US">
      <a name="streams" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#streams" name="streams" shape="rect">
        3.2.5.5. Streams
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Applications manage the concurrent operations described above through streams.
        </li>
        <li class="li">
         A stream is a sequence of commands (possibly issued by different host threads) that execute in order.
        </li>
        <li class="li">
         Different streams, on the other hand, may execute their commands out of order with respect to one another or concurrently; this behavior is not guaranteed and should therefore not be relied upon for correctness (e.g., inter-kernel communication is undefined).
        </li>
       </ul>
      </div>
      <div class="topic concept nested5" id="creation-and-destruction-streams" xml:lang="en-US">
       <a name="creation-and-destruction-streams" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#creation-and-destruction-streams" name="creation-and-destruction-streams" shape="rect">
         3.2.5.5.1. Creation and Destruction
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          A stream is defined by creating a stream object and specifying it as the stream parameter to a sequence of kernel launches and host &lt;-&gt; device memory copies.
         </li>
         <li class="li">
          The following code sample creates two streams and allocates an array hostPtr of float in page-locked memory.
         </li>
         <li class="li">
          Each of these streams is defined by the following code sample as a sequence of one memory copy from host to device, one kernel launch, and one memory copy from device to host: Each stream copies its portion of input array hostPtr to array inputDevPtr in device memory, processes inputDevPtr on the device by calling MyKernel(), and copies the result outputDevPtr back to the same portion of hostPtr.
         </li>
         <li class="li">
          Overlapping Behavior describes how the streams overlap in this example depending on the capability of the device.
         </li>
         <li class="li">
          Note that hostPtr must point to page-locked host memory for any overlap to occur.
         </li>
         <li class="li">
          Streams are released by calling cudaStreamDestroy().
         </li>
         <li class="li">
          cudaStreamDestroy() waits for all preceding commands in the given stream to complete before destroying the stream and returning control to the host thread.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="default-stream" xml:lang="en-US">
       <a name="default-stream" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#default-stream" name="default-stream" shape="rect">
         3.2.5.5.2. Default Stream
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          Kernel launches and host &lt;-&gt; device memory copies that do not specify any stream parameter, or equivalently that set the stream parameter to zero, are issued to the default stream.
         </li>
         <li class="li">
          They are therefore executed in order.
         </li>
         <li class="li">
          For code that is compiled using the --default-stream per-thread compilation flag (or that defines the CUDA_API_PER_THREAD_DEFAULT_STREAM macro before including CUDA headers (cuda.h and cuda_runtime.h)), the default stream is a regular stream and each host thread has its own default stream.
         </li>
         <li class="li">
          For code that is compiled using the --default-stream legacy compilation flag, the default stream is a special stream called the NULL stream and each device has a single NULL stream used for all host threads.
         </li>
         <li class="li">
          The NULL stream is special as it causes implicit synchronization as described in Implicit Synchronization.
         </li>
         <li class="li">
          For code that is compiled without specifying a --default-stream compilation flag, --default-stream legacy is assumed as the default.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="explicit-synchronization" xml:lang="en-US">
       <a name="explicit-synchronization" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#explicit-synchronization" name="explicit-synchronization" shape="rect">
         3.2.5.5.3. Explicit Synchronization
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          There are various ways to explicitly synchronize streams with each other.
         </li>
         <li class="li">
          cudaDeviceSynchronize() waits until all preceding commands in all streams of all host threads have completed.
         </li>
         <li class="li">
          cudaStreamSynchronize()takes a stream as a parameter and waits until all preceding commands in the given stream have completed.
         </li>
         <li class="li">
          It can be used to synchronize the host with a specific stream, allowing other streams to continue executing on the device.
         </li>
         <li class="li">
          cudaStreamWaitEvent()takes a stream and an event as parameters (see Events for a description of events)and makes all the commands added to the given stream after the call to cudaStreamWaitEvent()delay their execution until the given event has completed.
         </li>
         <li class="li">
          The stream can be 0, in which case all the commands added to any stream after the call to cudaStreamWaitEvent()wait on the event.
         </li>
         <li class="li">
          cudaStreamQuery()provides applications with a way to know if all preceding commands in a stream have completed.
         </li>
         <li class="li">
          To avoid unnecessary slowdowns, all these synchronization functions are usually best used for timing purposes or to isolate a launch or memory copy that is failing.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="implicit-synchronization" xml:lang="en-US">
       <a name="implicit-synchronization" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#implicit-synchronization" name="implicit-synchronization" shape="rect">
         3.2.5.5.4. Implicit Synchronization
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          Two commands from different streams cannot run concurrently if any one of the following operations is issued in-between them by the host thread: a page-locked host memory allocation, a device memory allocation, a device memory set, a memory copy between two addresses to the same device memory, any CUDA command to the NULL stream, a switch between the L1/shared memory configurations described in Compute Capability 2.x and Compute Capability 3.x.
         </li>
         <li class="li">
          For devices that support concurrent kernel execution and are of compute capability 3.0 or lower, any operation that requires a dependency check to see if a streamed kernel launch is complete: Can start executing only when all thread blocks of all prior kernel launches from any stream in the CUDA context have started executing; Blocks all later kernel launches from any stream in the CUDA context until the kernel launch being checked is complete.
         </li>
         <li class="li">
          Operations that require a dependency check include any other commands within the same stream as the launch being checked and any call to cudaStreamQuery() on that stream.
         </li>
         <li class="li">
          Therefore, applications should follow these guidelines to improve their potential for concurrent kernel execution: All independent operations should be issued before dependent operations, Synchronization of any kind should be delayed as long as possible.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="overlapping-behavior" xml:lang="en-US">
       <a name="overlapping-behavior" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#overlapping-behavior" name="overlapping-behavior" shape="rect">
         3.2.5.5.5. Overlapping Behavior
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          The amount of execution overlap between two streams depends on the order in which the commands are issued to each stream and whether or not the device supports overlap of data transfer and kernel execution (see Overlap of Data Transfer and Kernel Execution), concurrent kernel execution (see Concurrent Kernel Execution), and/or concurrent data transfers (see Concurrent Data Transfers).
         </li>
         <li class="li">
          For example, on devices that do not support concurrent data transfers, the two streams of the code sample of Creation and Destruction do not overlap at all because the memory copy from host to device is issued to stream[1] after the memory copy from device to host is issued to stream[0], so it can only start once the memory copy from device to host issued to stream[0] has completed.
         </li>
         <li class="li">
          If the code is rewritten the following way (and assuming the device supports overlap of data transfer and kernel execution) then the memory copy from host to device issued to stream[1] overlaps with the kernel launch issued to stream[0].
         </li>
         <li class="li">
          On devices that do support concurrent data transfers, the two streams of the code sample of Creation and Destruction do overlap: The memory copy from host to device issued to stream[1] overlaps with the memory copy from device to host issued to stream[0] and even with the kernel launch issued to stream[0] (assuming the device supports overlap of data transfer and kernel execution).
         </li>
         <li class="li">
          However, for devices of compute capability 3.0 or lower, the kernel executions cannot possibly overlap because the second kernel launch is issued to stream[1] after the memory copy from device to host is issued to stream[0], so it is blocked until the first kernel launch issued to stream[0] is complete as per Implicit Synchronization.
         </li>
         <li class="li">
          If the code is rewritten as above, the kernel executions overlap (assuming the device supports concurrent kernel execution) since the second kernel launch is issued to stream[1] before the memory copy from device to host is issued to stream[0].
         </li>
         <li class="li">
          In that case however, the memory copy from device to host issued to stream[0] only overlaps with the last thread blocks of the kernel launch issued to stream[1] as per Implicit Synchronization, which can represent only a small portion of the total execution time of the kernel.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="stream-callbacks" xml:lang="en-US">
       <a name="stream-callbacks" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#stream-callbacks" name="stream-callbacks" shape="rect">
         3.2.5.5.6. Callbacks
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          The runtime provides a way to insert a callback at any point into a stream via cudaStreamAddCallback().
         </li>
         <li class="li">
          A callback is a function that is executed on the host once all commands issued to the stream before the callback have completed.
         </li>
         <li class="li">
          Callbacks in stream 0 are executed once all preceding tasks and commands issued in all streams before the callback have completed.
         </li>
         <li class="li">
          The following code sample adds the callback function MyCallback to each of two streams after issuing a host-to-device memory copy, a kernel launch and a device-to-host memory copy into each stream.
         </li>
         <li class="li">
          The callback will begin execution on the host after each of the device-to-host memory copies completes.
         </li>
         <li class="li">
          The commands that are issued in a stream (or all commands issued to any stream if the callback is issued to stream 0) after a callback do not start executing before the callback has completed.
         </li>
         <li class="li">
          The last parameter of cudaStreamAddCallback() is reserved for future use.
         </li>
         <li class="li">
          A callback must not make CUDA API calls (directly or indirectly), as it might end up waiting on itself if it makes such a call leading to a deadlock.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="stream-priorities" xml:lang="en-US">
       <a name="stream-priorities" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#stream-priorities" name="stream-priorities" shape="rect">
         3.2.5.5.7. Stream Priorities
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          The relative priorities of streams can be specified at creation using cudaStreamCreateWithPriority().
         </li>
         <li class="li">
          The range of allowable priorities, ordered as [ highest priority, lowest priority ] can be obtained using the cudaDeviceGetStreamPriorityRange() function.
         </li>
         <li class="li">
          At runtime, as blocks in low-priority schemes finish, waiting blocks in higher-priority streams are scheduled in their place.
         </li>
         <li class="li">
          The following code sample obtains the allowable range of priorities for the current device, and creates streams with the highest and lowest available priorities
         </li>
        </ul>
       </div>
      </div>
     </div>
     <div class="topic concept nested4" id="events" xml:lang="en-US">
      <a name="events" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#events" name="events" shape="rect">
        3.2.5.6. Events
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The runtime also provides a way to closely monitor the device's progress, as well as perform accurate timing, by letting the application asynchronously record events at any point in the program and query when these events are completed.
        </li>
        <li class="li">
         An event has completed when all tasks - or optionally, all commands in a given stream - preceding the event have completed.
        </li>
        <li class="li">
         Events in stream zero are completed after all preceding tasks and commands in all streams are completed.
        </li>
       </ul>
      </div>
      <div class="topic concept nested5" id="creation-and-destruction-events" xml:lang="en-US">
       <a name="creation-and-destruction-events" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#creation-and-destruction-events" name="creation-and-destruction-events" shape="rect">
         3.2.5.6.1. Creation and Destruction
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          The following code sample creates two events:They are destroyed this way:
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="elapsed-time" xml:lang="en-US">
       <a name="elapsed-time" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#elapsed-time" name="elapsed-time" shape="rect">
         3.2.5.6.2. Elapsed Time
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          The events created in Creation and Destruction can be used to time the code sample of Creation and Destruction the following way:
         </li>
        </ul>
       </div>
      </div>
     </div>
     <div class="topic concept nested4" id="synchronous-calls" xml:lang="en-US">
      <a name="synchronous-calls" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#synchronous-calls" name="synchronous-calls" shape="rect">
        3.2.5.7. Synchronous Calls
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         When a synchronous function is called, control is not returned to the host thread before the device has completed the requested task.
        </li>
        <li class="li">
         Whether the host thread will then yield, block, or spin can be specified by calling cudaSetDeviceFlags()with some specific flags (see reference manual for details) before any other CUDA call is performed by the host thread.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="multi-device-system" xml:lang="en-US">
     <a name="multi-device-system" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#multi-device-system" name="multi-device-system" shape="rect">
       3.2.6. Multi-Device System
      </a>
     </h3>
     <div class="topic concept nested4" id="device-enumeration" xml:lang="en-US">
      <a name="device-enumeration" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#device-enumeration" name="device-enumeration" shape="rect">
        3.2.6.1. Device Enumeration
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         A host system can have multiple devices.
        </li>
        <li class="li">
         The following code sample shows how to enumerate these devices, query their properties, and determine the number of CUDA-enabled devices.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="device-selection" xml:lang="en-US">
      <a name="device-selection" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#device-selection" name="device-selection" shape="rect">
        3.2.6.2. Device Selection
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         A host thread can set the device it operates on at any time by calling cudaSetDevice().
        </li>
        <li class="li">
         Device memory allocations and kernel launches are made on the currently set device; streams and events are created in association with the currently set device.
        </li>
        <li class="li">
         If no call to cudaSetDevice() is made, the current device is device 0.
        </li>
        <li class="li">
         The following code sample illustrates how setting the current device affects memory allocation and kernel execution.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="stream-and-event-behavior" xml:lang="en-US">
      <a name="stream-and-event-behavior" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#stream-and-event-behavior" name="stream-and-event-behavior" shape="rect">
        3.2.6.3. Stream and Event Behavior
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         A kernel launch will fail if it is issued to a stream that is not associated to the current device as illustrated in the following code sample.
        </li>
        <li class="li">
         A memory copy will succeed even if it is issued to a stream that is not associated to the current device.
        </li>
        <li class="li">
         cudaEventRecord() will fail if the input event and input stream are associated to different devices.
        </li>
        <li class="li">
         cudaEventElapsedTime() will fail if the two input events are associated to different devices.
        </li>
        <li class="li">
         cudaEventSynchronize() and cudaEventQuery() will succeed even if the input event is associated to a device that is different from the current device.
        </li>
        <li class="li">
         cudaStreamWaitEvent() will succeed even if the input stream and input event are associated to different devices.
        </li>
        <li class="li">
         cudaStreamWaitEvent() can therefore be used to synchronize multiple devices with each other.
        </li>
        <li class="li">
         Each device has its own default stream (see Default Stream), so commands issued to the default stream of a device may execute out of order or concurrently with respect to commands issued to the default stream of any other device.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="peer-to-peer-memory-access" xml:lang="en-US">
      <a name="peer-to-peer-memory-access" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#peer-to-peer-memory-access" name="peer-to-peer-memory-access" shape="rect">
        3.2.6.4. Peer-to-Peer Memory Access
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         When the application is run as a 64-bit process, devices of compute capability 2.0 and higher from the Tesla series may address each other's memory (i.e., a kernel executing on one device can dereference a pointer to the memory of the other device).
        </li>
        <li class="li">
         This peer-to-peer memory access feature is supported between two devices if cudaDeviceCanAccessPeer() returns true for these two devices.
        </li>
        <li class="li">
         Peer-to-peer memory access must be enabled between two devices by calling cudaDeviceEnablePeerAccess() as illustrated in the following code sample.
        </li>
        <li class="li">
         Each device can support a system-wide maximum of eight peer connections.
        </li>
        <li class="li">
         A unified address space is used for both devices (see Unified Virtual Address Space), so the same pointer can be used to address memory from both devices as shown in the code sample below.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="peer-to-peer-memory-copy" xml:lang="en-US">
      <a name="peer-to-peer-memory-copy" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#peer-to-peer-memory-copy" name="peer-to-peer-memory-copy" shape="rect">
        3.2.6.5. Peer-to-Peer Memory Copy
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Memory copies can be performed between the memories of two different devices.
        </li>
        <li class="li">
         When a unified address space is used for both devices (see Unified Virtual Address Space), this is done using the regular memory copy functions mentioned in Device Memory.
        </li>
        <li class="li">
         Otherwise, this is done using cudaMemcpyPeer(), cudaMemcpyPeerAsync(), cudaMemcpy3DPeer(), or cudaMemcpy3DPeerAsync() as illustrated in the following code sample.
        </li>
        <li class="li">
         A copy (in the implicit NULL stream) between the memories of two different devices: does not start until all commands previously issued to either device have completed and runs to completion before any commands (see Asynchronous Concurrent Execution) issued after the copy to either device can start.
        </li>
        <li class="li">
         Consistent with the normal behavior of streams, an asynchronous copy between the memories of two devices may overlap with copies or kernels in another stream.
        </li>
        <li class="li">
         Note that if peer-to-peer access is enabled between two devices via cudaDeviceEnablePeerAccess() as described in Peer-to-Peer Memory Access, peer-to-peer memory copy between these two devices no longer needs to be staged through the host and is therefore faster.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="unified-virtual-address-space" xml:lang="en-US">
     <a name="unified-virtual-address-space" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#unified-virtual-address-space" name="unified-virtual-address-space" shape="rect">
       3.2.7. Unified Virtual Address Space
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        When the application is run as a 64-bit process, a single address space is used for the host and all the devices of compute capability 2.0 and higher.
       </li>
       <li class="li">
        All host memory allocations made via CUDA API calls and all device memory allocations on supported devices are within this virtual address range.
       </li>
       <li class="li">
        As a consequence: The location of any memory on the host allocated through CUDA, or on any of the devices which use the unified address space, can be determined from the value of the pointer using cudaPointerGetAttributes().
       </li>
       <li class="li">
        When copying to or from the memory of any device which uses the unified address space, the cudaMemcpyKind parameter of cudaMemcpy*() can be set to cudaMemcpyDefault to determine locations from the pointers.
       </li>
       <li class="li">
        This also works for host pointers not allocated through CUDA, as long as the current device uses unified addressing.
       </li>
       <li class="li">
        Allocations via cudaHostAlloc() are automatically portable (see Portable Memory) across all the devices for which the unified address space is used, and pointers returned by cudaHostAlloc() can be used directly from within kernels running on these devices (i.e., there is no need to obtain a device pointer via cudaHostGetDevicePointer() as described in Mapped Memory.
       </li>
       <li class="li">
        Applications may query if the unified address space is used for a particular device by checking that the unifiedAddressing device property (see Device Enumeration) is equal to 1.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="interprocess-communication" xml:lang="en-US">
     <a name="interprocess-communication" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#interprocess-communication" name="interprocess-communication" shape="rect">
       3.2.8. Interprocess Communication
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Any device memory pointer or event handle created by a host thread can be directly referenced by any other thread within the same process.
       </li>
       <li class="li">
        It is not valid outside this process however, and therefore cannot be directly referenced by threads belonging to a different process.
       </li>
       <li class="li">
        To share device memory pointers and events across processes, an application must use the Inter Process Communication API, which is described in detail in the reference manual.
       </li>
       <li class="li">
        The IPC API is only supported for 64-bit processes on Linux and for devices of compute capability 2.0 and higher.
       </li>
       <li class="li">
        Using this API, an application can get the IPC handle for a given device memory pointer using cudaIpcGetMemHandle(), pass it to another process using standard IPC mechanisms (e.g., interprocess shared memory or files), and use cudaIpcOpenMemHandle() to retrieve a device pointer from the IPC handle that is a valid pointer within this other process.
       </li>
       <li class="li">
        Event handles can be shared using similar entry points.
       </li>
       <li class="li">
        An example of using the IPC API is where a single master process generates a batch of input data, making the data available to multiple slave processes without requiring regeneration or copying.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="error-checking" xml:lang="en-US">
     <a name="error-checking" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#error-checking" name="error-checking" shape="rect">
       3.2.9. Error Checking
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        All runtime functions return an error code, but for an asynchronous function (see Asynchronous Concurrent Execution), this error code cannot possibly report any of the asynchronous errors that could occur on the device since the function returns before the device has completed the task; the error code only reports errors that occur on the host prior to executing the task, typically related to parameter validation; if an asynchronous error occurs, it will be reported by some subsequent unrelated runtime function call.
       </li>
       <li class="li">
        The only way to check for asynchronous errors just after some asynchronous function call is therefore to synchronize just after the call by calling cudaDeviceSynchronize() (or by using any other synchronization mechanisms described in Asynchronous Concurrent Execution) and checking the error code returned by cudaDeviceSynchronize().
       </li>
       <li class="li">
        The runtime maintains an error variable for each host thread that is initialized to cudaSuccess and is overwritten by the error code every time an error occurs (be it a parameter validation error or an asynchronous error).
       </li>
       <li class="li">
        cudaPeekAtLastError() returns this variable.
       </li>
       <li class="li">
        cudaGetLastError() returns this variable and resets it to cudaSuccess.
       </li>
       <li class="li">
        Kernel launches do not return any error code, so cudaPeekAtLastError() or cudaGetLastError() must be called just after the kernel launch to retrieve any pre-launch errors.
       </li>
       <li class="li">
        To ensure that any error returned by cudaPeekAtLastError() or cudaGetLastError() does not originate from calls prior to the kernel launch, one has to make sure that the runtime error variable is set to cudaSuccess just before the kernel launch, for example, by calling cudaGetLastError() just before the kernel launch.
       </li>
       <li class="li">
        Kernel launches are asynchronous, so to check for asynchronous errors, the application must synchronize in-between the kernel launch and the call to cudaPeekAtLastError() or cudaGetLastError().
       </li>
       <li class="li">
        Note that cudaErrorNotReady that may be returned by cudaStreamQuery() and cudaEventQuery() is not considered an error and is therefore not reported by cudaPeekAtLastError() or cudaGetLastError().
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="call-stack" xml:lang="en-US">
     <a name="call-stack" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#call-stack" name="call-stack" shape="rect">
       3.2.10. Call Stack
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        On devices of compute capability 2.x and higher, the size of the call stack can be queried using cudaDeviceGetLimit() and set using cudaDeviceSetLimit().
       </li>
       <li class="li">
        When the call stack overflows, the kernel call fails with a stack overflow error if the application is run via a CUDA debugger (cuda-gdb, Nsight) or an unspecified launch error, otherwise.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="texture-and-surface-memory" xml:lang="en-US">
     <a name="texture-and-surface-memory" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#texture-and-surface-memory" name="texture-and-surface-memory" shape="rect">
       3.2.11. Texture and Surface Memory
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        CUDA supports a subset of the texturing hardware that the GPU uses for graphics to access texture and surface memory.
       </li>
       <li class="li">
        Reading data from texture or surface memory instead of global memory can have several performance benefits as described in Device Memory Accesses.
       </li>
       <li class="li">
        There are two different APIs to access texture and surface memory: The texture reference API that is supported on all devices, The texture object API that is only supported on devices of compute capability 3.x.
       </li>
       <li class="li">
        The texture reference API has limitations that the texture object API does not have.
       </li>
       <li class="li">
        They are mentioned in Texture Reference API.
       </li>
      </ul>
     </div>
     <div class="topic concept nested4" id="texture-memory" xml:lang="en-US">
      <a name="texture-memory" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#texture-memory" name="texture-memory" shape="rect">
        3.2.11.1. Texture Memory
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Texture memory is read from kernels using the device functions described in Texture Functions.
        </li>
        <li class="li">
         The process of reading a texture calling one of these functions is called a texture fetch.
        </li>
        <li class="li">
         Each texture fetch specifies a parameter called a texture object for the texture object API or a texture reference for the texture reference API.
        </li>
        <li class="li">
         The texture object or the texture reference specifies: The texture, which is the piece of texture memory that is fetched.
        </li>
        <li class="li">
         Texture objects are created at runtime and the texture is specified when creating the texture object as described in Texture Object API.
        </li>
        <li class="li">
         Texture references are created at compile time and the texture is specified at runtime by bounding the texture reference to the texture through runtime functions as described in Texture Reference API; several distinct texture references might be bound to the same texture or to textures that overlap in memory.
        </li>
        <li class="li">
         A texture can be any region of linear memory or a CUDA array (described in CUDA Arrays).
        </li>
        <li class="li">
         Its dimensionality that specifies whether the texture is addressed as a one dimensional array using one texture coordinate, a two-dimensional array using two texture coordinates, or a three-dimensional array using three texture coordinates.
        </li>
        <li class="li">
         Elements of the array are called texels, short for texture elements.
        </li>
        <li class="li">
         The texture width, height, and depth refer to the size of the array in each dimension.
        </li>
        <li class="li">
         Table 13 lists the maximum texture width, height, and depth depending on the compute capability of the device.
        </li>
        <li class="li">
         The type of a texel, which is restricted to the basic integer and single-precision floating-point types and any of the 1-, 2-, and 4-component vector types defined in char, short, int, long, longlong, float, double that are derived from the basic integer and single-precision floating-point types.
        </li>
        <li class="li">
         The read mode, which is equal to cudaReadModeNormalizedFloat or cudaReadModeElementType.
        </li>
        <li class="li">
         If it is cudaReadModeNormalizedFloat and the type of the texel is a 16-bit or 8-bit integer type, the value returned by the texture fetch is actually returned as floating-point type and the full range of the integer type is mapped to [0.0, 1.0] for unsigned integer type and [-1.0, 1.0] for signed integer type; for example, an unsigned 8-bit texture element with the value 0xff reads as 1.
        </li>
        <li class="li">
         If it is cudaReadModeElementType, no conversion is performed.
        </li>
        <li class="li">
         Whether texture coordinates are normalized or not.
        </li>
        <li class="li">
         By default, textures are referenced (by the functions of Texture Functions) using floating-point coordinates in the range [0, N-1] where N is the size of the texture in the dimension corresponding to the coordinate.
        </li>
        <li class="li">
         For example, a texture that is 64x32 in size will be referenced with coordinates in the range [0, 63] and [0, 31] for the x and y dimensions, respectively.
        </li>
        <li class="li">
         Normalized texture coordinates cause the coordinates to be specified in the range [0.0, 1.0-1/N] instead of [0, N-1], so the same 64x32 texture would be addressed by normalized coordinates in the range [0, 1-1/N] in both the x and y dimensions.
        </li>
        <li class="li">
         Normalized texture coordinates are a natural fit to some applications' requirements, if it is preferable for the texture coordinates to be independent of the texture size.
        </li>
        <li class="li">
         The addressing mode.
        </li>
        <li class="li">
         It is valid to call the device functions of Section B.8 with coordinates that are out of range.
        </li>
        <li class="li">
         The addressing mode defines what happens in that case.
        </li>
        <li class="li">
         The default addressing mode is to clamp the coordinates to the valid range: [0, N) for non-normalized coordinates and [0.0, 1.0) for normalized coordinates.
        </li>
        <li class="li">
         If the border mode is specified instead, texture fetches with out-of-range texture coordinates return zero.
        </li>
        <li class="li">
         For normalized coordinates, the warp mode and the mirror mode are also available.
        </li>
        <li class="li">
         When using the wrap mode, each coordinate x is converted to frac(x)=x floor(x) where floor(x) is the largest integer not greater than x.
        </li>
        <li class="li">
         When using the mirror mode, each coordinate x is converted to frac(x) if floor(x) is even and 1-frac(x) if floor(x) is odd.
        </li>
        <li class="li">
         The addressing mode is specified as an array of size three whose first, second, and third elements specify the addressing mode for the first, second, and third texture coordinates, respectively; the addressing mode are cudaAddressModeBorder, cudaAddressModeClamp, cudaAddressModeWrap, and cudaAddressModeMirror; cudaAddressModeWrap and cudaAddressModeMirror are only supported for normalized texture coordinates The filtering mode which specifies how the value returned when fetching the texture is computed based on the input texture coordinates.
        </li>
        <li class="li">
         Linear texture filtering may be done only for textures that are configured to return floating-point data.
        </li>
        <li class="li">
         It performs low-precision interpolation between neighboring texels.
        </li>
        <li class="li">
         When enabled, the texels surrounding a texture fetch location are read and the return value of the texture fetch is interpolated based on where the texture coordinates fell between the texels.
        </li>
        <li class="li">
         Simple linear interpolation is performed for one-dimensional textures, bilinear interpolation for two-dimensional textures, and trilinear interpolation for three-dimensional textures.
        </li>
        <li class="li">
         Texture Fetching gives more details on texture fetching.
        </li>
        <li class="li">
         The filtering mode is equal to cudaFilterModePoint or cudaFilterModeLinear.
        </li>
        <li class="li">
         If it is cudaFilterModePoint, the returned value is the texel whose texture coordinates are the closest to the input texture coordinates.
        </li>
        <li class="li">
         If it is cudaFilterModeLinear, the returned value is the linear interpolation of the two (for a one-dimensional texture), four (for a two dimensional texture), or eight (for a three dimensional texture) texels whose texture coordinates are the closest to the input texture coordinates.
        </li>
        <li class="li">
         cudaFilterModeLinear is only valid for returned values of floating-point type.
        </li>
        <li class="li">
         Texture Object API introduces the texture object API.
        </li>
        <li class="li">
         Texture Reference API introduces the texture reference API.
        </li>
        <li class="li">
         16-Bit Floating-Point Textures explains how to deal with 16-bit floating-point textures.
        </li>
        <li class="li">
         Textures can also be layered as described in Layered Textures.
        </li>
        <li class="li">
         Cubemap Textures and Cubemap Layered Textures describe a special type of texture, the cubemap texture.
        </li>
        <li class="li">
         Texture Gather describes a special texture fetch, texture gather.
        </li>
       </ul>
      </div>
      <div class="topic concept nested5" id="texture-object-api" xml:lang="en-US">
       <a name="texture-object-api" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#texture-object-api" name="texture-object-api" shape="rect">
         3.2.11.1.1. Texture Object API
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          A texture object is created using cudaCreateTextureObject() from a resource description of type struct cudaResourceDesc, which specifies the texture, and from a texture description defined as such: addressMode specifies the addressing mode; filterMode specifies the filter mode; readMode specifies the read mode; normalizedCoords specifies whether texture coordinates are normalized or not; See reference manual for sRGB, maxAnisotropy, mipmapFilterMode, mipmapLevelBias, minMipmapLevelClamp, and maxMipmapLevelClamp.
         </li>
         <li class="li">
          The following code sample applies some simple transformation kernel to a texture.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="texture-reference-api" xml:lang="en-US">
       <a name="texture-reference-api" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#texture-reference-api" name="texture-reference-api" shape="rect">
         3.2.11.1.2. Texture Reference API
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          Some of the attributes of a texture reference are immutable and must be known at compile time; they are specified when declaring the texture reference.
         </li>
         <li class="li">
          A texture reference is declared at file scope as a variable of type texture: where: DataType specifies the type of the texel; Type specifies the type of the texture reference and is equal to cudaTextureType1D, cudaTextureType2D, or cudaTextureType3D, for a one-dimensional, two-dimensional, or three-dimensional texture, respectively, or cudaTextureType1DLayered or cudaTextureType2DLayered for a one-dimensional or two-dimensional layered texture respectively; Type is an optional argument which defaults to cudaTextureType1D; ReadMode specifies the read mode; it is an optional argument which defaults to cudaReadModeElementType.
         </li>
         <li class="li">
          A texture reference can only be declared as a static global variable and cannot be passed as an argument to a function.
         </li>
         <li class="li">
          The other attributes of a texture reference are mutable and can be changed at runtime through the host runtime.
         </li>
         <li class="li">
          As explained in the reference manual, the runtime API has a low-level C-style interface and a high-level C++-style interface.
         </li>
         <li class="li">
          The texture type is defined in the high-level API as a structure publicly derived from the textureReference type defined in the low-level API as such: normalized specifies whether texture coordinates are normalized or not; filterMode specifies the filtering mode; addressMode specifies the addressing mode; channelDesc describes the format of the texel; it must match the DataType argument of the texture reference declaration; channelDesc is of the following type: where x, y, z, and w are equal to the number of bits of each component of the returned value and f is: cudaChannelFormatKindSigned if these components are of signed integer type, cudaChannelFormatKindUnsigned if they are of unsigned integer type, cudaChannelFormatKindFloat if they are of floating point type.
         </li>
         <li class="li">
          See reference manual for sRGB, maxAnisotropy, mipmapFilterMode, mipmapLevelBias, minMipmapLevelClamp, and maxMipmapLevelClamp.
         </li>
         <li class="li">
          normalized, addressMode, and filterMode may be directly modified in host code.
         </li>
         <li class="li">
          Before a kernel can use a texture reference to read from texture memory, the texture reference must be bound to a texture using cudaBindTexture() or cudaBindTexture2D() for linear memory, or cudaBindTextureToArray() for CUDA arrays.
         </li>
         <li class="li">
          cudaUnbindTexture() is used to unbind a texture reference.
         </li>
         <li class="li">
          Once a texture reference has been unbound, it can be safely rebound to another array, even if kernels that use the previously bound texture have not completed.
         </li>
         <li class="li">
          It is recommended to allocate two-dimensional textures in linear memory using cudaMallocPitch() and use the pitch returned by cudaMallocPitch() as input parameter to cudaBindTexture2D().
         </li>
         <li class="li">
          The following code samples bind a 2D texture reference to linear memory pointed to by devPtr: Using the low-level API: Using the high-level API: The following code samples bind a 2D texture reference to a CUDA array cuArray: Using the low-level API: Using the high-level API: The format specified when binding a texture to a texture reference must match the parameters specified when declaring the texture reference; otherwise, the results of texture fetches are undefined.
         </li>
         <li class="li">
          There is a limit to the number of textures that can be bound to a kernel as specified in Table 13.
         </li>
         <li class="li">
          The following code sample applies some simple transformation kernel to a texture.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="sixteen-bit-floating-point-textures" xml:lang="en-US">
       <a name="sixteen-bit-floating-point-textures" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#sixteen-bit-floating-point-textures" name="sixteen-bit-floating-point-textures" shape="rect">
         3.2.11.1.3. 16-Bit Floating-Point Textures
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          The 16-bit floating-point or half format supported by CUDA arrays is the same as the IEEE 754-2008 binary2 format.
         </li>
         <li class="li">
          CUDA C does not support a matching data type, but provides intrinsic functions to convert to and from the 32-bit floating-point format via the unsigned short type: __float2half_rn(float) and __half2float(unsigned short).
         </li>
         <li class="li">
          These functions are only supported in device code.
         </li>
         <li class="li">
          Equivalent functions for the host code can be found in the OpenEXR library, for example.
         </li>
         <li class="li">
          16-bit floating-point components are promoted to 32 bit float during texture fetching before any filtering is performed.
         </li>
         <li class="li">
          A channel description for the 16-bit floating-point format can be created by calling one of the cudaCreateChannelDescHalf*() functions.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="layered-textures" xml:lang="en-US">
       <a name="layered-textures" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#layered-textures" name="layered-textures" shape="rect">
         3.2.11.1.4. Layered Textures
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          A one-dimensional or two-dimensional layered texture (also known as texture array in Direct3D and array texture in OpenGL) is a texture made up of a sequence of layers, all of which are regular textures of same dimensionality, size, and data type.
         </li>
         <li class="li">
          A one-dimensional layered texture is addressed using an integer index and a floating-point texture coordinate; the index denotes a layer within the sequence and the coordinate addresses a texel within that layer.
         </li>
         <li class="li">
          A two-dimensional layered texture is addressed using an integer index and two floating-point texture coordinates; the index denotes a layer within the sequence and the coordinates address a texel within that layer.
         </li>
         <li class="li">
          A layered texture can only be a CUDA array by calling cudaMalloc3DArray() with the cudaArrayLayered flag (and a height of zero for one-dimensional layered texture).
         </li>
         <li class="li">
          Layered textures are fetched using the device functions described in tex1DLayered(), tex1DLayered(), tex2DLayered(), and tex2DLayered().
         </li>
         <li class="li">
          Texture filtering (see Texture Fetching) is done only within a layer, not across layers.
         </li>
         <li class="li">
          Layered textures are only supported on devices of compute capability 2.0 and higher.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="cubemap-textures" xml:lang="en-US">
       <a name="cubemap-textures" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#cubemap-textures" name="cubemap-textures" shape="rect">
         3.2.11.1.5. Cubemap Textures
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          A cubemap texture is a special type of two-dimensional layered texture that has six layers representing the faces of a cube: The width of a layer is equal to its height.
         </li>
         <li class="li">
          The cubemap is addressed using three texture coordinates x, y, and z that are interpreted as a direction vector emanating from the center of the cube and pointing to one face of the cube and a texel within the layer corresponding to that face.
         </li>
         <li class="li">
          More specifically, the face is selected by the coordinate with largest magnitude m and the corresponding layer is addressed using coordinates (s/m+1)/2 and (t/m+1)/2 where s and t are defined in Table 1.
         </li>
         <li class="li">
          A layered texture can only be a CUDA array by calling cudaMalloc3DArray() with the cudaArrayCubemap flag.
         </li>
         <li class="li">
          Cubemap textures are fetched using the device function described in texCubemap() and texCubemap().
         </li>
         <li class="li">
          Cubemap textures are only supported on devices of compute capability 2.0 and higher.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="cubemap-layered-textures" xml:lang="en-US">
       <a name="cubemap-layered-textures" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#cubemap-layered-textures" name="cubemap-layered-textures" shape="rect">
         3.2.11.1.6. Cubemap Layered Textures
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          A cubemap layered texture is a layered texture whose layers are cubemaps of same dimension.
         </li>
         <li class="li">
          A cubemap layered texture is addressed using an integer index and three floating-point texture coordinates; the index denotes a cubemap within the sequence and the coordinates address a texel within that cubemap.
         </li>
         <li class="li">
          A layered texture can only be a CUDA array by calling cudaMalloc3DArray() with the cudaArrayLayered and cudaArrayCubemap flags.
         </li>
         <li class="li">
          Cubemap layered textures are fetched using the device function described in texCubemapLayered() and texCubemapLayered().
         </li>
         <li class="li">
          Texture filtering (see Texture Fetching) is done only within a layer, not across layers.
         </li>
         <li class="li">
          Cubemap layered textures are only supported on devices of compute capability 2.0 and higher.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="texture-gather" xml:lang="en-US">
       <a name="texture-gather" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#texture-gather" name="texture-gather" shape="rect">
         3.2.11.1.7. Texture Gather
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          Texture gather is a special texture fetch that is available for two-dimensional textures only.
         </li>
         <li class="li">
          It is performed by the tex2Dgather() function, which has the same parameters as tex2D(), plus an additional comp parameter equal to 0, 1, 2, or 3 (see tex2Dgather() and tex2Dgather()).
         </li>
         <li class="li">
          It returns four 32-bit numbers that correspond to the value of the component comp of each of the four texels that would have been used for bilinear filtering during a regular texture fetch.
         </li>
         <li class="li">
          For example, if these texels are of values (253, 20, 31, 255), (250, 25, 29, 254), (249, 16, 37, 253), (251, 22, 30, 250), and comp is 2, tex2Dgather() returns (31, 29, 37, 30).
         </li>
         <li class="li">
          Texture gather is only supported for CUDA arrays created with the cudaArrayTextureGather flag and of width and height less than the maximum specified in Table 13 for texture gather, which is smaller than for regular texture fetch.
         </li>
         <li class="li">
          Texture gather is only supported on devices of compute capability 2.0 and higher.
         </li>
        </ul>
       </div>
      </div>
     </div>
     <div class="topic concept nested4" id="surface-memory" xml:lang="en-US">
      <a name="surface-memory" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surface-memory" name="surface-memory" shape="rect">
        3.2.11.2. Surface Memory
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         For devices of compute capability 2.0 and higher, a CUDA array (described in Cubemap Surfaces), created with the cudaArraySurfaceLoadStore flag, can be read and written via a surface object or surface reference using the functions described in Surface Functions.
        </li>
        <li class="li">
         Table 13 lists the maximum surface width, height, and depth depending on the compute capability of the device.
        </li>
       </ul>
      </div>
      <div class="topic concept nested5" id="surface-object-api" xml:lang="en-US">
       <a name="surface-object-api" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surface-object-api" name="surface-object-api" shape="rect">
         3.2.11.2.1. Surface Object API
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          A surface object is created using cudaCreateSurfaceObject() from a resource description of type struct cudaResourceDesc.
         </li>
         <li class="li">
          The following code sample applies some simple transformation kernel to a texture.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="surface-reference-api" xml:lang="en-US">
       <a name="surface-reference-api" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surface-reference-api" name="surface-reference-api" shape="rect">
         3.2.11.2.2. Surface Reference API
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          A surface reference is declared at file scope as a variable of type surface: where Type specifies the type of the surface reference and is equal to cudaSurfaceType1D, cudaSurfaceType2D, cudaSurfaceType3D, cudaSurfaceTypeCubemap, cudaSurfaceType1DLayered, cudaSurfaceType2DLayered, or cudaSurfaceTypeCubemapLayered; Type is an optional argument which defaults to cudaSurfaceType1D.
         </li>
         <li class="li">
          A surface reference can only be declared as a static global variable and cannot be passed as an argument to a function.
         </li>
         <li class="li">
          Before a kernel can use a surface reference to access a CUDA array, the surface reference must be bound to the CUDA array using cudaBindSurfaceToArray().
         </li>
         <li class="li">
          The following code samples bind a surface reference to a CUDA array cuArray: Using the low-level API: Using the high-level API: A CUDA array must be read and written using surface functions of matching dimensionality and type and via a surface reference of matching dimensionality; otherwise, the results of reading and writing the CUDA array are undefined.
         </li>
         <li class="li">
          Unlike texture memory, surface memory uses byte addressing.
         </li>
         <li class="li">
          This means that the x-coordinate used to access a texture element via texture functions needs to be multiplied by the byte size of the element to access the same element via a surface function.
         </li>
         <li class="li">
          For example, the element at texture coordinate x of a one-dimensional floating-point CUDA array bound to a texture reference texRef and a surface reference surfRef is read using tex1d(texRef, x) via texRef, but surf1Dread(surfRef, 4*x) via surfRef.
         </li>
         <li class="li">
          Similarly, the element at texture coordinate x and y of a two-dimensional floating-point CUDA array bound to a texture reference texRef and a surface reference surfRef is accessed using tex2d(texRef, x, y) via texRef, but surf2Dread(surfRef, 4*x, y) via surfRef (the byte offset of the y-coordinate is internally calculated from the underlying line pitch of the CUDA array).
         </li>
         <li class="li">
          The following code sample applies some simple transformation kernel to a texture.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="cubemap-surfaces" xml:lang="en-US">
       <a name="cubemap-surfaces" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#cubemap-surfaces" name="cubemap-surfaces" shape="rect">
         3.2.11.2.3. Cubemap Surfaces
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          Cubemap surfaces are accessed usingsurfCubemapread() and surfCubemapwrite() (surfCubemapread and surfCubemapwrite) as a two-dimensional layered surface, i.e., using an integer index denoting a face and two floating-point texture coordinates addressing a texel within the layer corresponding to this face.
         </li>
         <li class="li">
          Faces are ordered as indicated in Table 1.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="cubemap-layered-surfaces" xml:lang="en-US">
       <a name="cubemap-layered-surfaces" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#cubemap-layered-surfaces" name="cubemap-layered-surfaces" shape="rect">
         3.2.11.2.4. Cubemap Layered Surfaces
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          Cubemap layered surfaces are accessed using surfCubemapLayeredread() and surfCubemapLayeredwrite() (surfCubemapLayeredread() and surfCubemapLayeredwrite()) as a two-dimensional layered surface, i.e., using an integer index denoting a face of one of the cubemaps and two floating-point texture coordinates addressing a texel within the layer corresponding to this face.
         </li>
         <li class="li">
          Faces are ordered as indicated in Table 1, so index ((2 * 6) + 3), for example, accesses the fourth face of the third cubemap.
         </li>
        </ul>
       </div>
      </div>
     </div>
     <div class="topic concept nested4" id="cuda-arrays" xml:lang="en-US">
      <a name="cuda-arrays" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#cuda-arrays" name="cuda-arrays" shape="rect">
        3.2.11.3. CUDA Arrays
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         CUDA arrays are opaque memory layouts optimized for texture fetching.
        </li>
        <li class="li">
         They are one dimensional, two dimensional, or three-dimensional and composed of elements, each of which has 1, 2 or 4 components that may be signed or unsigned 8-, 16-, or 32-bit integers, 16-bit floats, or 32-bit floats.
        </li>
        <li class="li">
         CUDA arrays are only accessible by kernels through texture fetching as described in Texture Memory or surface reading and writing as described in Surface Memory.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="read-write-coherency" xml:lang="en-US">
      <a name="read-write-coherency" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#read-write-coherency" name="read-write-coherency" shape="rect">
        3.2.11.4. Read/Write Coherency
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The texture and surface memory is cached (see Device Memory Accesses) and within the same kernel call, the cache is not kept coherent with respect to global memory writes and surface memory writes, so any texture fetch or surface read to an address that has been written to via a global write or a surface write in the same kernel call returns undefined data.
        </li>
        <li class="li">
         In other words, a thread can safely read some texture or surface memory location only if this memory location has been updated by a previous kernel call or memory copy, but not if it has been previously updated by the same thread or another thread from the same kernel call.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="graphics-interoperability" xml:lang="en-US">
     <a name="graphics-interoperability" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#graphics-interoperability" name="graphics-interoperability" shape="rect">
       3.2.12. Graphics Interoperability
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Some resources from OpenGL and Direct3D may be mapped into the address space of CUDA, either to enable CUDA to read data written by OpenGL or Direct3D, or to enable CUDA to write data for consumption by OpenGL or Direct3D.
       </li>
       <li class="li">
        A resource must be registered to CUDA before it can be mapped using the functions mentioned in OpenGL Interoperability and Direct3D Interoperability.
       </li>
       <li class="li">
        These functions return a pointer to a CUDA graphics resource of type struct cudaGraphicsResource.
       </li>
       <li class="li">
        Registering a resource is potentially high-overhead and therefore typically called only once per resource.
       </li>
       <li class="li">
        A CUDA graphics resource is unregistered using cudaGraphicsUnregisterResource().
       </li>
       <li class="li">
        Each CUDA context which intends to use the resource is required to register it separately.
       </li>
       <li class="li">
        Once a resource is registered to CUDA, it can be mapped and unmapped as many times as necessary using cudaGraphicsMapResources() and cudaGraphicsUnmapResources().
       </li>
       <li class="li">
        cudaGraphicsResourceSetMapFlags() can be called to specify usage hints (write-only, read-only) that the CUDA driver can use to optimize resource management.
       </li>
       <li class="li">
        A mapped resource can be read from or written to by kernels using the device memory address returned by cudaGraphicsResourceGetMappedPointer() for buffers and cudaGraphicsSubResourceGetMappedArray() for CUDA arrays.
       </li>
       <li class="li">
        Accessing a resource through OpenGL, Direct3D, or another CUDA context while it is mapped produces undefined results.
       </li>
       <li class="li">
        OpenGL Interoperability and Direct3D Interoperability give specifics for each graphics API and some code samples.
       </li>
       <li class="li">
        SLI Interoperability gives specifics for when the system is in SLI mode.
       </li>
      </ul>
     </div>
     <div class="topic concept nested4" id="opengl-interoperability" xml:lang="en-US">
      <a name="opengl-interoperability" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#opengl-interoperability" name="opengl-interoperability" shape="rect">
        3.2.12.1. OpenGL Interoperability
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The OpenGL resources that may be mapped into the address space of CUDA are OpenGL buffer, texture, and renderbuffer objects.
        </li>
        <li class="li">
         A buffer object is registered using cudaGraphicsGLRegisterBuffer().
        </li>
        <li class="li">
         In CUDA, it appears as a device pointer and can therefore be read and written by kernels or via cudaMemcpy() calls.
        </li>
        <li class="li">
         A texture or renderbuffer object is registered using cudaGraphicsGLRegisterImage().
        </li>
        <li class="li">
         In CUDA, it appears as a CUDA array.
        </li>
        <li class="li">
         Kernels can read from the array by binding it to a texture or surface reference.
        </li>
        <li class="li">
         They can also write to it via the surface write functions if the resource has been registered with the cudaGraphicsRegisterFlagsSurfaceLoadStore flag.
        </li>
        <li class="li">
         The array can also be read and written via cudaMemcpy2D() calls.
        </li>
        <li class="li">
         cudaGraphicsGLRegisterImage() supports all texture formats with 1, 2, or 4 components and an internal type of float (e.g., GL_RGBA_FLOAT32), normalized integer (e.g., GL_RGBA8, GL_INTENSITY16), and unnormalized integer (e.g., GL_RGBA8UI) (please note that since unnormalized integer formats require OpenGL 3.0, they can only be written by shaders, not the fixed function pipeline).
        </li>
        <li class="li">
         The OpenGL context whose resources are being shared has to be current to the host thread making any OpenGL interoperability API calls.
        </li>
        <li class="li">
         Please note: When an OpenGL texture is made bindless (say for example by requesting an image or texture handle using the glGetTextureHandle*/glGetImageHandle* APIs) it cannot be registered with CUDA.
        </li>
        <li class="li">
         The application needs to register the texture for interop before requesting an image or texture handle.
        </li>
        <li class="li">
         The following code sample uses a kernel to dynamically modify a 2D width x height grid of vertices stored in a vertex buffer object: On Windows and for Quadro GPUs, cudaWGLGetDevice() can be used to retrieve the CUDA device associated to the handle returned by wglEnumGpusNV().
        </li>
        <li class="li">
         Quadro GPUs offer higher performance OpenGL interoperability than GeForce and Tesla GPUs in a multi-GPU configuration where OpenGL rendering is performed on the Quadro GPU and CUDA computations are performed on other GPUs in the system.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="direct3d-interoperability" xml:lang="en-US">
      <a name="direct3d-interoperability" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#direct3d-interoperability" name="direct3d-interoperability" shape="rect">
        3.2.12.2. Direct3D Interoperability
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Direct3D interoperability is supported for Direct3D 9Ex, Direct3D 10, and Direct3D 11.
        </li>
        <li class="li">
         A CUDA context may interoperate only with Direct3D devices that fulfill the following criteria: Direct3D 9Ex devices must be created with DeviceType set to D3DDEVTYPE_HAL and BehaviorFlags with the D3DCREATE_HARDWARE_VERTEXPROCESSING flag; Direct3D 10 and Direct3D 11 devices must be created with DriverType set to D3D_DRIVER_TYPE_HARDWARE.
        </li>
        <li class="li">
         The Direct3D resources that may be mapped into the address space of CUDA are Direct3D buffers, textures, and surfaces.
        </li>
        <li class="li">
         These resources are registered using cudaGraphicsD3D9RegisterResource(), cudaGraphicsD3D10RegisterResource(), and cudaGraphicsD3D11RegisterResource().
        </li>
        <li class="li">
         The following code sample uses a kernel to dynamically modify a 2D width x height grid of vertices stored in a vertex buffer object.
        </li>
       </ul>
      </div>
      <div class="topic concept nested5" id="direct3d-9-version" xml:lang="en-US">
       <a name="direct3d-9-version" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#direct3d-9-version" name="direct3d-9-version" shape="rect">
         3.2.12.2.1. Direct3D 9 Version
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="direct3d-10-version" xml:lang="en-US">
       <a name="direct3d-10-version" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#direct3d-10-version" name="direct3d-10-version" shape="rect">
         3.2.12.2.2. Direct3D 10 Version
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="direct3d-11-version" xml:lang="en-US">
       <a name="direct3d-11-version" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#direct3d-11-version" name="direct3d-11-version" shape="rect">
         3.2.12.2.3. Direct3D 11 Version
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
        </ul>
       </div>
      </div>
     </div>
     <div class="topic concept nested4" id="sli-interoperability" xml:lang="en-US">
      <a name="sli-interoperability" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#sli-interoperability" name="sli-interoperability" shape="rect">
        3.2.12.3. SLI Interoperability
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         In a system with multiple GPUs, all CUDA-enabled GPUs are accessible via the CUDA driver and runtime as separate devices.
        </li>
        <li class="li">
         There are however special considerations as described below when the system is in SLI mode.
        </li>
        <li class="li">
         First, an allocation in one CUDA device on one GPU will consume memory on other GPUs that are part of the SLI configuration of the Direct3D or OpenGL device.
        </li>
        <li class="li">
         Because of this, allocations may fail earlier than otherwise expected.
        </li>
        <li class="li">
         Second, applications should create multiple CUDA contexts, one for each GPU in the SLI configuration.
        </li>
        <li class="li">
         While this is not a strict requirement, it avoids unnecessary data transfers between devices.
        </li>
        <li class="li">
         The application can use the cudaD3D[9|10|11]GetDevices() for Direct3D and cudaGLGetDevices() for OpenGL set of calls to identify the CUDA device handle(s) for the device(s) that are performing the rendering in the current and next frame.
        </li>
        <li class="li">
         Given this information the application will typically choose the appropriate device and map Direct3D or OpenGL resources to the CUDA device returned by cudaD3D[9|10|11]GetDevices() or cudaGLGetDevices() when the deviceList parameter is set to cudaD3D[9|10|11]DeviceListCurrentFrame or cudaGLDeviceListCurrentFrame.
        </li>
        <li class="li">
         Please note that resource returned from cudaGraphicsD9D[9|10|11]RegisterResource and cudaGraphicsGLRegister[Buffer|Image] must be only used on device the registration happened.
        </li>
        <li class="li">
         Therefore on SLI configurations when data for different frames is computed on different CUDA devices it is necessary to register the resources for each separatly.
        </li>
        <li class="li">
         See Direct3D Interoperability and OpenGL Interoperability for details on how the CUDA runtime interoperate with Direct3D and OpenGL, respectively.
        </li>
       </ul>
      </div>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="versioning-and-compatibility" xml:lang="en-US">
    <a name="versioning-and-compatibility" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#versioning-and-compatibility" name="versioning-and-compatibility" shape="rect">
      3.3. Versioning and Compatibility
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       There are two version numbers that developers should care about when developing a CUDA application: The compute capability that describes the general specifications and features of the compute device (see Compute Capability) and the version of the CUDA driver API that describes the features supported by the driver API and runtime.
      </li>
      <li class="li">
       The version of the driver API is defined in the driver header file as CUDA_VERSION.
      </li>
      <li class="li">
       It allows developers to check whether their application requires a newer device driver than the one currently installed.
      </li>
      <li class="li">
       This is important, because the driver API is backward compatible, meaning that applications, plug-ins, and libraries (including the C runtime) compiled against a particular version of the driver API will continue to work on subsequent device driver releases as illustrated in Figure 11.
      </li>
      <li class="li">
       The driver API is not forward compatible, which means that applications, plug-ins, and libraries (including the C runtime) compiled against a particular version of the driver API will not work on previous versions of the device driver.
      </li>
      <li class="li">
       It is important to note that there are limitations on the mixing and matching of versions that is supported: Since only one version of the CUDA Driver can be installed at a time on a system, the installed driver must be of the same or higher version than the maximum Driver API version against which any application, plug-ins, or libraries that must run on that system were built.
      </li>
      <li class="li">
       All plug-ins and libraries used by an application must use the same version of the CUDA Runtime unless they statically link to the Runtime, in which case multiple versions of the runtime can coexist in the same process space.
      </li>
      <li class="li">
       Note that if nvcc is used to link the application, the static version of the CUDA Runtime library will be used by default, and all CUDA Toolkit libraries are statically linked against the CUDA Runtime.
      </li>
      <li class="li">
       All plug-ins and libraries used by an application must use the same version of any libraries that use the runtime (such as cuFFT, cuBLAS, ...) unless statically linking to those libraries.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="compute-modes" xml:lang="en-US">
    <a name="compute-modes" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#compute-modes" name="compute-modes" shape="rect">
      3.4. Compute Modes
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       On Tesla solutions running Windows Server 2008 and later or Linux, one can set any device in a system in one of the three following modes using NVIDIA's System Management Interface (nvidia-smi), which is a tool distributed as part of the driver: Default compute mode: Multiple host threads can use the device (by calling cudaSetDevice() on this device, when using the runtime API, or by making current a context associated to the device, when using the driver API) at the same time.
      </li>
      <li class="li">
       Exclusive-process compute mode: Only one CUDA context may be created on the device across all processes in the system and that context may be current to as many threads as desired within the process that created that context.
      </li>
      <li class="li">
       Exclusive-process-and-thread compute mode: Only one CUDA context may be created on the device across all processes in the system and that context may only be current to one thread at a time.
      </li>
      <li class="li">
       Prohibited compute mode: No CUDA context can be created on the device.
      </li>
      <li class="li">
       This means, in particular, that a host thread using the runtime API without explicitly calling cudaSetDevice() might be associated with a device other than device 0 if device 0 turns out to be in the exclusive-process mode and used by another process, or in the exclusive-process-and-thread mode and used by another thread, or in prohibited mode.
      </li>
      <li class="li">
       cudaSetValidDevices() can be used to set a device from a prioritized list of devices.
      </li>
      <li class="li">
       Applications may query the compute mode of a device by checking the computeMode device property (see Device Enumeration).
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="mode-switches" xml:lang="en-US">
    <a name="mode-switches" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#mode-switches" name="mode-switches" shape="rect">
      3.5. Mode Switches
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       GPUs that have a display output dedicate some DRAM memory to the so-called primary surface, which is used to refresh the display device whose output is viewed by the user.
      </li>
      <li class="li">
       When users initiate a mode switch of the display by changing the resolution or bit depth of the display (using NVIDIA control panel or the Display control panel on Windows), the amount of memory needed for the primary surface changes.
      </li>
      <li class="li">
       For example, if the user changes the display resolution from 1280x1024x32-bit to 1600x1200x32-bit, the system must dedicate 7.68 MB to the primary surface rather than 5.24 MB.
      </li>
      <li class="li">
       (Full-screen graphics applications running with anti-aliasing enabled may require much more display memory for the primary surface.)
      </li>
      <li class="li">
       On Windows, other events that may initiate display mode switches include launching a full-screen DirectX application, hitting Alt+Tab to task switch away from a full-screen DirectX application, or hitting Ctrl+Alt+Del to lock the computer.
      </li>
      <li class="li">
       If a mode switch increases the amount of memory needed for the primary surface, the system may have to cannibalize memory allocations dedicated to CUDA applications.
      </li>
      <li class="li">
       Therefore, a mode switch results in any call to the CUDA runtime to fail and return an invalid context error.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="tesla-compute-cluster-mode-for-windows" xml:lang="en-US">
    <a name="tesla-compute-cluster-mode-for-windows" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tesla-compute-cluster-mode-for-windows" name="tesla-compute-cluster-mode-for-windows" shape="rect">
      3.6. Tesla Compute Cluster Mode for Windows
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       Using NVIDIA's System Management Interface (nvidia-smi), the Windows device driver can be put in TCC (Tesla Compute Cluster) mode for devices of the Tesla and Quadro Series of compute capability 2.0 and higher.
      </li>
      <li class="li">
       This mode has the following primary benefits: It makes it possible to use these GPUs in cluster nodes with non-NVIDIA integrated graphics; It makes these GPUs available via Remote Desktop, both directly and via cluster management systems that rely on Remote Desktop; It makes these GPUs available to applications running as a Windows service (i.e., in Session 0).
      </li>
      <li class="li">
       However, the TCC mode removes support for any graphics functionality.
      </li>
     </ul>
    </div>
   </div>
  </div>
  <div class="topic concept nested1" id="hardware-implementation" xml:lang="en-US">
   <a name="hardware-implementation" shape="rect">
   </a>
   <h2 class="title topictitle1">
    <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#hardware-implementation" name="hardware-implementation" shape="rect">
     4. Hardware Implementation
    </a>
   </h2>
   <div class="body conbody">
    <ul class="ul">
     <li class="li">
      The NVIDIA GPU architecture is built around a scalable array of multithreaded Streaming Multiprocessors (SMs).
     </li>
     <li class="li">
      When a CUDA program on the host CPU invokes a kernel grid, the blocks of the grid are enumerated and distributed to multiprocessors with available execution capacity.
     </li>
     <li class="li">
      The threads of a thread block execute concurrently on one multiprocessor, and multiple thread blocks can execute concurrently on one multiprocessor.
     </li>
     <li class="li">
      As thread blocks terminate, new blocks are launched on the vacated multiprocessors.
     </li>
     <li class="li">
      A multiprocessor is designed to execute hundreds of threads concurrently.
     </li>
     <li class="li">
      To manage such a large amount of threads, it employs a unique architecture called SIMT (Single-Instruction, Multiple-Thread) that is described in SIMT Architecture.
     </li>
     <li class="li">
      The instructions are pipelined to leverage instruction-level parallelism within a single thread, as well as thread-level parallelism extensively through simultaneous hardware multithreading as detailed in Hardware Multithreading.
     </li>
     <li class="li">
      Unlike CPU cores they are issued in order however and there is no branch prediction and no speculative execution.
     </li>
     <li class="li">
      SIMT Architecture and Hardware Multithreading describe the architecture features of the streaming multiprocessor that are common to all devices.
     </li>
     <li class="li">
      Compute Capability 2.x, Compute Capability 3.x, Compute Capability 5.x, and Compute Capability 6.x provide the specifics for devices of compute capabilities 2.x, 3.x, 5.x, and 6.x, respectively.
     </li>
     <li class="li">
      The NVIDIA GPU architecture uses a little-endian representation.
     </li>
    </ul>
   </div>
   <div class="topic concept nested2" id="simt-architecture" xml:lang="en-US">
    <a name="simt-architecture" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#simt-architecture" name="simt-architecture" shape="rect">
      4.1. SIMT Architecture
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       The multiprocessor creates, manages, schedules, and executes threads in groups of 32 parallel threads called warps.
      </li>
      <li class="li">
       Individual threads composing a warp start together at the same program address, but they have their own instruction address counter and register state and are therefore free to branch and execute independently.
      </li>
      <li class="li">
       The term warp originates from weaving, the first parallel thread technology.
      </li>
      <li class="li">
       A half-warp is either the first or second half of a warp.
      </li>
      <li class="li">
       A quarter-warp is either the first, second, third, or fourth quarter of a warp.
      </li>
      <li class="li">
       When a multiprocessor is given one or more thread blocks to execute, it partitions them into warps and each warp gets scheduled by a warp scheduler for execution.
      </li>
      <li class="li">
       The way a block is partitioned into warps is always the same; each warp contains threads of consecutive, increasing thread IDs with the first warp containing thread 0.
      </li>
      <li class="li">
       Thread Hierarchy describes how thread IDs relate to thread indices in the block.
      </li>
      <li class="li">
       A warp executes one common instruction at a time, so full efficiency is realized when all 32 threads of a warp agree on their execution path.
      </li>
      <li class="li">
       If threads of a warp diverge via a data-dependent conditional branch, the warp serially executes each branch path taken, disabling threads that are not on that path, and when all paths complete, the threads converge back to the same execution path.
      </li>
      <li class="li">
       Branch divergence occurs only within a warp; different warps execute independently regardless of whether they are executing common or disjoint code paths.
      </li>
      <li class="li">
       The SIMT architecture is akin to SIMD (Single Instruction, Multiple Data) vector organizations in that a single instruction controls multiple processing elements.
      </li>
      <li class="li">
       A key difference is that SIMD vector organizations expose the SIMD width to the software, whereas SIMT instructions specify the execution and branching behavior of a single thread.
      </li>
      <li class="li">
       In contrast with SIMD vector machines, SIMT enables programmers to write thread-level parallel code for independent, scalar threads, as well as data-parallel code for coordinated threads.
      </li>
      <li class="li">
       For the purposes of correctness, the programmer can essentially ignore the SIMT behavior; however, substantial performance improvements can be realized by taking care that the code seldom requires threads in a warp to diverge.
      </li>
      <li class="li">
       In practice, this is analogous to the role of cache lines in traditional code: Cache line size can be safely ignored when designing for correctness but must be considered in the code structure when designing for peak performance.
      </li>
      <li class="li">
       Vector architectures, on the other hand, require the software to coalesce loads into vectors and manage divergence manually.
      </li>
      <li class="li">
       The threads of a warp that are on that warp's current execution path are called the active threads, whereas threads not on the current path are inactive (disabled).
      </li>
      <li class="li">
       Threads can be inactive because they have exited earlier than other threads of their warp, or because they are on a different branch path than the branch path currently executed by the warp, or because they are the last threads of a block whose number of threads is not a multiple of the warp size.
      </li>
      <li class="li">
       If a non-atomic instruction executed by a warp writes to the same location in global or shared memory for more than one of the threads of the warp, the number of serialized writes that occur to that location varies depending on the compute capability of the device (see Compute Capability 2.x, Compute Capability 3.x, Compute Capability 5.x, and Compute Capability 6.x), and which thread performs the final write is undefined.
      </li>
      <li class="li">
       If an atomic instruction executed by a warp reads, modifies, and writes to the same location in global memory for more than one of the threads of the warp, each read/modify/write to that location occurs and they are all serialized, but the order in which they occur is undefined.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="hardware-multithreading" xml:lang="en-US">
    <a name="hardware-multithreading" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#hardware-multithreading" name="hardware-multithreading" shape="rect">
      4.2. Hardware Multithreading
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       The execution context (program counters, registers, etc.)
      </li>
      <li class="li">
       for each warp processed by a multiprocessor is maintained on-chip during the entire lifetime of the warp.
      </li>
      <li class="li">
       Therefore, switching from one execution context to another has no cost, and at every instruction issue time, a warp scheduler selects a warp that has threads ready to execute its next instruction (the active threads of the warp) and issues the instruction to those threads.
      </li>
      <li class="li">
       In particular, each multiprocessor has a set of 32-bit registers that are partitioned among the warps, and a parallel data cache or shared memory that is partitioned among the thread blocks.
      </li>
      <li class="li">
       The number of blocks and warps that can reside and be processed together on the multiprocessor for a given kernel depends on the amount of registers and shared memory used by the kernel and the amount of registers and shared memory available on the multiprocessor.
      </li>
      <li class="li">
       There are also a maximum number of resident blocks and a maximum number of resident warps per multiprocessor.
      </li>
      <li class="li">
       These limits as well the amount of registers and shared memory available on the multiprocessor are a function of the compute capability of the device and are given in Appendix Compute Capabilities.
      </li>
      <li class="li">
       If there are not enough registers or shared memory available per multiprocessor to process at least one block, the kernel will fail to launch.
      </li>
      <li class="li">
       The total number of warps in a block is as follows: ceil ( T W s i z e , 1 ) T is the number of threads per block, Wsize is the warp size, which is equal to 32, ceil(x, y) is equal to x rounded up to the nearest multiple of y.
      </li>
      <li class="li">
       The total number of registers and total amount of shared memory allocated for a block are documented in the CUDA Occupancy Calculator provided in the CUDA Toolkit.
      </li>
     </ul>
    </div>
   </div>
  </div>
  <div class="topic concept nested1" id="performance-guidelines" xml:lang="en-US">
   <a name="performance-guidelines" shape="rect">
   </a>
   <h2 class="title topictitle1">
    <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#performance-guidelines" name="performance-guidelines" shape="rect">
     5. Performance Guidelines
    </a>
   </h2>
   <div class="topic concept nested2" id="overall-performance-optimization-strategies" xml:lang="en-US">
    <a name="overall-performance-optimization-strategies" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#overall-performance-optimization-strategies" name="overall-performance-optimization-strategies" shape="rect">
      5.1. Overall Performance Optimization Strategies
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       Performance optimization revolves around three basic strategies: Maximize parallel execution to achieve maximum utilization; Optimize memory usage to achieve maximum memory throughput; Optimize instruction usage to achieve maximum instruction throughput.
      </li>
      <li class="li">
       Which strategies will yield the best performance gain for a particular portion of an application depends on the performance limiters for that portion; optimizing instruction usage of a kernel that is mostly limited by memory accesses will not yield any significant performance gain, for example.
      </li>
      <li class="li">
       Optimization efforts should therefore be constantly directed by measuring and monitoring the performance limiters, for example using the CUDA profiler.
      </li>
      <li class="li">
       Also, comparing the floating-point operation throughput or memory throughput - whichever makes more sense - of a particular kernel to the corresponding peak theoretical throughput of the device indicates how much room for improvement there is for the kernel.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="maximize-utilization" xml:lang="en-US">
    <a name="maximize-utilization" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#maximize-utilization" name="maximize-utilization" shape="rect">
      5.2. Maximize Utilization
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       To maximize utilization the application should be structured in a way that it exposes as much parallelism as possible and efficiently maps this parallelism to the various components of the system to keep them busy most of the time.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="application-level" xml:lang="en-US">
     <a name="application-level" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#application-level" name="application-level" shape="rect">
       5.2.1. Application Level
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        At a high level, the application should maximize parallel execution between the host, the devices, and the bus connecting the host to the devices, by using asynchronous functions calls and streams as described in Asynchronous Concurrent Execution.
       </li>
       <li class="li">
        It should assign to each processor the type of work it does best: serial workloads to the host; parallel workloads to the devices.
       </li>
       <li class="li">
        For the parallel workloads, at points in the algorithm where parallelism is broken because some threads need to synchronize in order to share data with each other, there are two cases: Either these threads belong to the same block, in which case they should use __syncthreads() and share data through shared memory within the same kernel invocation, or they belong to different blocks, in which case they must share data through global memory using two separate kernel invocations, one for writing to and one for reading from global memory.
       </li>
       <li class="li">
        The second case is much less optimal since it adds the overhead of extra kernel invocations and global memory traffic.
       </li>
       <li class="li">
        Its occurrence should therefore be minimized by mapping the algorithm to the CUDA programming model in such a way that the computations that require inter-thread communication are performed within a single thread block as much as possible.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="device-level" xml:lang="en-US">
     <a name="device-level" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#device-level" name="device-level" shape="rect">
       5.2.2. Device Level
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        At a lower level, the application should maximize parallel execution between the multiprocessors of a device.
       </li>
       <li class="li">
        Multiple kernels can execute concurrently on a device, so maximum utilization can also be achieved by using streams to enable enough kernels to execute concurrently as described in Asynchronous Concurrent Execution.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="multiprocessor-level" xml:lang="en-US">
     <a name="multiprocessor-level" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#multiprocessor-level" name="multiprocessor-level" shape="rect">
       5.2.3. Multiprocessor Level
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        At an even lower level, the application should maximize parallel execution between the various functional units within a multiprocessor.
       </li>
       <li class="li">
        As described in Hardware Multithreading, a GPU multiprocessor relies on thread-level parallelism to maximize utilization of its functional units.
       </li>
       <li class="li">
        Utilization is therefore directly linked to the number of resident warps.
       </li>
       <li class="li">
        At every instruction issue time, a warp scheduler selects a warp that is ready to execute its next instruction, if any, and issues the instruction to the active threads of the warp.
       </li>
       <li class="li">
        The number of clock cycles it takes for a warp to be ready to execute its next instruction is called the latency, and full utilization is achieved when all warp schedulers always have some instruction to issue for some warp at every clock cycle during that latency period, or in other words, when latency is completely "hidden".
       </li>
       <li class="li">
        The number of instructions required to hide a latency of L clock cycles depends on the respective throughputs of these instructions (see Arithmetic Instructions for the throughputs of various arithmetic instructions); assuming maximum throughput for all instructions, it is: L for devices of compute capability 2.0 since a multiprocessor issues one instruction per warp over two clock cycles for two warps at a time, as mentioned in Compute Capability 2.x, 2L for devices of compute capability 2.1 since a multiprocessor issues a pair of instructions per warp over two clock cycles for two warps at a time, as mentioned in Compute Capability 2.x, 8L for devices of compute capability 3.x since a multiprocessor issues a pair of instructions per warp over one clock cycle for four warps at a time, as mentioned in Compute Capability 3.x.
       </li>
       <li class="li">
        For devices of compute capability 2.0, the two instructions issued every other cycle are for two different warps.
       </li>
       <li class="li">
        For devices of compute capability 2.1, the four instructions issued every other cycle are two pairs for two different warps, each pair being for the same warp.
       </li>
       <li class="li">
        For devices of compute capability 3.x, the eight instructions issued every cycle are four pairs for four different warps, each pair being for the same warp.
       </li>
       <li class="li">
        The most common reason a warp is not ready to execute its next instruction is that the instruction's input operands are not available yet.
       </li>
       <li class="li">
        If all input operands are registers, latency is caused by register dependencies, i.e., some of the input operands are written by some previous instruction(s) whose execution has not completed yet.
       </li>
       <li class="li">
        In the case of a back-to-back register dependency (i.e., some input operand is written by the previous instruction), the latency is equal to the execution time of the previous instruction and the warp schedulers must schedule instructions for different warps during that time.
       </li>
       <li class="li">
        Execution time varies depending on the instruction, but it is typically about 22 clock cycles for devices of compute capability 2.x and about 11 clock cycles for devices of compute capability 3.x, which translates to 22 warps for devices of compute capability 2.x and 44 warps for devices of compute capability 3.x and higher (still assuming that warps execute instructions with maximum throughput, otherwise fewer warps are needed).
       </li>
       <li class="li">
        For devices of compute capability 2.1 and higher, this is also assuming enough instruction-level parallelism so that schedulers are always able to issue pairs of instructions for each warp.
       </li>
       <li class="li">
        If some input operand resides in off-chip memory, the latency is much higher: 400 to 800 clock cycles for devices of compute capability 2.x and about 200 to 400 clock cycles for devices of compute capability 3.x.
       </li>
       <li class="li">
        The number of warps required to keep the warp schedulers busy during such high latency periods depends on the kernel code and its degree of instruction-level parallelism.
       </li>
       <li class="li">
        In general, more warps are required if the ratio of the number of instructions with no off-chip memory operands (i.e., arithmetic instructions most of the time) to the number of instructions with off-chip memory operands is low (this ratio is commonly called the arithmetic intensity of the program).
       </li>
       <li class="li">
        For example, assume this ratio is 30, also assume the latencies are 600 cycles on devices of compute capability 2.x and 300 cycles on devices of compute capability 3.x.
       </li>
       <li class="li">
        Then about 20 warps are required for devices of compute capability 2.x and about 40 for devices of compute capability 3.x (with the same assumptions as in the previous paragraph).
       </li>
       <li class="li">
        Another reason a warp is not ready to execute its next instruction is that it is waiting at some memory fence (Memory Fence Functions) or synchronization point (Memory Fence Functions).
       </li>
       <li class="li">
        A synchronization point can force the multiprocessor to idle as more and more warps wait for other warps in the same block to complete execution of instructions prior to the synchronization point.
       </li>
       <li class="li">
        Having multiple resident blocks per multiprocessor can help reduce idling in this case, as warps from different blocks do not need to wait for each other at synchronization points.
       </li>
       <li class="li">
        The number of blocks and warps residing on each multiprocessor for a given kernel call depends on the execution configuration of the call (Execution Configuration), the memory resources of the multiprocessor, and the resource requirements of the kernel as described in Hardware Multithreading.
       </li>
       <li class="li">
        Register and shared memory usage are reported by the compiler when compiling with the -ptxas-options=-v option.
       </li>
       <li class="li">
        The total amount of shared memory required for a block is equal to the sum of the amount of statically allocated shared memory and the amount of dynamically allocated shared memory.
       </li>
       <li class="li">
        The number of registers used by a kernel can have a significant impact on the number of resident warps.
       </li>
       <li class="li">
        For example, for devices of compute capability 2.x, if a kernel uses 32 registers and each block has 512 threads and requires very little shared memory, then two blocks (i.e., 32 warps) can reside on the multiprocessor since they require 2x512x32 registers, which exactly matches the number of registers available on the multiprocessor.
       </li>
       <li class="li">
        But as soon as the kernel uses one more register, only one block (i.e., 16 warps) can be resident since two blocks would require 2x512x17 registers, which are more registers than are available on the multiprocessor.
       </li>
       <li class="li">
        Therefore, the compiler attempts to minimize register usage while keeping register spilling (see Device Memory Accesses) and the number of instructions to a minimum.
       </li>
       <li class="li">
        Register usage can be controlled using the maxrregcount compiler option or launch bounds as described in Launch Bounds.
       </li>
       <li class="li">
        Each double variable and each long long variable uses two registers.
       </li>
       <li class="li">
        The effect of execution configuration on performance for a given kernel call generally depends on the kernel code.
       </li>
       <li class="li">
        Experimentation is therefore recommended.
       </li>
       <li class="li">
        Applications can also parameterize execution configurations based on register file size and shared memory size, which depends on the compute capability of the device, as well as on the number of multiprocessors and memory bandwidth of the device, all of which can be queried using the runtime (see reference manual).
       </li>
       <li class="li">
        The number of threads per block should be chosen as a multiple of the warp size to avoid wasting computing resources with under-populated warps as much as possible.
       </li>
      </ul>
     </div>
     <div class="topic concept nested4" id="occupancy-calculator" xml:lang="en-US">
      <a name="occupancy-calculator" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#occupancy-calculator" name="occupancy-calculator" shape="rect">
        5.2.3.1. Occupancy Calculator
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Several API functions exist to assist programmers in choosing thread block size based on register and shared memory requirements.
        </li>
        <li class="li">
         The occupancy calculator API, cudaOccupancyMaxActiveBlocksPerMultiprocessor, can provide an occupancy prediction based on the block size and shared memory usage of a kernel.
        </li>
        <li class="li">
         This function reports occupancy in terms of the number of concurrent thread blocks per multiprocessor.
        </li>
        <li class="li">
         Note that this value can be converted to other metrics.
        </li>
        <li class="li">
         Multiplying by the number of warps per block yields the number of concurrent warps per multiprocessor; further dividing concurrent warps by max warps per multiprocessor gives the occupancy as a percentage.
        </li>
        <li class="li">
         The occupancy-based launch configurator APIs, cudaOccupancyMaxPotentialBlockSize and cudaOccupancyMaxPotentialBlockSizeVariableSMem, heuristically calculate an execution configuration that achieves the maximum multiprocessor-level occupancy.
        </li>
        <li class="li">
         The following code sample calculates the occupancy of MyKernel.
        </li>
        <li class="li">
         It then reports the occupancy level with the ratio between concurrent warps versus maximum warps per multiprocessor.
        </li>
        <li class="li">
         The following code sample configures an occupancy-based kernel launch of MyKernel according to the user input.The CUDA Toolkit also provides a self-documenting, standalone occupancy calculator and launch configurator implementation in &lt;CUDA_Toolkit_Path&gt;/include/cuda_occupancy.h for any use cases that cannot depend on the CUDA software stack.
        </li>
        <li class="li">
         A spreadsheet version of the occupancy calculator is also provided.
        </li>
        <li class="li">
         The spreadsheet version is particularly useful as a learning tool that visualizes the impact of changes to the parameters that affect occupancy (block size, registers per thread, and shared memory per thread).
        </li>
       </ul>
      </div>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="maximize-memory-throughput" xml:lang="en-US">
    <a name="maximize-memory-throughput" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#maximize-memory-throughput" name="maximize-memory-throughput" shape="rect">
      5.3. Maximize Memory Throughput
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       The first step in maximizing overall memory throughput for the application is to minimize data transfers with low bandwidth.
      </li>
      <li class="li">
       That means minimizing data transfers between the host and the device, as detailed in Data Transfer between Host and Device, since these have much lower bandwidth than data transfers between global memory and the device.
      </li>
      <li class="li">
       That also means minimizing data transfers between global memory and the device by maximizing use of on-chip memory: shared memory and caches (i.e., L1 cache available on devices of compute capability 2.x and 3.x, L2 cache available on devices of compute capability 2.x and higher, texture cache and constant cache available on all devices).
      </li>
      <li class="li">
       Shared memory is equivalent to a user-managed cache: The application explicitly allocates and accesses it.
      </li>
      <li class="li">
       As illustrated in CUDA C Runtime, a typical programming pattern is to stage data coming from device memory into shared memory; in other words, to have each thread of a block: Load data from device memory to shared memory, Synchronize with all the other threads of the block so that each thread can safely read shared memory locations that were populated by different threads, Process the data in shared memory, Synchronize again if necessary to make sure that shared memory has been updated with the results, Write the results back to device memory.
      </li>
      <li class="li">
       For some applications (e.g., for which global memory access patterns are data-dependent), a traditional hardware-managed cache is more appropriate to exploit data locality.
      </li>
      <li class="li">
       As mentioned in Compute Capability 2.x and Compute Capability 3.x, for devices of compute capability 2.x and 3.x, the same on-chip memory is used for both L1 and shared memory, and how much of it is dedicated to L1 versus shared memory is configurable for each kernel call.
      </li>
      <li class="li">
       The throughput of memory accesses by a kernel can vary by an order of magnitude depending on access pattern for each type of memory.
      </li>
      <li class="li">
       The next step in maximizing memory throughput is therefore to organize memory accesses as optimally as possible based on the optimal memory access patterns described in Device Memory Accesses.
      </li>
      <li class="li">
       This optimization is especially important for global memory accesses as global memory bandwidth is low, so non-optimal global memory accesses have a higher impact on performance.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="data-transfer-between-host-and-device" xml:lang="en-US">
     <a name="data-transfer-between-host-and-device" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#data-transfer-between-host-and-device" name="data-transfer-between-host-and-device" shape="rect">
       5.3.1. Data Transfer between Host and Device
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Applications should strive to minimize data transfer between the host and the device.
       </li>
       <li class="li">
        One way to accomplish this is to move more code from the host to the device, even if that means running kernels with low parallelism computations.
       </li>
       <li class="li">
        Intermediate data structures may be created in device memory, operated on by the device, and destroyed without ever being mapped by the host or copied to host memory.
       </li>
       <li class="li">
        Also, because of the overhead associated with each transfer, batching many small transfers into a single large transfer always performs better than making each transfer separately.
       </li>
       <li class="li">
        On systems with a front-side bus, higher performance for data transfers between host and device is achieved by using page-locked host memory as described in Page-Locked Host Memory.
       </li>
       <li class="li">
        In addition, when using mapped page-locked memory (Mapped Memory), there is no need to allocate any device memory and explicitly copy data between device and host memory.
       </li>
       <li class="li">
        Data transfers are implicitly performed each time the kernel accesses the mapped memory.
       </li>
       <li class="li">
        For maximum performance, these memory accesses must be coalesced as with accesses to global memory (see Device Memory Accesses).
       </li>
       <li class="li">
        Assuming that they are and that the mapped memory is read or written only once, using mapped page-locked memory instead of explicit copies between device and host memory can be a win for performance.
       </li>
       <li class="li">
        On integrated systems where device memory and host memory are physically the same, any copy between host and device memory is superfluous and mapped page-locked memory should be used instead.
       </li>
       <li class="li">
        Applications may query a device is integrated by checking that the integrated device property (see Device Enumeration) is equal to 1.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="device-memory-accesses" xml:lang="en-US">
     <a name="device-memory-accesses" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#device-memory-accesses" name="device-memory-accesses" shape="rect">
       5.3.2. Device Memory Accesses
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        An instruction that accesses addressable memory (i.e., global, local, shared, constant, or texture memory) might need to be re-issued multiple times depending on the distribution of the memory addresses across the threads within the warp.
       </li>
       <li class="li">
        How the distribution affects the instruction throughput this way is specific to each type of memory and described in the following sections.
       </li>
       <li class="li">
        For example, for global memory, as a general rule, the more scattered the addresses are, the more reduced the throughput is.
       </li>
       <li class="li">
        Global memory resides in device memory and device memory is accessed via 32-, 64-, or 128-byte memory transactions.
       </li>
       <li class="li">
        These memory transactions must be naturally aligned: Only the 32-, 64-, or 128-byte segments of device memory that are aligned to their size (i.e., whose first address is a multiple of their size) can be read or written by memory transactions.
       </li>
       <li class="li">
        When a warp executes an instruction that accesses global memory, it coalesces the memory accesses of the threads within the warp into one or more of these memory transactions depending on the size of the word accessed by each thread and the distribution of the memory addresses across the threads.
       </li>
       <li class="li">
        In general, the more transactions are necessary, the more unused words are transferred in addition to the words accessed by the threads, reducing the instruction throughput accordingly.
       </li>
       <li class="li">
        For example, if a 32-byte memory transaction is generated for each thread's 4-byte access, throughput is divided by 8.
       </li>
       <li class="li">
        How many transactions are necessary and how much throughput is ultimately affected varies with the compute capability of the device.
       </li>
       <li class="li">
        Compute Capability 2.x, Compute Capability 3.x, Compute Capability 5.x and Compute Capability 6.x give more details on how global memory accesses are handled for various compute capabilities.
       </li>
       <li class="li">
        To maximize global memory throughput, it is therefore important to maximize coalescing by: Following the most optimal access patterns based on Compute Capability 2.x, Compute Capability 3.x , Compute Capability 5.x and Compute Capability 6.x, Using data types that meet the size and alignment requirement detailed in Device Memory Accesses, Padding data in some cases, for example, when accessing a two-dimensional array as described in Device Memory Accesses.
       </li>
       <li class="li">
        Global memory instructions support reading or writing words of size equal to 1, 2, 4, 8, or 16 bytes.
       </li>
       <li class="li">
        Any access (via a variable or a pointer) to data residing in global memory compiles to a single global memory instruction if and only if the size of the data type is 1, 2, 4, 8, or 16 bytes and the data is naturally aligned (i.e., its address is a multiple of that size).
       </li>
       <li class="li">
        If this size and alignment requirement is not fulfilled, the access compiles to multiple instructions with interleaved access patterns that prevent these instructions from fully coalescing.
       </li>
       <li class="li">
        It is therefore recommended to use types that meet this requirement for data that resides in global memory.
       </li>
       <li class="li">
        The alignment requirement is automatically fulfilled for the built-in types of char, short, int, long, longlong, float, double like float2 or float4.
       </li>
       <li class="li">
        For structures, the size and alignment requirements can be enforced by the compiler using the alignment specifiers __align__(8) or __align__(16), such as orAny address of a variable residing in global memory or returned by one of the memory allocation routines from the driver or runtime API is always aligned to at least 256 bytes.
       </li>
       <li class="li">
        Reading non-naturally aligned 8-byte or 16-byte words produces incorrect results (off by a few words), so special care must be taken to maintain alignment of the starting address of any value or array of values of these types.
       </li>
       <li class="li">
        A typical case where this might be easily overlooked is when using some custom global memory allocation scheme, whereby the allocations of multiple arrays (with multiple calls to cudaMalloc() or cuMemAlloc()) is replaced by the allocation of a single large block of memory partitioned into multiple arrays, in which case the starting address of each array is offset from the block's starting address.
       </li>
       <li class="li">
        A common global memory access pattern is when each thread of index (tx,ty) uses the following address to access one element of a 2D array of width width, located at address BaseAddress of type type* (where type meets the requirement described in Maximize Utilization): For these accesses to be fully coalesced, both the width of the thread block and the width of the array must be a multiple of the warp size.
       </li>
       <li class="li">
        In particular, this means that an array whose width is not a multiple of this size will be accessed much more efficiently if it is actually allocated with a width rounded up to the closest multiple of this size and its rows padded accordingly.
       </li>
       <li class="li">
        The cudaMallocPitch() and cuMemAllocPitch() functions and associated memory copy functions described in the reference manual enable programmers to write non-hardware-dependent code to allocate arrays that conform to these constraints.
       </li>
       <li class="li">
        Local memory accesses only occur for some automatic variables as mentioned in Variable Type Qualifiers.
       </li>
       <li class="li">
        Automatic variables that the compiler is likely to place in local memory are: Arrays for which it cannot determine that they are indexed with constant quantities, Large structures or arrays that would consume too much register space, Any variable if the kernel uses more registers than available (this is also known as register spilling).
       </li>
       <li class="li">
        Inspection of the PTX assembly code (obtained by compiling with the -ptx or-keep option) will tell if a variable has been placed in local memory during the first compilation phases as it will be declared using the .local mnemonic and accessed using the ld.local and st.local mnemonics.
       </li>
       <li class="li">
        Even if it has not, subsequent compilation phases might still decide otherwise though if they find it consumes too much register space for the targeted architecture: Inspection of the cubin object using cuobjdump will tell if this is the case.
       </li>
       <li class="li">
        Also, the compiler reports total local memory usage per kernel (lmem) when compiling with the --ptxas-options=-v option.
       </li>
       <li class="li">
        Note that some mathematical functions have implementation paths that might access local memory.
       </li>
       <li class="li">
        The local memory space resides in device memory, so local memory accesses have same high latency and low bandwidth as global memory accesses and are subject to the same requirements for memory coalescing as described in Device Memory Accesses.
       </li>
       <li class="li">
        Local memory is however organized such that consecutive 32-bit words are accessed by consecutive thread IDs.
       </li>
       <li class="li">
        Accesses are therefore fully coalesced as long as all threads in a warp access the same relative address (e.g., same index in an array variable, same member in a structure variable).
       </li>
       <li class="li">
        On devices of compute capability 2.x and 3.x, local memory accesses are always cached in L1 and L2 in the same way as global memory accesses (see Compute Capability 2.x and Compute Capability 3.x).
       </li>
       <li class="li">
        On devices of compute capability 5.x and 6.x, local memory accesses are always cached in L2 in the same way as global memory accesses (see Compute Capability 5.x and Compute Capability 6.x).
       </li>
       <li class="li">
        Because it is on-chip, shared memory has much higher bandwidth and much lower latency than local or global memory.
       </li>
       <li class="li">
        To achieve high bandwidth, shared memory is divided into equally-sized memory modules, called banks, which can be accessed simultaneously.
       </li>
       <li class="li">
        Any memory read or write request made of n addresses that fall in n distinct memory banks can therefore be serviced simultaneously, yielding an overall bandwidth that is n times as high as the bandwidth of a single module.
       </li>
       <li class="li">
        However, if two addresses of a memory request fall in the same memory bank, there is a bank conflict and the access has to be serialized.
       </li>
       <li class="li">
        The hardware splits a memory request with bank conflicts into as many separate conflict-free requests as necessary, decreasing throughput by a factor equal to the number of separate memory requests.
       </li>
       <li class="li">
        If the number of separate memory requests is n, the initial memory request is said to cause n-way bank conflicts.
       </li>
       <li class="li">
        To get maximum performance, it is therefore important to understand how memory addresses map to memory banks in order to schedule the memory requests so as to minimize bank conflicts.
       </li>
       <li class="li">
        This is described in Compute Capability 2.x, Compute Capability 3.x, Compute Capability 5.x, and Compute Capability 6.x for devices of compute capability 2.x, 3.x, 5.x and 6.x, respectively.
       </li>
       <li class="li">
        The constant memory space resides in device memory and is cached in the constant cache mentioned in Compute Capability 2.x.
       </li>
       <li class="li">
        A request is then split into as many separate requests as there are different memory addresses in the initial request, decreasing throughput by a factor equal to the number of separate requests.
       </li>
       <li class="li">
        The resulting requests are then serviced at the throughput of the constant cache in case of a cache hit, or at the throughput of device memory otherwise.
       </li>
       <li class="li">
        The texture and surface memory spaces reside in device memory and are cached in texture cache, so a texture fetch or surface read costs one memory read from device memory only on a cache miss, otherwise it just costs one read from texture cache.
       </li>
       <li class="li">
        The texture cache is optimized for 2D spatial locality, so threads of the same warp that read texture or surface addresses that are close together in 2D will achieve best performance.
       </li>
       <li class="li">
        Also, it is designed for streaming fetches with a constant latency; a cache hit reduces DRAM bandwidth demand but not fetch latency.
       </li>
       <li class="li">
        Reading device memory through texture or surface fetching present some benefits that can make it an advantageous alternative to reading device memory from global or constant memory: If the memory reads do not follow the access patterns that global or constant memory reads must follow to get good performance, higher bandwidth can be achieved providing that there is locality in the texture fetches or surface reads; Addressing calculations are performed outside the kernel by dedicated units; Packed data may be broadcast to separate variables in a single operation; 8-bit and 16-bit integer input data may be optionally converted to 32 bit floating-point values in the range [0.0, 1.0] or [-1.0, 1.0] (see Texture Memory).
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="maximize-instruction-throughput" xml:lang="en-US">
    <a name="maximize-instruction-throughput" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#maximize-instruction-throughput" name="maximize-instruction-throughput" shape="rect">
      5.4. Maximize Instruction Throughput
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       To maximize instruction throughput the application should: Minimize the use of arithmetic instructions with low throughput; this includes trading precision for speed when it does not affect the end result, such as using intrinsic instead of regular functions (intrinsic functions are listed in Intrinsic Functions), single-precision instead of double-precision, or flushing denormalized numbers to zero; Minimize divergent warps caused by control flow instructions as detailed in Control Flow Instructions Reduce the number of instructions, for example, by optimizing out synchronization points whenever possible as described in Synchronization Instruction or by using restricted pointers as described in __restrict__.
      </li>
      <li class="li">
       In this section, throughputs are given in number of operations per clock cycle per multiprocessor.
      </li>
      <li class="li">
       For a warp size of 32, one instruction corresponds to 32 operations, so if N is the number of operations per clock cycle, the instruction throughput is N/32 instructions per clock cycle.
      </li>
      <li class="li">
       All throughputs are for one multiprocessor.
      </li>
      <li class="li">
       They must be multiplied by the number of multiprocessors in the device to get throughput for the whole device.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="arithmetic-instructions" xml:lang="en-US">
     <a name="arithmetic-instructions" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#arithmetic-instructions" name="arithmetic-instructions" shape="rect">
       5.4.1. Arithmetic Instructions
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Table 2 gives the throughputs of the arithmetic instructions that are natively supported in hardware for devices of various compute capabilities.
       </li>
       <li class="li">
        Other instructions and functions are implemented on top of the native instructions.
       </li>
       <li class="li">
        The implementation may be different for devices of different compute capabilities, and the number of native instructions after compilation may fluctuate with every compiler version.
       </li>
       <li class="li">
        For complicated functions, there can be multiple code paths depending on input.
       </li>
       <li class="li">
        cuobjdump can be used to inspect a particular implementation in a cubin object.
       </li>
       <li class="li">
        The implementation of some functions are readily available on the CUDA header files (math_functions.h, device_functions.h, ...).
       </li>
       <li class="li">
        In general, code compiled with -ftz=true (denormalized numbers are flushed to zero) tends to have higher performance than code compiled with -ftz=false.
       </li>
       <li class="li">
        Similarly, code compiled with -prec div=false (less precise division) tends to have higher performance code than code compiled with -prec div=true, and code compiled with -prec-sqrt=false (less precise square root) tends to have higher performance than code compiled with -prec-sqrt=true.
       </li>
       <li class="li">
        The nvcc user manual describes these compilation flags in more details.
       </li>
       <li class="li">
        __fdividef(x, y) (see Intrinsic Functions) provides faster single-precision floating-point division than the division operator.
       </li>
       <li class="li">
        To preserve IEEE-754 semantics the compiler can optimize 1.0/sqrtf() into rsqrtf() only when both reciprocal and square root are approximate, (i.e., with -prec-div=false and -prec-sqrt=false).
       </li>
       <li class="li">
        It is therefore recommended to invoke rsqrtf() directly where desired.
       </li>
       <li class="li">
        Single-precision floating-point square root is implemented as a reciprocal square root followed by a reciprocal instead of a reciprocal square root followed by a multiplication so that it gives correct results for 0 and infinity.
       </li>
       <li class="li">
        sinf(x), cosf(x), tanf(x), sincosf(x), and corresponding double-precision instructions are much more expensive and even more so if the argument x is large in magnitude.
       </li>
       <li class="li">
        More precisely, the argument reduction code (see Mathematical Functions for implementation) comprises two code paths referred to as the fast path and the slow path, respectively.
       </li>
       <li class="li">
        The fast path is used for arguments sufficiently small in magnitude and essentially consists of a few multiply-add operations.
       </li>
       <li class="li">
        The slow path is used for arguments large in magnitude and consists of lengthy computations required to achieve correct results over the entire argument range.
       </li>
       <li class="li">
        At present, the argument reduction code for the trigonometric functions selects the fast path for arguments whose magnitude is less than 105615.0f for the single-precision functions, and less than 2147483648.0 for the double-precision functions.
       </li>
       <li class="li">
        As the slow path requires more registers than the fast path, an attempt has been made to reduce register pressure in the slow path by storing some intermediate variables in local memory, which may affect performance because of local memory high latency and bandwidth (see Device Memory Accesses).
       </li>
       <li class="li">
        At present, 28 bytes of local memory are used by single-precision functions, and 44 bytes are used by double-precision functions.
       </li>
       <li class="li">
        However, the exact amount is subject to change.
       </li>
       <li class="li">
        Due to the lengthy computations and use of local memory in the slow path, the throughput of these trigonometric functions is lower by one order of magnitude when the slow path reduction is required as opposed to the fast path reduction.
       </li>
       <li class="li">
        Integer division and modulo operation are costly as they compiler to up to 20 instructions.
       </li>
       <li class="li">
        They can be replaced with bitwise operations in some cases: If n is a power of 2, (i/n) is equivalent to (i&gt;&gt;log2(n)) and (i%n) is equivalent to (i&amp;(n-1)); the compiler will perform these conversions if n is literal.
       </li>
       <li class="li">
        __brev and __popc map to a single instruction and __brevll and __popcll to a few instructions.
       </li>
       <li class="li">
        __[u]mul24 are legacy intrinsic functions that have no longer any reason to be used.
       </li>
       <li class="li">
        Sometimes, the compiler must insert conversion instructions, introducing additional execution cycles.
       </li>
       <li class="li">
        This is the case for: Functions operating on variables of type char or short whose operands generally need to be converted to int, Double-precision floating-point constants (i.e., those constants defined without any type suffix) used as input to single-precision floating-point computations (as mandated by C/C++ standards).
       </li>
       <li class="li">
        This last case can be avoided by using single-precision floating-point constants, defined with an f suffix such as 3.141592653589793f, 1.0f, 0.5f.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="control-flow-instructions" xml:lang="en-US">
     <a name="control-flow-instructions" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#control-flow-instructions" name="control-flow-instructions" shape="rect">
       5.4.2. Control Flow Instructions
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Any flow control instruction (if, switch, do, for, while) can significantly impact the effective instruction throughput by causing threads of the same warp to diverge (i.e., to follow different execution paths).
       </li>
       <li class="li">
        If this happens, the different executions paths have to be serialized, increasing the total number of instructions executed for this warp.
       </li>
       <li class="li">
        When all the different execution paths have completed, the threads converge back to the same execution path.
       </li>
       <li class="li">
        To obtain best performance in cases where the control flow depends on the thread ID, the controlling condition should be written so as to minimize the number of divergent warps.
       </li>
       <li class="li">
        This is possible because the distribution of the warps across the block is deterministic as mentioned in SIMT Architecture.
       </li>
       <li class="li">
        A trivial example is when the controlling condition only depends on (threadIdx / warpSize) where warpSize is the warp size.
       </li>
       <li class="li">
        In this case, no warp diverges since the controlling condition is perfectly aligned with the warps.
       </li>
       <li class="li">
        Sometimes, the compiler may unroll loops or it may optimize out if or switch statements by using branch predication instead, as detailed below.
       </li>
       <li class="li">
        In these cases, no warp can ever diverge.
       </li>
       <li class="li">
        The programmer can also control loop unrolling using the #pragma unroll directive (see #pragma unroll).
       </li>
       <li class="li">
        When using branch predication none of the instructions whose execution depends on the controlling condition gets skipped.
       </li>
       <li class="li">
        Instead, each of them is associated with a per-thread condition code or predicate that is set to true or false based on the controlling condition and although each of these instructions gets scheduled for execution, only the instructions with a true predicate are actually executed.
       </li>
       <li class="li">
        Instructions with a false predicate do not write results, and also do not evaluate addresses or read operands.
       </li>
       <li class="li">
        The compiler replaces a branch instruction with predicated instructions only if the number of instructions controlled by the branch condition is less or equal to a certain threshold: If the compiler determines that the condition is likely to produce many divergent warps, this threshold is 7, otherwise it is 4.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="synchronization-instruction" xml:lang="en-US">
     <a name="synchronization-instruction" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#synchronization-instruction" name="synchronization-instruction" shape="rect">
       5.4.3. Synchronization Instruction
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Throughput for __syncthreads() is 16 operations per clock cycle for devices of compute capability 2.x, 128 operations per clock cycle for devices of compute capability 3.x, 32 operations per clock cycle for devices of compute capability 6.0 and 64 operations per clock cycle for devices of compute capability 5.x, 6.1 and 6.2.
       </li>
       <li class="li">
        Note that __syncthreads() can impact performance by forcing the multiprocessor to idle as detailed in Device Memory Accesses.
       </li>
      </ul>
     </div>
    </div>
   </div>
  </div>
  <div class="topic concept nested1" id="cuda-enabled-gpus" xml:lang="en-US">
   <a name="cuda-enabled-gpus" shape="rect">
   </a>
   <h2 class="title topictitle1">
    <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#cuda-enabled-gpus" name="cuda-enabled-gpus" shape="rect">
     A. CUDA-Enabled GPUs
    </a>
   </h2>
   <div class="body conbody">
    <ul class="ul">
     <li class="li">
      http://developer.nvidia.com/cuda-gpus lists all CUDA-enabled devices with their compute capability.
     </li>
     <li class="li">
      The compute capability, number of multiprocessors, clock frequency, total amount of device memory, and other properties can be queried using the runtime (see reference manual).
     </li>
    </ul>
   </div>
  </div>
  <div class="topic concept nested1" id="c-language-extensions" xml:lang="en-US">
   <a name="c-language-extensions" shape="rect">
   </a>
   <h2 class="title topictitle1">
    <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#c-language-extensions" name="c-language-extensions" shape="rect">
     B. C Language Extensions
    </a>
   </h2>
   <div class="topic concept nested2" id="function-type-qualifiers" xml:lang="en-US">
    <a name="function-type-qualifiers" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#function-type-qualifiers" name="function-type-qualifiers" shape="rect">
      B.1. Function Type Qualifiers
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       Function type qualifiers specify whether a function executes on the host or on the device and whether it is callable from the host or from the device.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="device-function-qualifier" xml:lang="en-US">
     <a name="device-function-qualifier" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#device-function-qualifier" name="device-function-qualifier" shape="rect">
       B.1.1. __device__
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The __device__ qualifier declares a function that is: Executed on the device, Callable from the device only.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="global" xml:lang="en-US">
     <a name="global" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#global" name="global" shape="rect">
       B.1.2. __global__
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The __global__ qualifier declares a function as being a kernel.
       </li>
       <li class="li">
        Such a function is: Executed on the device, Callable from the host, Callable from the device for devices of compute capability 3.2 or higher (see CUDA Dynamic Parallelism for more details).
       </li>
       <li class="li">
        __global__ functions must have void return type.
       </li>
       <li class="li">
        Any call to a __global__ function must specify its execution configuration as described in Execution Configuration.
       </li>
       <li class="li">
        A call to a __global__ function is asynchronous, meaning it returns before the device has completed its execution.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="host" xml:lang="en-US">
     <a name="host" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#host" name="host" shape="rect">
       B.1.3. __host__
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The __host__ qualifier declares a function that is: Executed on the host, Callable from the host only.
       </li>
       <li class="li">
        It is equivalent to declare a function with only the __host__ qualifier or to declare it without any of the __host__, __device__, or __global__ qualifier; in either case the function is compiled for the host only.
       </li>
       <li class="li">
        The __global__ and __host__ qualifiers cannot be used together.
       </li>
       <li class="li">
        The __device__ and __host__ qualifiers can be used together however, in which case the function is compiled for both the host and the device.
       </li>
       <li class="li">
        The __CUDA_ARCH__ macro introduced in Application Compatibility can be used to differentiate code paths between host and device:
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="noinline-and-forceinline" xml:lang="en-US">
     <a name="noinline-and-forceinline" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#noinline-and-forceinline" name="noinline-and-forceinline" shape="rect">
       B.1.4. __noinline__ and __forceinline__
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The compiler inlines any __device__ function when deemed appropriate.
       </li>
       <li class="li">
        The __noinline__ function qualifier can be used as a hint for the compiler not to inline the function if possible.
       </li>
       <li class="li">
        The function body must still be in the same file where it is called.
       </li>
       <li class="li">
        The __forceinline__ function qualifier can be used to force the compiler to inline the function.
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="variable-type-qualifiers" xml:lang="en-US">
    <a name="variable-type-qualifiers" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#variable-type-qualifiers" name="variable-type-qualifiers" shape="rect">
      B.2. Variable Type Qualifiers
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       Variable type qualifiers specify the memory location on the device of a variable.
      </li>
      <li class="li">
       An automatic variable declared in device code without any of the __device__, __shared__ and __constant__ qualifiers described in this section generally resides in a register.
      </li>
      <li class="li">
       However in some cases the compiler might choose to place it in local memory, which can have adverse performance consequences as detailed in Device Memory Accesses.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="device-variable-qualifier" xml:lang="en-US">
     <a name="device-variable-qualifier" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#device-variable-qualifier" name="device-variable-qualifier" shape="rect">
       B.2.1. __device__
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The __device__ qualifier declares a variable that resides on the device.
       </li>
       <li class="li">
        At most one of the other type qualifiers defined in the next two sections may be used together with __device__ to further specify which memory space the variable belongs to.
       </li>
       <li class="li">
        If none of them is present, the variable: Resides in global memory space.
       </li>
       <li class="li">
        Has the lifetime of an application.
       </li>
       <li class="li">
        Is accessible from all the threads within the grid and from the host through the runtime library (cudaGetSymbolAddress() / cudaGetSymbolSize() / cudaMemcpyToSymbol() / cudaMemcpyFromSymbol()).
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="constant" xml:lang="en-US">
     <a name="constant" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#constant" name="constant" shape="rect">
       B.2.2. __constant__
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The __constant__ qualifier, optionally used together with __device__, declares a variable that: Resides in constant memory space, Has the lifetime of an application, Is accessible from all the threads within the grid and from the host through the runtime library (cudaGetSymbolAddress() / cudaGetSymbolSize() / cudaMemcpyToSymbol() / cudaMemcpyFromSymbol()).
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="shared" xml:lang="en-US">
     <a name="shared" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#shared" name="shared" shape="rect">
       B.2.3. __shared__
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The __shared__ qualifier, optionally used together with __device__, declares a variable that: Resides in the shared memory space of a thread block, Has the lifetime of the block, Is only accessible from all the threads within the block.
       </li>
       <li class="li">
        When declaring a variable in shared memory as an external array such as the size of the array is determined at launch time (see Execution Configuration).
       </li>
       <li class="li">
        All variables declared in this fashion, start at the same address in memory, so that the layout of the variables in the array must be explicitly managed through offsets.
       </li>
       <li class="li">
        For example, if one wants the equivalent of in dynamically allocated shared memory, one could declare and initialize the arrays the following way:Note that pointers need to be aligned to the type they point to, so the following code, for example, does not work since array1 is not aligned to 4 bytes.
       </li>
       <li class="li">
        Alignment requirements for the built-in vector types are listed in Table 3.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="managed" xml:lang="en-US">
     <a name="managed" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#managed" name="managed" shape="rect">
       B.2.4. __managed__
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The __managed__ qualifier, optionally used together with __device__, declares a variable that: Can be referenced from both device and host code, e.g., its address can be taken or it can be read or written directly from a device or host function.
       </li>
       <li class="li">
        Has the lifetime of an application.
       </li>
       <li class="li">
        See __managed__ Qualifier for more details.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="restrict" xml:lang="en-US">
     <a name="restrict" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#restrict" name="restrict" shape="rect">
       B.2.5. __restrict__
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        nvcc supports restricted pointers via the __restrict__ keyword.
       </li>
       <li class="li">
        Restricted pointers were introduced in C99 to alleviate the aliasing problem that exists in C-type languages, and which inhibits all kind of optimization from code re-ordering to common sub-expression elimination.
       </li>
       <li class="li">
        Here is an example subject to the aliasing issue, where use of restricted pointer can help the compiler to reduce the number of instructions: In C-type languages, the pointers a, b, and c may be aliased, so any write through c could modify elements of a or b.
       </li>
       <li class="li">
        This means that to guarantee functional correctness, the compiler cannot load a[0] and b[0] into registers, multiply them, and store the result to both c[0] and c[1], because the results would differ from the abstract execution model if, say, a[0] is really the same location as c[0].
       </li>
       <li class="li">
        So the compiler cannot take advantage of the common sub-expression.
       </li>
       <li class="li">
        Likewise, the compiler cannot just reorder the computation of c[4] into the proximity of the computation of c[0] and c[1] because the preceding write to c[3] could change the inputs to the computation of c[4].
       </li>
       <li class="li">
        By making a, b, and c restricted pointers, the programmer asserts to the compiler that the pointers are in fact not aliased, which in this case means writes through c would never overwrite elements of a or b.
       </li>
       <li class="li">
        This changes the function prototype as follows: Note that all pointer arguments need to be made restricted for the compiler optimizer to derive any benefit.
       </li>
       <li class="li">
        With the __restrict__ keywords added, the compiler can now reorder and do common sub-expression elimination at will, while retaining functionality identical with the abstract execution model: The effects here are a reduced number of memory accesses and reduced number of computations.
       </li>
       <li class="li">
        This is balanced by an increase in register pressure due to "cached" loads and common sub-expressions.
       </li>
       <li class="li">
        Since register pressure is a critical issue in many CUDA codes, use of restricted pointers can have negative performance impact on CUDA code, due to reduced occupancy.
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="built-in-vector-types" xml:lang="en-US">
    <a name="built-in-vector-types" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#built-in-vector-types" name="built-in-vector-types" shape="rect">
      B.3. Built-in Vector Types
     </a>
    </h3>
    <div class="topic concept nested3" id="vector-types" xml:lang="en-US">
     <a name="vector-types" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#vector-types" name="vector-types" shape="rect">
       B.3.1. char, short, int, long, longlong, float, double
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        These are vector types derived from the basic integer and floating-point types.
       </li>
       <li class="li">
        They are structures and the 1st, 2nd, 3rd, and 4th components are accessible through the fields x, y, z, and w, respectively.
       </li>
       <li class="li">
        They all come with a constructor function of the form make_&lt;type name&gt;; for example, which creates a vector of type int2 with value(x, y).
       </li>
       <li class="li">
        In host code, the alignment requirement of a vector type is equal to the alignment requirement of its base type.
       </li>
       <li class="li">
        This is not always the case in device code as detailed in Table 3.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="dim3" xml:lang="en-US">
     <a name="dim3" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#dim3" name="dim3" shape="rect">
       B.3.2. dim3
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        This type is an integer vector type based on uint3 that is used to specify dimensions.
       </li>
       <li class="li">
        When defining a variable of type dim3, any component left unspecified is initialized to 1.
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="built-in-variables" xml:lang="en-US">
    <a name="built-in-variables" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#built-in-variables" name="built-in-variables" shape="rect">
      B.4. Built-in Variables
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       Built-in variables specify the grid and block dimensions and the block and thread indices.
      </li>
      <li class="li">
       They are only valid within functions that are executed on the device.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="griddim" xml:lang="en-US">
     <a name="griddim" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#griddim" name="griddim" shape="rect">
       B.4.1. gridDim
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        This variable is of type dim3 (see dim3) and contains the dimensions of the grid.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="blockidx" xml:lang="en-US">
     <a name="blockidx" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#blockidx" name="blockidx" shape="rect">
       B.4.2. blockIdx
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        This variable is of type uint3 (see char, short, int, long, longlong, float, double) and contains the block index within the grid.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="blockdim" xml:lang="en-US">
     <a name="blockdim" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#blockdim" name="blockdim" shape="rect">
       B.4.3. blockDim
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        This variable is of type dim3 (see dim3) and contains the dimensions of the block.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="threadidx" xml:lang="en-US">
     <a name="threadidx" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#threadidx" name="threadidx" shape="rect">
       B.4.4. threadIdx
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        This variable is of type uint3 (see char, short, int, long, longlong, float, double ) and contains the thread index within the block.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="warpsize" xml:lang="en-US">
     <a name="warpsize" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#warpsize" name="warpsize" shape="rect">
       B.4.5. warpSize
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        This variable is of type int and contains the warp size in threads (see SIMT Architecture for the definition of a warp).
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="memory-fence-functions" xml:lang="en-US">
    <a name="memory-fence-functions" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#memory-fence-functions" name="memory-fence-functions" shape="rect">
      B.5. Memory Fence Functions
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       The CUDA programming model assumes a device with a weakly-ordered memory model, that is: The order in which a CUDA thread writes data to shared memory, global memory, page-locked host memory, or the memory of a peer device is not necessarily the order in which the data is observed being written by another CUDA or host thread; The order in which a CUDA thread reads data from shared memory, global memory, page-locked host memory, or the memory of a peer device is not necessarily the order in which the read instructions appear in the program for instructions that are independent of each other.
      </li>
      <li class="li">
       For example, if thread 1 executes writeXY() and thread 2 executes readXY() as defined in the following code sample it is possible that B ends up equal to 2 and A equal to 10 for thread 2: either because at the time thread 2 reads X and Y, thread 1's write to X has happened from thread 2's perspective, but thread 1's write to Y has not, or because thread 2 reads Y before X and thread 1's writes to X and Y happen after thread 2's read of Y and before thread 2's read of X.
      </li>
      <li class="li">
       In a strongly-ordered memory model, the only possibilities would be: A equal to 1 and B equal to 2 (thread 1's writes to X and Y happen after thread 2's read of X and Y), A equal to 10 and B equal to 2 (thread 1's write to X happens before thread 2's read of X and thread 1's write to Y happens after thread 2's read of Y), A equal to 10 and B equal to 20 (thread 1's writes to X and Y happen before thread 2's read of X and Y), Memory fence functions can be used to enforce some ordering.
      </li>
      <li class="li">
       ensures that: All writes to shared and global memory made by the calling thread before the call to __threadfence_block() are observed by all threads in the block of the calling thread as occurring before all writes to shared memory and global memory made by the calling thread after the call to __threadfence_block(); All reads from shared memory and global memory made by the calling thread before the call to __threadfence_block() are performed before all reads from shared memory and global memory made by the calling thread after the call to __threadfence_block().
      </li>
      <li class="li">
       acts as __threadfence_block() for all threads in the block of the calling thread and also ensures that no writes to global memory made by the calling thread after the call to __threadfence() are observed by any thread in the device as occurring before any write to global memory made by the calling thread before the call to __threadfence().
      </li>
      <li class="li">
       Note that for this ordering guarantee to be true, the observing threads must truly observe global memory and not cached versions of it; this is ensured by using the volatile keyword as detailed in Volatile Qualifier.
      </li>
      <li class="li">
       acts as __threadfence_block() for all threads in the block of the calling thread and also ensures that: All writes to global memory, page-locked host memory, and the memory of a peer device made by the calling thread before the call to __threadfence_system() are observed by all threads in the device, host threads, and all threads in peer devices as occurring before all writes to global memory, page-locked host memory, and the memory of a peer device made by the calling thread after the call to __threadfence_system().
      </li>
      <li class="li">
       All reads from shared memory, global memory, page-locked host memory, and the memory of a peer device made by the calling thread before the call to __threadfence_system() are performed before all reads from shared memory, global memory, page-locked host memory, and the memory of a peer device made by the calling thread after the call to __threadfence_system().
      </li>
      <li class="li">
       __threadfence_system() is only supported by devices of compute capability 2.x and higher.
      </li>
      <li class="li">
       In the previous code sample, inserting a fence function call between X = 10; and Y = 20; and between int A = X; and int B = Y; would ensure that for thread 1, A will always be equal to 10 if B is equal to 20.
      </li>
      <li class="li">
       If thread 1 and 2 belong to the same block, it is enough to use __threadfence_block().
      </li>
      <li class="li">
       If thread 1 and 2 do not belong to the same block, __threadfence() must be used if they are CUDA threads from the same device and __threadfence_system() must be used if they are CUDA threads from two different devices.
      </li>
      <li class="li">
       A common use case is when threads consume some data produced by other threads as illustrated by the following code sample of a kernel that computes the sum of an array of N numbers in one call.
      </li>
      <li class="li">
       Each block first sums a subset of the array and stores the result in global memory.
      </li>
      <li class="li">
       When all blocks are done, the last block done reads each of these partial sums from global memory and sums them to obtain the final result.
      </li>
      <li class="li">
       In order to determine which block is finished last, each block atomically increments a counter to signal that it is done with computing and storing its partial sum (see Atomic Functions about atomic functions).
      </li>
      <li class="li">
       The last block is the one that receives the counter value equal to gridDim.x-1.
      </li>
      <li class="li">
       If no fence is placed between storing the partial sum and incrementing the counter, the counter might increment before the partial sum is stored and therefore, might reach gridDim.x-1 and let the last block start reading partial sums before they have been actually updated in memory.
      </li>
      <li class="li">
       Memory fence functions only affect the ordering of memory operations by a thread; they do not ensure that these memory operations are visible to other threads (like __syncthreads() does for threads within a block (see Synchronization Functions)).
      </li>
      <li class="li">
       In the code sample below, the visibility of memory operations on the result variable is ensured by declaring it as volatile (see Volatile Qualifier).
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="synchronization-functions" xml:lang="en-US">
    <a name="synchronization-functions" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#synchronization-functions" name="synchronization-functions" shape="rect">
      B.6. Synchronization Functions
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       waits until all threads in the thread block have reached this point and all global and shared memory accesses made by these threads prior to __syncthreads() are visible to all threads in the block.
      </li>
      <li class="li">
       __syncthreads() is used to coordinate communication between the threads of the same block.
      </li>
      <li class="li">
       When some threads within a block access the same addresses in shared or global memory, there are potential read-after-write, write-after-read, or write-after-write hazards for some of these memory accesses.
      </li>
      <li class="li">
       These data hazards can be avoided by synchronizing threads in-between these accesses.
      </li>
      <li class="li">
       __syncthreads() is allowed in conditional code but only if the conditional evaluates identically across the entire thread block, otherwise the code execution is likely to hang or produce unintended side effects.
      </li>
      <li class="li">
       Devices of compute capability 2.x and higher support three variations of __syncthreads() described below.
      </li>
      <li class="li">
       is identical to __syncthreads() with the additional feature that it evaluates predicate for all threads of the block and returns the number of threads for which predicate evaluates to non-zero.
      </li>
      <li class="li">
       is identical to __syncthreads() with the additional feature that it evaluates predicate for all threads of the block and returns non-zero if and only if predicate evaluates to non-zero for all of them.
      </li>
      <li class="li">
       is identical to __syncthreads() with the additional feature that it evaluates predicate for all threads of the block and returns non-zero if and only if predicate evaluates to non-zero for any of them.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="mathematical-functions" xml:lang="en-US">
    <a name="mathematical-functions" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#mathematical-functions" name="mathematical-functions" shape="rect">
      B.7. Mathematical Functions
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       The reference manual lists all C/C++ standard library mathematical functions that are supported in device code and all intrinsic functions that are only supported in device code.
      </li>
      <li class="li">
       Mathematical Functions provides accuracy information for some of these functions when relevant.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="texture-functions" xml:lang="en-US">
    <a name="texture-functions" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#texture-functions" name="texture-functions" shape="rect">
      B.8. Texture Functions
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       Texture objects are described in Texture Object API Texture references are described in Texture Reference API Texture fetching is described in Texture Fetching.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="texture-object-api-appendix" xml:lang="en-US">
     <a name="texture-object-api-appendix" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#texture-object-api-appendix" name="texture-object-api-appendix" shape="rect">
       B.8.1. Texture Object API
      </a>
     </h3>
     <div class="topic concept nested4" id="tex1dfetch-object" xml:lang="en-US">
      <a name="tex1dfetch-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex1dfetch-object" name="tex1dfetch-object" shape="rect">
        B.8.1.1. tex1Dfetch()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the region of linear memory specified by the one-dimensional texture object texObj using integer texture coordinate x. tex1Dfetch() only works with non-normalized coordinates, so only the border and clamp addressing modes are supported.
        </li>
        <li class="li">
         It does not perform any texture filtering.
        </li>
        <li class="li">
         For integer types, it may optionally promote the integer to single-precision floating point.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex1d-object" xml:lang="en-US">
      <a name="tex1d-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex1d-object" name="tex1d-object" shape="rect">
        B.8.1.2. tex1D()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array specified by the one-dimensional texture object texObj using texture coordinate x.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex1dlod-object" xml:lang="en-US">
      <a name="tex1dlod-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex1dlod-object" name="tex1dlod-object" shape="rect">
        B.8.1.3. tex1DLod()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array specified by the one-dimensional texture object texObj using texture coordinate x at the level-of-detail level.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex1dgrad-object" xml:lang="en-US">
      <a name="tex1dgrad-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex1dgrad-object" name="tex1dgrad-object" shape="rect">
        B.8.1.4. tex1DGrad()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array specified by the one-dimensional texture object texObj using texture coordinate x.
        </li>
        <li class="li">
         The level-of-detail is derived from the X-gradient dx and Y-gradient dy.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex2d-object" xml:lang="en-US">
      <a name="tex2d-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex2d-object" name="tex2d-object" shape="rect">
        B.8.1.5. tex2D()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array or the region of linear memory specified by the two-dimensional texture object texObj using texture coordinate (x,y).
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex2dlod-object" xml:lang="en-US">
      <a name="tex2dlod-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex2dlod-object" name="tex2dlod-object" shape="rect">
        B.8.1.6. tex2DLod()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array or the region of linear memory specified by the two-dimensional texture object texObj using texture coordinate (x,y) at level-of-detail level.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex2dgrad-object" xml:lang="en-US">
      <a name="tex2dgrad-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex2dgrad-object" name="tex2dgrad-object" shape="rect">
        B.8.1.7. tex2DGrad()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array specified by the two-dimensional texture object texObj using texture coordinate (x,y).
        </li>
        <li class="li">
         The level-of-detail is derived from the dx and dy gradients.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex3d-object" xml:lang="en-US">
      <a name="tex3d-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex3d-object" name="tex3d-object" shape="rect">
        B.8.1.8. tex3D()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array specified by the three-dimensional texture object texObj using texture coordinate (x,y,z).
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex3dlod-object" xml:lang="en-US">
      <a name="tex3dlod-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex3dlod-object" name="tex3dlod-object" shape="rect">
        B.8.1.9. tex3DLod()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array or the region of linear memory specified by the three-dimensional texture object texObj using texture coordinate (x,y,z) at level-of-detail level.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex3dgrad-object" xml:lang="en-US">
      <a name="tex3dgrad-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex3dgrad-object" name="tex3dgrad-object" shape="rect">
        B.8.1.10. tex3DGrad()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array specified by the three-dimensional texture object texObj using texture coordinate (x,y,z) at a level-of-detail derived from the X and Y gradients dx and dy.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex1dlayered-object" xml:lang="en-US">
      <a name="tex1dlayered-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex1dlayered-object" name="tex1dlayered-object" shape="rect">
        B.8.1.11. tex1DLayered()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array specified by the one-dimensional texture object texObj using texture coordinate x and index layer, as described in Layered Textures
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex1dlayeredlod-object" xml:lang="en-US">
      <a name="tex1dlayeredlod-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex1dlayeredlod-object" name="tex1dlayeredlod-object" shape="rect">
        B.8.1.12. tex1DLayeredLod()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array specified by the one-dimensional layered texture at layer layer using texture coordinate x and level-of-detail level.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex1dlayeredgrad-object" xml:lang="en-US">
      <a name="tex1dlayeredgrad-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex1dlayeredgrad-object" name="tex1dlayeredgrad-object" shape="rect">
        B.8.1.13. tex1DLayeredGrad()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array specified by the one-dimensional layered texture at layer layer using texture coordinate x and a level-of-detail derived from the dx and dy gradients.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex2dlayered-object" xml:lang="en-US">
      <a name="tex2dlayered-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex2dlayered-object" name="tex2dlayered-object" shape="rect">
        B.8.1.14. tex2DLayered()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array specified by the two-dimensional texture object texObj using texture coordinate (x,y) and index layer, as described in Layered Textures.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex2dlayeredlod-object" xml:lang="en-US">
      <a name="tex2dlayeredlod-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex2dlayeredlod-object" name="tex2dlayeredlod-object" shape="rect">
        B.8.1.15. tex2DLayeredLod()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array specified by the two-dimensional layered texture at layer layer using texture coordinate (x,y).
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex2dlayeredgrad-object" xml:lang="en-US">
      <a name="tex2dlayeredgrad-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex2dlayeredgrad-object" name="tex2dlayeredgrad-object" shape="rect">
        B.8.1.16. tex2DLayeredGrad()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array specified by the two-dimensional layered texture at layer layer using texture coordinate (x,y) and a level-of-detail derived from the dx and dy X and Y gradients.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="texcubemap-object" xml:lang="en-US">
      <a name="texcubemap-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#texcubemap-object" name="texcubemap-object" shape="rect">
        B.8.1.17. texCubemap()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches the CUDA array specified by the three-dimensional texture object texObj using texture coordinate (x,y,z), as described in Cubemap Textures.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="texcubemaplod-object" xml:lang="en-US">
      <a name="texcubemaplod-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#texcubemaplod-object" name="texcubemaplod-object" shape="rect">
        B.8.1.18. texCubemapLod()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array specified by the three-dimensional texture object texObj using texture coordinate (x,y,z) as described in Cubemap Textures.
        </li>
        <li class="li">
         The level-of-detail used is given by level.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="texcubemaplayered-object" xml:lang="en-US">
      <a name="texcubemaplayered-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#texcubemaplayered-object" name="texcubemaplayered-object" shape="rect">
        B.8.1.19. texCubemapLayered()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array specified by the cubemap layered texture object texObj using texture coordinates (x,y,z), and index layer, as described in Cubemap Layered Textures.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="texcubemaplayeredlod-object" xml:lang="en-US">
      <a name="texcubemaplayeredlod-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#texcubemaplayeredlod-object" name="texcubemaplayeredlod-object" shape="rect">
        B.8.1.20. texCubemapLayeredLod()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array specified by the cubemap layered texture object texObj using texture coordinate (x,y,z) and index layer, as described in Cubemap Layered Textures, at level-of-detail level level.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex2dgather-object" xml:lang="en-US">
      <a name="tex2dgather-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex2dgather-object" name="tex2dgather-object" shape="rect">
        B.8.1.21. tex2Dgather()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array specified by the 2D texture object texObj using texture coordinates x and y and the comp parameter as described in Texture Gather.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="texture-reference-api-appendix" xml:lang="en-US">
     <a name="texture-reference-api-appendix" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#texture-reference-api-appendix" name="texture-reference-api-appendix" shape="rect">
       B.8.2. Texture Reference API
      </a>
     </h3>
     <div class="topic concept nested4" id="tex1dfetch" xml:lang="en-US">
      <a name="tex1dfetch" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex1dfetch" name="tex1dfetch" shape="rect">
        B.8.2.1. tex1Dfetch()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the region of linear memory bound to the one-dimensional texture reference texRef using integer texture coordinate x. tex1Dfetch() only works with non-normalized coordinates, so only the border and clamp addressing modes are supported.
        </li>
        <li class="li">
         It does not perform any texture filtering.
        </li>
        <li class="li">
         For integer types, it may optionally promote the integer to single-precision floating point.
        </li>
        <li class="li">
         Besides the functions shown above, 2-, and 4-tuples are supported; for example: fetches from the region of linear memory bound to texture reference texRef using texture coordinate x.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex1d" xml:lang="en-US">
      <a name="tex1d" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex1d" name="tex1d" shape="rect">
        B.8.2.2. tex1D()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array bound to the one-dimensional texture reference texRef using texture coordinate x.
        </li>
        <li class="li">
         Type is equal to DataType except when readMode is equal to cudaReadModeNormalizedFloat (see Texture Reference API), in which case Type is equal to the matching floating-point type.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex1dlod" xml:lang="en-US">
      <a name="tex1dlod" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex1dlod" name="tex1dlod" shape="rect">
        B.8.2.3. tex1DLod()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array bound to the one-dimensional texture reference texRef using texture coordinate x.
        </li>
        <li class="li">
         The level-of-detail is given by level.
        </li>
        <li class="li">
         Type is the same as DataType except when readMode is cudaReadModeNormalizedFloat (see Texture Reference API), in which case Type is the corresponding floating-point type.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex1dgrad" xml:lang="en-US">
      <a name="tex1dgrad" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex1dgrad" name="tex1dgrad" shape="rect">
        B.8.2.4. tex1DGrad()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array bound to the one-dimensional texture reference texRef using texture coordinate x.
        </li>
        <li class="li">
         The level-of-detail is derived from the dx and dy X- and Y-gradients.
        </li>
        <li class="li">
         Type is the same as DataType except when readMode is cudaReadModeNormalizedFloat (see Texture Reference API), in which case Type is the corresponding floating-point type.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex2d" xml:lang="en-US">
      <a name="tex2d" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex2d" name="tex2d" shape="rect">
        B.8.2.5. tex2D()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array or the region of linear memory bound to the two-dimensional texture reference texRef using texture coordinates x and y.
        </li>
        <li class="li">
         Type is equal to DataType except when readMode is equal to cudaReadModeNormalizedFloat (see Texture Reference API), in which case Type is equal to the matching floating-point type.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex2dlod" xml:lang="en-US">
      <a name="tex2dlod" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex2dlod" name="tex2dlod" shape="rect">
        B.8.2.6. tex2DLod()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array bound to the two-dimensional texture reference texRef using texture coordinate (x,y).
        </li>
        <li class="li">
         The level-of-detail is given by level.
        </li>
        <li class="li">
         Type is the same as DataType except when readMode is cudaReadModeNormalizedFloat (see Texture Reference API), in which case Type is the corresponding floating-point type.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex2dgrad" xml:lang="en-US">
      <a name="tex2dgrad" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex2dgrad" name="tex2dgrad" shape="rect">
        B.8.2.7. tex2DGrad()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array bound to the two-dimensional texture reference texRef using texture coordinate (x,y).
        </li>
        <li class="li">
         The level-of-detail is derived from the dx and dy X- and Y-gradients.
        </li>
        <li class="li">
         Type is the same as DataType except when readMode is cudaReadModeNormalizedFloat (see Texture Reference API), in which case Type is the corresponding floating-point type.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex3d" xml:lang="en-US">
      <a name="tex3d" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex3d" name="tex3d" shape="rect">
        B.8.2.8. tex3D()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array bound to the three-dimensional texture reference texRef using texture coordinates x, y, and z.
        </li>
        <li class="li">
         Type is equal to DataType except when readMode is equal to cudaReadModeNormalizedFloat (see Texture Reference API), in which case Type is equal to the matching floating-point type.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex3dlod" xml:lang="en-US">
      <a name="tex3dlod" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex3dlod" name="tex3dlod" shape="rect">
        B.8.2.9. tex3DLod()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array bound to the two-dimensional texture reference texRef using texture coordinate (x,y,z).
        </li>
        <li class="li">
         The level-of-detail is given by level.
        </li>
        <li class="li">
         Type is the same as DataType except when readMode is cudaReadModeNormalizedFloat (see Texture Reference API), in which case Type is the corresponding floating-point type.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex3dgrad" xml:lang="en-US">
      <a name="tex3dgrad" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex3dgrad" name="tex3dgrad" shape="rect">
        B.8.2.10. tex3DGrad()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array bound to the two-dimensional texture reference texRef using texture coordinate (x,y,z).
        </li>
        <li class="li">
         The level-of-detail is derived from the dx and dy X- and Y-gradients.
        </li>
        <li class="li">
         Type is the same as DataType except when readMode is cudaReadModeNormalizedFloat (see Texture Reference API), in which case Type is the corresponding floating-point type.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex1dlayered" xml:lang="en-US">
      <a name="tex1dlayered" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex1dlayered" name="tex1dlayered" shape="rect">
        B.8.2.11. tex1DLayered()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array bound to the one-dimensional layered texture reference texRef using texture coordinate x and index layer, as described in Layered Textures.
        </li>
        <li class="li">
         Type is equal to DataType except when readMode is equal to cudaReadModeNormalizedFloat (see Texture Reference API), in which case Type is equal to the matching floating-point type.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex1dlayeredlod" xml:lang="en-US">
      <a name="tex1dlayeredlod" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex1dlayeredlod" name="tex1dlayeredlod" shape="rect">
        B.8.2.12. tex1DLayeredLod()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array bound to the one-dimensional texture reference texRef using texture coordinate x and index layer as described in Layered Textures.
        </li>
        <li class="li">
         The level-of-detail is given by level.
        </li>
        <li class="li">
         Type is the same as DataType except when readMode is cudaReadModeNormalizedFloat (see Texture Reference API), in which case Type is the corresponding floating-point type.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex1dlayeredgrad" xml:lang="en-US">
      <a name="tex1dlayeredgrad" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex1dlayeredgrad" name="tex1dlayeredgrad" shape="rect">
        B.8.2.13. tex1DLayeredGrad()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array bound to the one-dimensional texture reference texRef using texture coordinate x and index layer as described in Layered Textures.
        </li>
        <li class="li">
         The level-of-detail is derived from the dx and dy X- and Y-gradients.
        </li>
        <li class="li">
         Type is the same as DataType except when readMode is cudaReadModeNormalizedFloat (see Texture Reference API), in which case Type is the corresponding floating-point type.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex2dlayered" xml:lang="en-US">
      <a name="tex2dlayered" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex2dlayered" name="tex2dlayered" shape="rect">
        B.8.2.14. tex2DLayered()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array bound to the two-dimensional layered texture reference texRef using texture coordinates x and y, and index layer, as described in Texture Memory.
        </li>
        <li class="li">
         Type is equal to DataType except when readMode is equal to cudaReadModeNormalizedFloat (see Texture Reference API), in which case Type is equal to the matching floating-point type.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex2dlayeredlod" xml:lang="en-US">
      <a name="tex2dlayeredlod" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex2dlayeredlod" name="tex2dlayeredlod" shape="rect">
        B.8.2.15. tex2DLayeredLod()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array bound to the two-dimensional texture reference texRef using texture coordinate (x,y) and index layer as described in Layered Textures.
        </li>
        <li class="li">
         The level-of-detail is given by level.
        </li>
        <li class="li">
         Type is the same as DataType except when readMode is cudaReadModeNormalizedFloat (see Texture Reference API), in which case Type is the corresponding floating-point type.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex2dlayeredgrad" xml:lang="en-US">
      <a name="tex2dlayeredgrad" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex2dlayeredgrad" name="tex2dlayeredgrad" shape="rect">
        B.8.2.16. tex2DLayeredGrad()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array bound to the two-dimensional texture reference texRef using texture coordinate (x,y) and index layer as described in Layered Textures.
        </li>
        <li class="li">
         The level-of-detail is derived from the dx and dy X- and Y-gradients.
        </li>
        <li class="li">
         Type is the same as DataType except when readMode is cudaReadModeNormalizedFloat (see Texture Reference API), in which case Type is the corresponding floating-point type.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="texcubemap" xml:lang="en-US">
      <a name="texcubemap" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#texcubemap" name="texcubemap" shape="rect">
        B.8.2.17. texCubemap()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array bound to the cubemap texture reference texRef using texture coordinates x, y, and z, as described in Cubemap Textures.
        </li>
        <li class="li">
         Type is equal to DataType except when readMode is equal to cudaReadModeNormalizedFloat (see Texture Reference API), in which case Type is equal to the matching floating-point type.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="texcubemaplod" xml:lang="en-US">
      <a name="texcubemaplod" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#texcubemaplod" name="texcubemaplod" shape="rect">
        B.8.2.18. texCubemapLod()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array bound to the two-dimensional texture reference texRef using texture coordinate (x,y,z).
        </li>
        <li class="li">
         The level-of-detail is given by level.
        </li>
        <li class="li">
         Type is the same as DataType except when readMode is cudaReadModeNormalizedFloat (see Texture Reference API), in which case Type is the corresponding floating-point type.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="texcubemaplayered" xml:lang="en-US">
      <a name="texcubemaplayered" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#texcubemaplayered" name="texcubemaplayered" shape="rect">
        B.8.2.19. texCubemapLayered()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array bound to the cubemap layered texture reference texRef using texture coordinates x, y, and z, and index layer, as described in Cubemap Layered Textures.
        </li>
        <li class="li">
         Type is equal to DataType except when readMode is equal to cudaReadModeNormalizedFloat (see Texture Reference API), in which case Type is equal to the matching floating-point type.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="texcubemaplayeredlod" xml:lang="en-US">
      <a name="texcubemaplayeredlod" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#texcubemaplayeredlod" name="texcubemaplayeredlod" shape="rect">
        B.8.2.20. texCubemapLayeredLod()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array bound to the two-dimensional texture reference texRef using texture coordinate (x,y,z) and index layer as described in Layered Textures.
        </li>
        <li class="li">
         The level-of-detail is given by level.
        </li>
        <li class="li">
         Type is the same as DataType except when readMode is cudaReadModeNormalizedFloat (see Texture Reference API), in which case Type is the corresponding floating-point type.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="tex2dgather" xml:lang="en-US">
      <a name="tex2dgather" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#tex2dgather" name="tex2dgather" shape="rect">
        B.8.2.21. tex2Dgather()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         fetches from the CUDA array bound to the 2D texture reference texRef using texture coordinates x and y and the comp parameter as described in Texture Gather.
        </li>
        <li class="li">
         Type is a 4-component vector type.
        </li>
        <li class="li">
         It is based on the base type of DataType except when readMode is equal to cudaReadModeNormalizedFloat (see Texture Reference API), in which case it is always float4.
        </li>
       </ul>
      </div>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="surface-functions" xml:lang="en-US">
    <a name="surface-functions" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surface-functions" name="surface-functions" shape="rect">
      B.9. Surface Functions
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       Surface functions are only supported by devices of compute capability 2.0 and higher.
      </li>
      <li class="li">
       Surface objects are described in described in Surface Object API Surface references are described in Surface Reference API.
      </li>
      <li class="li">
       In the sections below, boundaryMode specifies the boundary mode, that is how out-of-range surface coordinates are handled; it is equal to either cudaBoundaryModeClamp, in which case out-of-range coordinates are clamped to the valid range, or cudaBoundaryModeZero, in which case out-of-range reads return zero and out-of-range writes are ignored, or cudaBoundaryModeTrap, in which case out-of-range accesses cause the kernel execution to fail.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="surface-object-api-appendix" xml:lang="en-US">
     <a name="surface-object-api-appendix" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surface-object-api-appendix" name="surface-object-api-appendix" shape="rect">
       B.9.1. Surface Object API
      </a>
     </h3>
     <div class="topic concept nested4" id="surf1dread-object" xml:lang="en-US">
      <a name="surf1dread-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surf1dread-object" name="surf1dread-object" shape="rect">
        B.9.1.1. surf1Dread()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         reads the CUDA array specified by the one-dimensional surface object surfObj using coordinate x.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surf1dwrite-object" xml:lang="en-US">
      <a name="surf1dwrite-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surf1dwrite-object" name="surf1dwrite-object" shape="rect">
        B.9.1.2. surf1Dwrite
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         writes value data to the CUDA array specified by the one-dimensional surface object surfObj at coordinate x.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surf2dread-object" xml:lang="en-US">
      <a name="surf2dread-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surf2dread-object" name="surf2dread-object" shape="rect">
        B.9.1.3. surf2Dread()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         reads the CUDA array specified by the two-dimensional surface object surfObj using coordinates x and y.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surf2dwrite-object" xml:lang="en-US">
      <a name="surf2dwrite-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surf2dwrite-object" name="surf2dwrite-object" shape="rect">
        B.9.1.4. surf2Dwrite()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         writes value data to the CUDA array specified by the two-dimensional surface object surfObj at coordinate x and y.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surf3dread-object" xml:lang="en-US">
      <a name="surf3dread-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surf3dread-object" name="surf3dread-object" shape="rect">
        B.9.1.5. surf3Dread()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         reads the CUDA array specified by the three-dimensional surface object surfObj using coordinates x, y, and z.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surf3dwrite-object" xml:lang="en-US">
      <a name="surf3dwrite-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surf3dwrite-object" name="surf3dwrite-object" shape="rect">
        B.9.1.6. surf3Dwrite()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         writes value data to the CUDA array specified by the three-dimensional object surfObj at coordinate x, y, and z.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surf1dlayeredread-object" xml:lang="en-US">
      <a name="surf1dlayeredread-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surf1dlayeredread-object" name="surf1dlayeredread-object" shape="rect">
        B.9.1.7. surf1DLayeredread()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         reads the CUDA array specified by the one-dimensional layered surface object surfObj using coordinate x and index layer.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surf1dlayeredwrite-object" xml:lang="en-US">
      <a name="surf1dlayeredwrite-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surf1dlayeredwrite-object" name="surf1dlayeredwrite-object" shape="rect">
        B.9.1.8. surf1DLayeredwrite()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         writes value data to the CUDA array specified by the two-dimensional layered surface object surfObj at coordinate x and index layer.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surf2dlayeredread-object" xml:lang="en-US">
      <a name="surf2dlayeredread-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surf2dlayeredread-object" name="surf2dlayeredread-object" shape="rect">
        B.9.1.9. surf2DLayeredread()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         reads the CUDA array specified by the two-dimensional layered surface object surfObj using coordinate x and y, and index layer.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surf2dlayeredwrite-object" xml:lang="en-US">
      <a name="surf2dlayeredwrite-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surf2dlayeredwrite-object" name="surf2dlayeredwrite-object" shape="rect">
        B.9.1.10. surf2DLayeredwrite()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         writes value data to the CUDA array specified by the one-dimensional layered surface object surfObj at coordinate x and y, and index layer.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surfcubemapread-object" xml:lang="en-US">
      <a name="surfcubemapread-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surfcubemapread-object" name="surfcubemapread-object" shape="rect">
        B.9.1.11. surfCubemapread()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         reads the CUDA array specified by the cubemap surface object surfObj using coordinate x and y, and face index face.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surfcubemapwrite-object" xml:lang="en-US">
      <a name="surfcubemapwrite-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surfcubemapwrite-object" name="surfcubemapwrite-object" shape="rect">
        B.9.1.12. surfCubemapwrite()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         writes value data to the CUDA array specified by the cubemap object surfObj at coordinate x and y, and face index face.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surfcubemaplayeredread-object" xml:lang="en-US">
      <a name="surfcubemaplayeredread-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surfcubemaplayeredread-object" name="surfcubemaplayeredread-object" shape="rect">
        B.9.1.13. surfCubemapLayeredread()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         reads the CUDA array specified by the cubemap layered surface object surfObj using coordinate x and y, and index layerFace.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surfcubemaplayeredwrite-object" xml:lang="en-US">
      <a name="surfcubemaplayeredwrite-object" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surfcubemaplayeredwrite-object" name="surfcubemaplayeredwrite-object" shape="rect">
        B.9.1.14. surfCubemapLayeredwrite()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         writes value data to the CUDA array specified by the cubemap layered object surfObj at coordinate x and y, and index layerFace.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="surface-reference-api-appendix" xml:lang="en-US">
     <a name="surface-reference-api-appendix" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surface-reference-api-appendix" name="surface-reference-api-appendix" shape="rect">
       B.9.2. Surface Reference API
      </a>
     </h3>
     <div class="topic concept nested4" id="surf1dread" xml:lang="en-US">
      <a name="surf1dread" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surf1dread" name="surf1dread" shape="rect">
        B.9.2.1. surf1Dread()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         reads the CUDA array bound to the one-dimensional surface reference surfRef using coordinate x.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surf1dwrite" xml:lang="en-US">
      <a name="surf1dwrite" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surf1dwrite" name="surf1dwrite" shape="rect">
        B.9.2.2. surf1Dwrite
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         writes value data to the CUDA array bound to the one-dimensional surface reference surfRef at coordinate x.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surf2dread" xml:lang="en-US">
      <a name="surf2dread" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surf2dread" name="surf2dread" shape="rect">
        B.9.2.3. surf2Dread()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         reads the CUDA array bound to the two-dimensional surface reference surfRef using coordinates x and y.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surf2dwrite" xml:lang="en-US">
      <a name="surf2dwrite" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surf2dwrite" name="surf2dwrite" shape="rect">
        B.9.2.4. surf2Dwrite()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         writes value data to the CUDA array bound to the two-dimensional surface reference surfRef at coordinate x and y.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surf3dread" xml:lang="en-US">
      <a name="surf3dread" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surf3dread" name="surf3dread" shape="rect">
        B.9.2.5. surf3Dread()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         reads the CUDA array bound to the three-dimensional surface reference surfRef using coordinates x, y, and z.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surf3dwrite" xml:lang="en-US">
      <a name="surf3dwrite" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surf3dwrite" name="surf3dwrite" shape="rect">
        B.9.2.6. surf3Dwrite()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         writes value data to the CUDA array bound to the three-dimensional surface reference surfRef at coordinate x, y, and z.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surf1dlayeredread" xml:lang="en-US">
      <a name="surf1dlayeredread" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surf1dlayeredread" name="surf1dlayeredread" shape="rect">
        B.9.2.7. surf1DLayeredread()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         reads the CUDA array bound to the one-dimensional layered surface reference surfRef using coordinate x and index layer.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surf1dlayeredwrite" xml:lang="en-US">
      <a name="surf1dlayeredwrite" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surf1dlayeredwrite" name="surf1dlayeredwrite" shape="rect">
        B.9.2.8. surf1DLayeredwrite()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         writes value data to the CUDA array bound to the two-dimensional layered surface reference surfRef at coordinate x and index layer.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surf2dlayeredread" xml:lang="en-US">
      <a name="surf2dlayeredread" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surf2dlayeredread" name="surf2dlayeredread" shape="rect">
        B.9.2.9. surf2DLayeredread()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         reads the CUDA array bound to the two-dimensional layered surface reference surfRef using coordinate x and y, and index layer.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surf2dlayeredwrite" xml:lang="en-US">
      <a name="surf2dlayeredwrite" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surf2dlayeredwrite" name="surf2dlayeredwrite" shape="rect">
        B.9.2.10. surf2DLayeredwrite()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         writes value data to the CUDA array bound to the one-dimensional layered surface reference surfRef at coordinate x and y, and index layer.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surfcubemapread" xml:lang="en-US">
      <a name="surfcubemapread" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surfcubemapread" name="surfcubemapread" shape="rect">
        B.9.2.11. surfCubemapread()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         reads the CUDA array bound to the cubemap surface reference surfRef using coordinate x and y, and face index face.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surfcubemapwrite" xml:lang="en-US">
      <a name="surfcubemapwrite" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surfcubemapwrite" name="surfcubemapwrite" shape="rect">
        B.9.2.12. surfCubemapwrite()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         writes value data to the CUDA array bound to the cubemap reference surfRef at coordinate x and y, and face index face.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surfcubemaplayeredread" xml:lang="en-US">
      <a name="surfcubemaplayeredread" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surfcubemaplayeredread" name="surfcubemaplayeredread" shape="rect">
        B.9.2.13. surfCubemapLayeredread()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         reads the CUDA array bound to the cubemap layered surface reference surfRef using coordinate x and y, and index layerFace.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="surfcubemaplayeredwrite" xml:lang="en-US">
      <a name="surfcubemaplayeredwrite" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#surfcubemaplayeredwrite" name="surfcubemaplayeredwrite" shape="rect">
        B.9.2.14. surfCubemapLayeredwrite()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         writes value data to the CUDA array bound to the cubemap layered reference surfRef at coordinate x and y, and index layerFace.
        </li>
       </ul>
      </div>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="ldg-function" xml:lang="en-US">
    <a name="ldg-function" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#ldg-function" name="ldg-function" shape="rect">
      B.10. Read-Only Data Cache Load Function
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       The read-only data cache load function is only supported by devices of compute capability 3.5 and higher.
      </li>
      <li class="li">
       returns the data of type T located at address address, where T is char, short, int, long longunsigned char, unsigned short, unsigned int, unsigned long long, int2, int4, uint2, uint4, float, float2, float4, double, or double2.
      </li>
      <li class="li">
       The operation is cached in the read-only data cache (see Global Memory).
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="time-function" xml:lang="en-US">
    <a name="time-function" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#time-function" name="time-function" shape="rect">
      B.11. Time Function
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       when executed in device code, returns the value of a per-multiprocessor counter that is incremented every clock cycle.
      </li>
      <li class="li">
       Sampling this counter at the beginning and at the end of a kernel, taking the difference of the two samples, and recording the result per thread provides a measure for each thread of the number of clock cycles taken by the device to completely execute the thread, but not of the number of clock cycles the device actually spent executing thread instructions.
      </li>
      <li class="li">
       The former number is greater than the latter since threads are time sliced.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="atomic-functions" xml:lang="en-US">
    <a name="atomic-functions" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#atomic-functions" name="atomic-functions" shape="rect">
      B.12. Atomic Functions
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       An atomic function performs a read-modify-write atomic operation on one 32-bit or 64-bit word residing in global or shared memory.
      </li>
      <li class="li">
       For example, atomicAdd() reads a word at some address in global or shared memory, adds a number to it, and writes the result back to the same address.
      </li>
      <li class="li">
       The operation is atomic in the sense that it is guaranteed to be performed without interference from other threads.
      </li>
      <li class="li">
       In other words, no other thread can access this address until the operation is complete.
      </li>
      <li class="li">
       Atomic functions do not act as memory fences and do not imply synchronization or ordering constraints for memory operations (see Memory Fence Functions for more details on memory fences).
      </li>
      <li class="li">
       Atomic functions can only be used in device functions and atomic functions operating on mapped page-locked memory (Mapped Memory) are not atomic from the point of view of the host or other devices.
      </li>
      <li class="li">
       Note that any atomic operation can be implemented based on atomicCAS() (Compare And Swap).
      </li>
      <li class="li">
       For example, atomicAdd() for double-precision floating-point numbers is not available on devices with compute capability lower than 6.0 but it can be implemented as follows:
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="arithmetic-functions" xml:lang="en-US">
     <a name="arithmetic-functions" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#arithmetic-functions" name="arithmetic-functions" shape="rect">
       B.12.1. Arithmetic Functions
      </a>
     </h3>
     <div class="topic concept nested4" id="atomicadd" xml:lang="en-US">
      <a name="atomicadd" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#atomicadd" name="atomicadd" shape="rect">
        B.12.1.1. atomicAdd()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         reads the 32-bit or 64-bit word old located at the address address in global or shared memory, computes (old + val), and stores the result back to memory at the same address.
        </li>
        <li class="li">
         These three operations are performed in one atomic transaction.
        </li>
        <li class="li">
         The function returns old.
        </li>
        <li class="li">
         The 32-bit floating-point version of atomicAdd() is only supported by devices of compute capability 2.x and higher.
        </li>
        <li class="li">
         The 64-bit floating-point version of atomicAdd() is only supported by devices of compute capability 6.x and higher.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="atomicsub" xml:lang="en-US">
      <a name="atomicsub" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#atomicsub" name="atomicsub" shape="rect">
        B.12.1.2. atomicSub()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         reads the 32-bit word old located at the address address in global or shared memory, computes (old - val), and stores the result back to memory at the same address.
        </li>
        <li class="li">
         These three operations are performed in one atomic transaction.
        </li>
        <li class="li">
         The function returns old.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="atomicexch" xml:lang="en-US">
      <a name="atomicexch" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#atomicexch" name="atomicexch" shape="rect">
        B.12.1.3. atomicExch()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         reads the 32-bit or 64-bit word old located at the address address in global or shared memory and stores val back to memory at the same address.
        </li>
        <li class="li">
         These two operations are performed in one atomic transaction.
        </li>
        <li class="li">
         The function returns old.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="atomicmin" xml:lang="en-US">
      <a name="atomicmin" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#atomicmin" name="atomicmin" shape="rect">
        B.12.1.4. atomicMin()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         reads the 32-bit or 64-bit word old located at the address address in global or shared memory, computes the minimum of old and val, and stores the result back to memory at the same address.
        </li>
        <li class="li">
         These three operations are performed in one atomic transaction.
        </li>
        <li class="li">
         The function returns old.
        </li>
        <li class="li">
         The 64-bit version of atomicMin() is only supported by devices of compute capability 3.5 and higher.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="atomicmax" xml:lang="en-US">
      <a name="atomicmax" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#atomicmax" name="atomicmax" shape="rect">
        B.12.1.5. atomicMax()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         reads the 32-bit or 64-bit word old located at the address address in global or shared memory, computes the maximum of old and val, and stores the result back to memory at the same address.
        </li>
        <li class="li">
         These three operations are performed in one atomic transaction.
        </li>
        <li class="li">
         The function returns old.
        </li>
        <li class="li">
         The 64-bit version of atomicMax() is only supported by devices of compute capability 3.5 and higher.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="atomicinc" xml:lang="en-US">
      <a name="atomicinc" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#atomicinc" name="atomicinc" shape="rect">
        B.12.1.6. atomicInc()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         reads the 32-bit word old located at the address address in global or shared memory, computes ((old &gt;= val) ?
        </li>
        <li class="li">
         0 : (old+1)), and stores the result back to memory at the same address.
        </li>
        <li class="li">
         These three operations are performed in one atomic transaction.
        </li>
        <li class="li">
         The function returns old.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="atomicdec" xml:lang="en-US">
      <a name="atomicdec" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#atomicdec" name="atomicdec" shape="rect">
        B.12.1.7. atomicDec()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         reads the 32-bit word old located at the address address in global or shared memory, computes (((old == 0) | (old &gt; val)) ?
        </li>
        <li class="li">
         val : (old-1) ), and stores the result back to memory at the same address.
        </li>
        <li class="li">
         These three operations are performed in one atomic transaction.
        </li>
        <li class="li">
         The function returns old.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="atomiccas" xml:lang="en-US">
      <a name="atomiccas" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#atomiccas" name="atomiccas" shape="rect">
        B.12.1.8. atomicCAS()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         reads the 32-bit or 64-bit word old located at the address address in global or shared memory, computes (old == compare ?
        </li>
        <li class="li">
         val : old) , and stores the result back to memory at the same address.
        </li>
        <li class="li">
         These three operations are performed in one atomic transaction.
        </li>
        <li class="li">
         The function returns old (Compare And Swap).
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="bitwise-functions" xml:lang="en-US">
     <a name="bitwise-functions" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#bitwise-functions" name="bitwise-functions" shape="rect">
       B.12.2. Bitwise Functions
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
      </ul>
     </div>
     <div class="topic concept nested4" id="atomicand" xml:lang="en-US">
      <a name="atomicand" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#atomicand" name="atomicand" shape="rect">
        B.12.2.1. atomicAnd()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         reads the 32-bit or 64-bit word old located at the address address in global or shared memory, computes (old &amp; val), and stores the result back to memory at the same address.
        </li>
        <li class="li">
         These three operations are performed in one atomic transaction.
        </li>
        <li class="li">
         The function returns old.
        </li>
        <li class="li">
         The 64-bit version of atomicAnd() is only supported by devices of compute capability 3.5 and higher.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="atomicor" xml:lang="en-US">
      <a name="atomicor" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#atomicor" name="atomicor" shape="rect">
        B.12.2.2. atomicOr()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         reads the 32-bit or 64-bit word old located at the address address in global or shared memory, computes (old | val), and stores the result back to memory at the same address.
        </li>
        <li class="li">
         These three operations are performed in one atomic transaction.
        </li>
        <li class="li">
         The function returns old.
        </li>
        <li class="li">
         The 64-bit version of atomicOr() is only supported by devices of compute capability 3.5 and higher.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="atomicxor" xml:lang="en-US">
      <a name="atomicxor" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#atomicxor" name="atomicxor" shape="rect">
        B.12.2.3. atomicXor()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         reads the 32-bit or 64-bit word old located at the address address in global or shared memory, computes (old ^ val), and stores the result back to memory at the same address.
        </li>
        <li class="li">
         These three operations are performed in one atomic transaction.
        </li>
        <li class="li">
         The function returns old.
        </li>
        <li class="li">
         The 64-bit version of atomicXor() is only supported by devices of compute capability 3.5 and higher.
        </li>
       </ul>
      </div>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="warp-vote-functions" xml:lang="en-US">
    <a name="warp-vote-functions" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#warp-vote-functions" name="warp-vote-functions" shape="rect">
      B.13. Warp Vote Functions
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       The warp vote functions allow the threads of a given warp to perform a reduction-and-broadcast operation.
      </li>
      <li class="li">
       These functions take as input an integer predicate from each thread in the warp and compare those values with zero.
      </li>
      <li class="li">
       The results of the comparisons are combined (reduced) across the active threads of the warp in one of the following ways, broadcasting a single return value to each participating thread: __all(predicate): Evaluate predicate for all active threads of the warp and return non-zero if and only if predicate evaluates to non-zero for all of them.
      </li>
      <li class="li">
       __any(predicate): Evaluate predicate for all active threads of the warp and return non-zero if and only if predicate evaluates to non-zero for any of them.
      </li>
      <li class="li">
       __ballot(predicate): Evaluate predicate for all active threads of the warp and return an integer whose Nth bit is set if and only if predicate evaluates to non-zero for the Nth thread of the warp and the Nth thread is active.
      </li>
      <li class="li">
       For each of these warp vote operations, the result excludes threads that are inactive (e.g., due to warp divergence).
      </li>
      <li class="li">
       Inactive threads are represented by 0 bits in the value returned by __ballot() and are not considered in the reductions performed by __all() and __any().
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="warp-shuffle-functions" xml:lang="en-US">
    <a name="warp-shuffle-functions" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#warp-shuffle-functions" name="warp-shuffle-functions" shape="rect">
      B.14. Warp Shuffle Functions
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       __shfl, __shfl_up, __shfl_down, __shfl_xor exchange a variable between threads within a warp.
      </li>
      <li class="li">
       Supported by devices of compute capability 3.x or higher.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="synopsis" xml:lang="en-US">
     <a name="synopsis" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#synopsis" name="synopsis" shape="rect">
       B.14.1. Synopsis
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="warp-description" xml:lang="en-US">
     <a name="warp-description" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#warp-description" name="warp-description" shape="rect">
       B.14.2. Description
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The __shfl() intrinsics permit exchanging of a variable between threads within a warp without use of shared memory.
       </li>
       <li class="li">
        The exchange occurs simultaneously for all active threads within the warp, moving 4 bytes of data per thread.
       </li>
       <li class="li">
        Exchange of 8-byte quantities must be broken into two separate invocations of __shfl().
       </li>
       <li class="li">
        Threads within a warp are referred to as lanes, and may have an index between 0 and warpSize-1 (inclusive).
       </li>
       <li class="li">
        Four source-lane addressing modes are supported: __shfl() Direct copy from indexed lane __shfl_up() Copy from a lane with lower ID relative to caller __shfl_down() Copy from a lane with higher ID relative to caller __shfl_xor() Copy from a lane based on bitwise XOR of own lane ID Threads may only read data from another thread which is actively participating in the __shfl() command.
       </li>
       <li class="li">
        If the target thread is inactive, the retrieved value is undefined.
       </li>
       <li class="li">
        All of the __shfl() intrinsics take an optional width parameter which alters the behavior of the intrinsic.
       </li>
       <li class="li">
        width must have a value which is a power of 2; results are undefined if width is not a power of 2, or is a number greater than warpSize.
       </li>
       <li class="li">
        __shfl() returns the value of var held by the thread whose ID is given by srcLane.
       </li>
       <li class="li">
        If width is less than warpSize then each subsection of the warp behaves as a separate entity with a starting logical lane ID of 0.
       </li>
       <li class="li">
        If srcLane is outside the range [0:width-1], the value returned corresponds to the value of var held by the srcLane modulo width (i.e.
       </li>
       <li class="li">
        within the same subsection).
       </li>
       <li class="li">
        __shfl_up() calculates a source lane ID by subtracting delta from the caller's lane ID.
       </li>
       <li class="li">
        The value of var held by the resulting lane ID is returned: in effect, var is shifted up the warp by delta lanes.
       </li>
       <li class="li">
        If width is less than warpSize then each subsection of the warp behaves as a separate entity with a starting logical lane ID of 0.
       </li>
       <li class="li">
        The source lane index will not wrap around the value of width, so effectively the lower delta lanes will be unchanged.
       </li>
       <li class="li">
        __shfl_down() calculates a source lane ID by adding delta to the caller's lane ID.
       </li>
       <li class="li">
        The value of var held by the resulting lane ID is returned: this has the effect of shifting var down the warp by delta lanes.
       </li>
       <li class="li">
        If width is less than warpSize then each subsection of the warp behaves as a separate entity with a starting logical lane ID of 0.
       </li>
       <li class="li">
        As for __shfl_up(), the ID number of the source lane will not wrap around the value of width and so the upper delta lanes will remain unchanged.
       </li>
       <li class="li">
        __shfl_xor() calculates a source line ID by performing a bitwise XOR of the caller's lane ID with laneMask: the value of var held by the resulting lane ID is returned.
       </li>
       <li class="li">
        If width is less than warpSize then each group of width consecutive threads are able to access elements from earlier groups of threads, however if they attempt to access elements from later groups of threads their own value of var will be returned.
       </li>
       <li class="li">
        This mode implements a butterfly addressing pattern such as is used in tree reduction and broadcast.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="return-value" xml:lang="en-US">
     <a name="return-value" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#return-value" name="return-value" shape="rect">
       B.14.3. Return Value
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        All __shfl() intrinsics return the 4-byte word referenced by var from the source lane ID as an unsigned integer.
       </li>
       <li class="li">
        If the source lane ID is out of range or the source thread has exited, the calling thread's own var is returned.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="warp-notes" xml:lang="en-US">
     <a name="warp-notes" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#warp-notes" name="warp-notes" shape="rect">
       B.14.4. Notes
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        All __shfl() intrinsics share the same semantics with respect to code motion as the vote intrinsics __any() and __all().
       </li>
       <li class="li">
        Threads may only read data from another thread which is actively participating in the __shfl() command.
       </li>
       <li class="li">
        If the target thread is inactive, the retrieved value is undefined.
       </li>
       <li class="li">
        width must be a power-of-2 (i.e., 2, 4, 8, 16 or 32).
       </li>
       <li class="li">
        Results are unspecified for other values.
       </li>
       <li class="li">
        Types other than int or float must first be cast in order to use the __shfl() intrinsics.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="warp-examples" xml:lang="en-US">
     <a name="warp-examples" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#warp-examples" name="warp-examples" shape="rect">
       B.14.5. Examples
      </a>
     </h3>
     <div class="topic concept nested4" id="warp-examples-broadcast" xml:lang="en-US">
      <a name="warp-examples-broadcast" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#warp-examples-broadcast" name="warp-examples-broadcast" shape="rect">
        B.14.5.1. Broadcast of a single value across a warp
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="warp-examples-inclusive" xml:lang="en-US">
      <a name="warp-examples-inclusive" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#warp-examples-inclusive" name="warp-examples-inclusive" shape="rect">
        B.14.5.2. Inclusive plus-scan across sub-partitions of 8 threads
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="warp-examples-reduction" xml:lang="en-US">
      <a name="warp-examples-reduction" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#warp-examples-reduction" name="warp-examples-reduction" shape="rect">
        B.14.5.3. Reduction across a warp
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
       </ul>
      </div>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="profiler-counter-function" xml:lang="en-US">
    <a name="profiler-counter-function" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#profiler-counter-function" name="profiler-counter-function" shape="rect">
      B.15. Profiler Counter Function
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       Each multiprocessor has a set of sixteen hardware counters that an application can increment with a single instruction by calling the __prof_trigger() function.
      </li>
      <li class="li">
       increments by one per warp the per-multiprocessor hardware counter of index counter.
      </li>
      <li class="li">
       Counters 8 to 15 are reserved and should not be used by applications.
      </li>
      <li class="li">
       The value of counters 0, 1, ..., 7 can be obtained via nvprof by nvprof --events prof_trigger_0x where x is 0, 1, ..., 7.
      </li>
      <li class="li">
       All counters are reset before each kernel launch (note that when collecting counters, kernel launches are synchronous as mentioned in Concurrent Execution between Host and Device).
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="assertion" xml:lang="en-US">
    <a name="assertion" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#assertion" name="assertion" shape="rect">
      B.16. Assertion
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       Assertion is only supported by devices of compute capability 2.x and higher.
      </li>
      <li class="li">
       It is not supported on MacOS, regardless of the device, and loading a module that references the assert function on Mac OS will fail.
      </li>
      <li class="li">
       stops the kernel execution if expression is equal to zero.
      </li>
      <li class="li">
       If the program is run within a debugger, this triggers a breakpoint and the debugger can be used to inspect the current state of the device.
      </li>
      <li class="li">
       Otherwise, each thread for which expression is equal to zero prints a message to stderr after synchronization with the host via cudaDeviceSynchronize(), cudaStreamSynchronize(), or cudaEventSynchronize().
      </li>
      <li class="li">
       The format of this message is as follows: Any subsequent host-side synchronization calls made for the same device will return cudaErrorAssert.
      </li>
      <li class="li">
       No more commands can be sent to this device until cudaDeviceReset() is called to reinitialize the device.
      </li>
      <li class="li">
       If expression is different from zero, the kernel execution is unaffected.
      </li>
      <li class="li">
       For example, the following program from source file test.cuwill output:Assertions are for debugging purposes.
      </li>
      <li class="li">
       They can affect performance and it is therefore recommended to disable them in production code.
      </li>
      <li class="li">
       They can be disabled at compile time by defining the NDEBUG preprocessor macro before including assert.h.
      </li>
      <li class="li">
       Note that expression should not be an expression with side effects (something like (++i &gt; 0), for example), otherwise disabling the assertion will affect the functionality of the code.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="formatted-output" xml:lang="en-US">
    <a name="formatted-output" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#formatted-output" name="formatted-output" shape="rect">
      B.17. Formatted Output
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       Formatted output is only supported by devices of compute capability 2.x and higher.prints formatted output from a kernel to a host-side output stream.
      </li>
      <li class="li">
       The in-kernel printf() function behaves in a similar way to the standard C-library printf() function, and the user is referred to the host system's manual pages for a complete description of printf() behavior.
      </li>
      <li class="li">
       In essence, the string passed in as format is output to a stream on the host, with substitutions made from the argument list wherever a format specifier is encountered.
      </li>
      <li class="li">
       Supported format specifiers are listed below.
      </li>
      <li class="li">
       The printf() command is executed as any other device-side function: per-thread, and in the context of the calling thread.
      </li>
      <li class="li">
       From a multi-threaded kernel, this means that a straightforward call to printf() will be executed by every thread, using that thread's data as specified.
      </li>
      <li class="li">
       Multiple versions of the output string will then appear at the host stream, once for each thread which encountered the printf().
      </li>
      <li class="li">
       It is up to the programmer to limit the output to a single thread if only a single output string is desired (see Examples for an illustrative example).
      </li>
      <li class="li">
       Unlike the C-standard printf(), which returns the number of characters printed, CUDA's printf() returns the number of arguments parsed.
      </li>
      <li class="li">
       If no arguments follow the format string, 0 is returned.
      </li>
      <li class="li">
       If the format string is NULL, -1 is returned.
      </li>
      <li class="li">
       If an internal error occurs, -2 is returned.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="format-specifiers" xml:lang="en-US">
     <a name="format-specifiers" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#format-specifiers" name="format-specifiers" shape="rect">
       B.17.1. Format Specifiers
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        As for standard printf(), format specifiers take the form: %[flags][width][.precision][size]type The following fields are supported (see widely-available documentation for a complete description of all behaviors): Flags: `#' ` ' `0' `+' `-' Width: `*' `0-9' Precision: `0-9' Size: `h' `l' `ll' Type: `%cdiouxXpeEfgGaAs' Note that CUDA's printf()will accept any combination of flag, width, precision, size and type, whether or not overall they form a valid format specifier.
       </li>
       <li class="li">
        In other words, "%hd" will be accepted and printf will expect a double-precision variable in the corresponding location in the argument list.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="limitations" xml:lang="en-US">
     <a name="limitations" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#limitations" name="limitations" shape="rect">
       B.17.2. Limitations
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Final formatting of the printf() output takes place on the host system.
       </li>
       <li class="li">
        This means that the format string must be understood by the host-system's compiler and C library.
       </li>
       <li class="li">
        Every effort has been made to ensure that the format specifiers supported by CUDA's printf function form a universal subset from the most common host compilers, but exact behavior will be host-OS-dependent.
       </li>
       <li class="li">
        As described in Format Specifiers, printf() will accept all combinations of valid flags and types.
       </li>
       <li class="li">
        This is because it cannot determine what will and will not be valid on the host system where the final output is formatted.
       </li>
       <li class="li">
        The effect of this is that output may be undefined if the program emits a format string which contains invalid combinations.
       </li>
       <li class="li">
        The printf() command can accept at most 32 arguments in addition to the format string.
       </li>
       <li class="li">
        Additional arguments beyond this will be ignored, and the format specifier output as-is.
       </li>
       <li class="li">
        Owing to the differing size of the long type on 64-bit Windows platforms (four bytes on 64-bit Windows platforms, eight bytes on other 64-bit platforms), a kernel which is compiled on a non-Windows 64-bit machine but then run on a win64 machine will see corrupted output for all format strings which include "%ld".
       </li>
       <li class="li">
        It is recommended that the compilation platform matches the execution platform to ensure safety.
       </li>
       <li class="li">
        The output buffer for printf() is set to a fixed size before kernel launch (see Associated Host-Side API).
       </li>
       <li class="li">
        It is circular and if more output is produced during kernel execution than can fit in the buffer, older output is overwritten.
       </li>
       <li class="li">
        It is flushed only when one of these actions is performed: Kernel launch via &lt;&lt;&lt;&gt;&gt;&gt; or cuLaunchKernel() (at the start of the launch, and if the CUDA_LAUNCH_BLOCKING environment variable is set to 1, at the end of the launch as well), Synchronization via cudaDeviceSynchronize(), cuCtxSynchronize(), cudaStreamSynchronize(), cuStreamSynchronize(), cudaEventSynchronize(), or cuEventSynchronize(), Memory copies via any blocking version of cudaMemcpy*() or cuMemcpy*(), Module loading/unloading via cuModuleLoad() or cuModuleUnload(), Context destruction via cudaDeviceReset() or cuCtxDestroy().
       </li>
       <li class="li">
        Prior to executing a stream callback added by cudaStreamAddCallback or cuStreamAddCallback.
       </li>
       <li class="li">
        Note that the buffer is not flushed automatically when the program exits.
       </li>
       <li class="li">
        The user must call cudaDeviceReset() or cuCtxDestroy() explicitly, as shown in the examples below.
       </li>
       <li class="li">
        Internally printf() uses a shared data structure and so it is possible that calling printf() might change the order of execution of threads.
       </li>
       <li class="li">
        In particular, a thread which calls printf() might take a longer execution path than one which does not call printf(), and that path length is dependent upon the parameters of the printf().
       </li>
       <li class="li">
        Note, however, that CUDA makes no guarantees of thread execution order except at explicit __syncthreads() barriers, so it is impossible to tell whether execution order has been modified by printf() or by other scheduling behaviour in the hardware.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="associated-host-side-api" xml:lang="en-US">
     <a name="associated-host-side-api" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#associated-host-side-api" name="associated-host-side-api" shape="rect">
       B.17.3. Associated Host-Side API
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The following API functions get and set the size of the buffer used to transfer the printf() arguments and internal metadata to the host (default is 1 megabyte): cudaDeviceGetLimit(size_t* size,cudaLimitPrintfFifoSize) cudaDeviceSetLimit(cudaLimitPrintfFifoSize, size_t size)
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="examples" xml:lang="en-US">
     <a name="examples" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#examples" name="examples" shape="rect">
       B.17.4. Examples
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The following code sample: will output: Notice how each thread encounters the printf() command, so there are as many lines of output as there were threads launched in the grid.
       </li>
       <li class="li">
        As expected, global values (i.e., float f) are common between all threads, and local values (i.e., threadIdx.x) are distinct per-thread.
       </li>
       <li class="li">
        The following code sample: will output: Self-evidently, the if() statement limits which threads will call printf, so that only a single line of output is seen.
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="dynamic-global-memory-allocation-and-operations" xml:lang="en-US">
    <a name="dynamic-global-memory-allocation-and-operations" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#dynamic-global-memory-allocation-and-operations" name="dynamic-global-memory-allocation-and-operations" shape="rect">
      B.18. Dynamic Global Memory Allocation and Operations
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       Dynamic global memory allocation and operations are only supported by devices of compute capability 2.x and higher.allocate and free memory dynamically from a fixed-size heap in global memory.copy size bytes from the memory location pointed by src to the memory location pointed by dest.
      </li>
      <li class="li">
       set size bytes of memory block pointed by ptr to value (interpreted as an unsigned char).
      </li>
      <li class="li">
       The CUDA in-kernel malloc() function allocates at least size bytes from the device heap and returns a pointer to the allocated memory or NULL if insufficient memory exists to fulfill the request.
      </li>
      <li class="li">
       The returned pointer is guaranteed to be aligned to a 16-byte boundary.
      </li>
      <li class="li">
       The CUDA in-kernel free() function deallocates the memory pointed to by ptr, which must have been returned by a previous call to malloc().
      </li>
      <li class="li">
       If ptr is NULL, the call to free() is ignored.
      </li>
      <li class="li">
       Repeated calls to free() with the same ptr has undefined behavior.
      </li>
      <li class="li">
       The memory allocated by a given CUDA thread via malloc() remains allocated for the lifetime of the CUDA context, or until it is explicitly released by a call to free().
      </li>
      <li class="li">
       It can be used by any other CUDA threads even from subsequent kernel launches.
      </li>
      <li class="li">
       Any CUDA thread may free memory allocated by another thread, but care should be taken to ensure that the same pointer is not freed more than once.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="heap-memory-allocation" xml:lang="en-US">
     <a name="heap-memory-allocation" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#heap-memory-allocation" name="heap-memory-allocation" shape="rect">
       B.18.1. Heap Memory Allocation
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The device memory heap has a fixed size that must be specified before any program using malloc() or free() is loaded into the context.
       </li>
       <li class="li">
        A default heap of eight megabytes is allocated if any program uses malloc() without explicitly specifying the heap size.
       </li>
       <li class="li">
        The following API functions get and set the heap size: cudaDeviceGetLimit(size_t* size, cudaLimitMallocHeapSize) cudaDeviceSetLimit(cudaLimitMallocHeapSize, size_t size) The heap size granted will be at least size bytes.
       </li>
       <li class="li">
        cuCtxGetLimit()and cudaDeviceGetLimit() return the currently requested heap size.
       </li>
       <li class="li">
        The actual memory allocation for the heap occurs when a module is loaded into the context, either explicitly via the CUDA driver API (see Module), or implicitly via the CUDA runtime API (see CUDA C Runtime).
       </li>
       <li class="li">
        If the memory allocation fails, the module load will generate a CUDA_ERROR_SHARED_OBJECT_INIT_FAILED error.
       </li>
       <li class="li">
        Heap size cannot be changed once a module load has occurred and it does not resize dynamically according to need.
       </li>
       <li class="li">
        Memory reserved for the device heap is in addition to memory allocated through host-side CUDA API calls such as cudaMalloc().
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="interoperability-host-memory-api" xml:lang="en-US">
     <a name="interoperability-host-memory-api" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#interoperability-host-memory-api" name="interoperability-host-memory-api" shape="rect">
       B.18.2. Interoperability with Host Memory API
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Memory allocated via malloc() cannot be freed using the runtime (i.e., by calling any of the free memory functions from Device Memory).
       </li>
       <li class="li">
        Similarly, memory allocated via the runtime (i.e., by calling any of the memory allocation functions from Device Memory) cannot be freed via free().
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="examples-per-thread" xml:lang="en-US">
     <a name="examples-per-thread" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#examples-per-thread" name="examples-per-thread" shape="rect">
       B.18.3. Examples
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
      </ul>
     </div>
     <div class="topic concept nested4" id="per-thread-allocation" xml:lang="en-US">
      <a name="per-thread-allocation" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#per-thread-allocation" name="per-thread-allocation" shape="rect">
        B.18.3.1. Per Thread Allocation
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The following code sample:will output: Notice how each thread encounters the malloc() and memset() commands and so receives and initializes its own allocation.
        </li>
        <li class="li">
         (Exact pointer values will vary: these are illustrative.)
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="per-thread-block-allocation" xml:lang="en-US">
      <a name="per-thread-block-allocation" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#per-thread-block-allocation" name="per-thread-block-allocation" shape="rect">
        B.18.3.2. Per Thread Block Allocation
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="allocation-persisting-kernel-launches" xml:lang="en-US">
      <a name="allocation-persisting-kernel-launches" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#allocation-persisting-kernel-launches" name="allocation-persisting-kernel-launches" shape="rect">
        B.18.3.3. Allocation Persisting Between Kernel Launches
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
       </ul>
      </div>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="execution-configuration" xml:lang="en-US">
    <a name="execution-configuration" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#execution-configuration" name="execution-configuration" shape="rect">
      B.19. Execution Configuration
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       Any call to a __global__ function must specify the execution configuration for that call.
      </li>
      <li class="li">
       The execution configuration defines the dimension of the grid and blocks that will be used to execute the function on the device, as well as the associated stream (see CUDA C Runtime for a description of streams).
      </li>
      <li class="li">
       The execution configuration is specified by inserting an expression of the form &lt;&lt;&lt; Dg, Db, Ns, S &gt;&gt;&gt; between the function name and the parenthesized argument list, where: Dg is of type dim3 (see dim3) and specifies the dimension and size of the grid, such that Dg.x * Dg.y * Dg.z equals the number of blocks being launched; Db is of type dim3 (see dim3) and specifies the dimension and size of each block, such that Db.x * Db.y * Db.z equals the number of threads per block; Ns is of type size_t and specifies the number of bytes in shared memory that is dynamically allocated per block for this call in addition to the statically allocated memory; this dynamically allocated memory is used by any of the variables declared as an external array as mentioned in __shared__; Ns is an optional argument which defaults to 0; S is of type cudaStream_t and specifies the associated stream; S is an optional argument which defaults to 0.
      </li>
      <li class="li">
       As an example, a function declared asmust be called like this:The arguments to the execution configuration are evaluated before the actual function arguments.
      </li>
      <li class="li">
       The function call will fail if Dg or Db are greater than the maximum sizes allowed for the device as specified in Compute Capabilities, or if Ns is greater than the maximum amount of shared memory available on the device, minus the amount of shared memory required for static allocation.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="launch-bounds" xml:lang="en-US">
    <a name="launch-bounds" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#launch-bounds" name="launch-bounds" shape="rect">
      B.20. Launch Bounds
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       As discussed in detail in Multiprocessor Level, the fewer registers a kernel uses, the more threads and thread blocks are likely to reside on a multiprocessor, which can improve performance.
      </li>
      <li class="li">
       Therefore, the compiler uses heuristics to minimize register usage while keeping register spilling (see Device Memory Accesses) and instruction count to a minimum.
      </li>
      <li class="li">
       An application can optionally aid these heuristics by providing additional information to the compiler in the form of launch bounds that are specified using the __launch_bounds__() qualifier in the definition of a __global__ function: maxThreadsPerBlock specifies the maximum number of threads per block with which the application will ever launch MyKernel(); it compiles to the .maxntidPTX directive; minBlocksPerMultiprocessor is optional and specifies the desired minimum number of resident blocks per multiprocessor; it compiles to the .minnctapersmPTX directive.
      </li>
      <li class="li">
       If launch bounds are specified, the compiler first derives from them the upper limit L on the number of registers the kernel should use to ensure that minBlocksPerMultiprocessor blocks (or a single block if minBlocksPerMultiprocessor is not specified) of maxThreadsPerBlock threads can reside on the multiprocessor (see Hardware Multithreading for the relationship between the number of registers used by a kernel and the number of registers allocated per block).
      </li>
      <li class="li">
       The compiler then optimizes register usage in the following way: If the initial register usage is higher than L, the compiler reduces it further until it becomes less or equal to L, usually at the expense of more local memory usage and/or higher number of instructions; If the initial register usage is lower than L If maxThreadsPerBlock is specified and minBlocksPerMultiprocessor is not, the compiler uses maxThreadsPerBlock to determine the register usage thresholds for the transitions between n and n+1 resident blocks (i.e., when using one less register makes room for an additional resident block as in the example of Multiprocessor Level) and then applies similar heuristics as when no launch bounds are specified; If both minBlocksPerMultiprocessor and maxThreadsPerBlock are specified, the compiler may increase register usage as high as L to reduce the number of instructions and better hide single thread instruction latency.
      </li>
      <li class="li">
       A kernel will fail to launch if it is executed with more threads per block than its launch bound maxThreadsPerBlock.
      </li>
      <li class="li">
       Optimal launch bounds for a given kernel will usually differ across major architecture revisions.
      </li>
      <li class="li">
       The sample code below shows how this is typically handled in device code using the __CUDA_ARCH__ macro introduced in Application Compatibility In the common case where MyKernel is invoked with the maximum number of threads per block (specified as the first parameter of __launch_bounds__()), it is tempting to use MY_KERNEL_MAX_THREADS as the number of threads per block in the execution configuration: This will not work however since __CUDA_ARCH__ is undefined in host code as mentioned in Application Compatibility, so MyKernel will launch with 256 threads per block even when __CUDA_ARCH__ is greater or equal to 200.
      </li>
      <li class="li">
       Instead the number of threads per block should be determined: Either at compile time using a macro that does not depend on __CUDA_ARCH__, for example Or at runtime based on the compute capability Register usage is reported by the --ptxas options=-v compiler option.
      </li>
      <li class="li">
       The number of resident blocks can be derived from the occupancy reported by the CUDA profiler (see Device Memory Accessesfor a definition of occupancy).
      </li>
      <li class="li">
       Register usage can also be controlled for all __global__ functions in a file using the maxrregcount compiler option.
      </li>
      <li class="li">
       The value of maxrregcount is ignored for functions with launch bounds.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="pragma-unroll" xml:lang="en-US">
    <a name="pragma-unroll" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#pragma-unroll" name="pragma-unroll" shape="rect">
      B.21. #pragma unroll
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       By default, the compiler unrolls small loops with a known trip count.
      </li>
      <li class="li">
       The #pragma unroll directive however can be used to control unrolling of any given loop.
      </li>
      <li class="li">
       It must be placed immediately before the loop and only applies to that loop.
      </li>
      <li class="li">
       It is optionally followed by an integral constant expression (ICE)6.
      </li>
      <li class="li">
       If the ICE is absent, the loop will be completely unrolled if its trip count is constant.
      </li>
      <li class="li">
       If the ICE evaluates to 1, the compiler will not unroll the loop.
      </li>
      <li class="li">
       The pragma will be ignored if the ICE evaluates to a non-positive integer or to an integer greater than the maximum value representable by the int data type.
      </li>
      <li class="li">
       Examples:
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="simd-video" xml:lang="en-US">
    <a name="simd-video" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#simd-video" name="simd-video" shape="rect">
      B.22. SIMD Video Instructions
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       PTX ISA version 3.0 includes SIMD (Single Instruction, Multiple Data) video instructions which operate on pairs of 16-bit values and quads of 8-bit values.
      </li>
      <li class="li">
       These are available on devices of compute capability 3.0.
      </li>
      <li class="li">
       The SIMD video instructions are: vadd2, vadd4 vsub2, vsub4 vavrg2, vavrg4 vabsdiff2, vabsdiff4 vmin2, vmin4 vmax2, vmax4 vset2, vset4 PTX instructions, such as the SIMD video instructions, can be included in CUDA programs by way of the assembler, asm(), statement.
      </li>
      <li class="li">
       The basic syntax of an asm() statement is:An example of using the vabsdiff4 PTX instruction is: This uses the vabsdiff4 instruction to compute an integer quad byte SIMD sum of absolute differences.
      </li>
      <li class="li">
       The absolute difference value is computed for each byte of the unsigned integers A and B in SIMD fashion.
      </li>
      <li class="li">
       The optional accumulate operation (.add) is specified to sum these differences.
      </li>
      <li class="li">
       Refer to the document "Using Inline PTX Assembly in CUDA" for details on using the assembly statement in your code.
      </li>
      <li class="li">
       Refer to the PTX ISA documentation ("Parallel Thread Execution ISA Version 3.0" for example) for details on the PTX instructions for the version of PTX that you are using.
      </li>
     </ul>
    </div>
   </div>
  </div>
  <div class="topic concept nested1" id="cuda-dynamic-parallelism" xml:lang="en-US">
   <a name="cuda-dynamic-parallelism" shape="rect">
   </a>
   <h2 class="title topictitle1">
    <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#cuda-dynamic-parallelism" name="cuda-dynamic-parallelism" shape="rect">
     C. CUDA Dynamic Parallelism
    </a>
   </h2>
   <div class="topic concept nested2" id="introduction-cuda-dynamic-parallelism" xml:lang="en-US">
    <a name="introduction-cuda-dynamic-parallelism" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#introduction-cuda-dynamic-parallelism" name="introduction-cuda-dynamic-parallelism" shape="rect">
      C.1. Introduction
     </a>
    </h3>
    <div class="topic concept nested3" id="overview" xml:lang="en-US">
     <a name="overview" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#overview" name="overview" shape="rect">
       C.1.1. Overview
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Dynamic Parallelism is an extension to the CUDA programming model enabling a CUDA kernel to create and synchronize with new work directly on the GPU.
       </li>
       <li class="li">
        The creation of parallelism dynamically at whichever point in a program that it is needed offers exciting new capabilities.
       </li>
       <li class="li">
        The ability to create work directly from the GPU can reduce the need to transfer execution control and data between host and device, as launch configuration decisions can now be made at runtime by threads executing on the device.
       </li>
       <li class="li">
        Additionally, data-dependent parallel work can be generated inline within a kernel at run-time, taking advantage of the GPU's hardware schedulers and load balancers dynamically and adapting in response to data-driven decisions or workloads.
       </li>
       <li class="li">
        Algorithms and programming patterns that had previously required modifications to eliminate recursion, irregular loop structure, or other constructs that do not fit a flat, single-level of parallelism may more transparently be expressed.
       </li>
       <li class="li">
        This document describes the extended capabilities of CUDA which enable Dynamic Parallelism, including the modifications and additions to the CUDA programming model necessary to take advantage of these, as well as guidelines and best practices for exploiting this added capacity.
       </li>
       <li class="li">
        Dynamic Parallelism is only supported by devices of compute capability 3.5 and higher.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="glossary" xml:lang="en-US">
     <a name="glossary" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#glossary" name="glossary" shape="rect">
       C.1.2. Glossary
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Definitions for terms used in this guide.
       </li>
       <li class="li">
        Grid A Grid is a collection of Threads.
       </li>
       <li class="li">
        Threads in a Grid execute a Kernel Function and are divided into Thread Blocks.
       </li>
       <li class="li">
        Thread Block A Thread Block is a group of threads which execute on the same multiprocessor (SMX).
       </li>
       <li class="li">
        Threads within a Thread Block have access to shared memory and can be explicitly synchronized.
       </li>
       <li class="li">
        Kernel Function A Kernel Function is an implicitly parallel subroutine that executes under the CUDA execution and memory model for every Thread in a Grid.
       </li>
       <li class="li">
        Host The Host refers to the execution environment that initially invoked CUDA.
       </li>
       <li class="li">
        Typically the thread running on a system's CPU processor.
       </li>
       <li class="li">
        Parent A Parent Thread, Thread Block, or Grid is one that has launched new grid(s), the Child Grid(s).
       </li>
       <li class="li">
        The Parent is not considered completed until all of its launched Child Grids have also completed.
       </li>
       <li class="li">
        Child A Child thread, block, or grid is one that has been launched by a Parent grid.
       </li>
       <li class="li">
        A Child grid must complete before the Parent Thread, Thread Block, or Grid are considered complete.
       </li>
       <li class="li">
        Thread Block Scope Objects with Thread Block Scope have the lifetime of a single Thread Block.
       </li>
       <li class="li">
        They only have defined behavior when operated on by Threads in the Thread Block that created the object and are destroyed when the Thread Block that created them is complete.
       </li>
       <li class="li">
        Device Runtime The Device Runtime refers to the runtime system and APIs available to enable Kernel Functions to use Dynamic Parallelism.
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="execution-environment-and-memory-model" xml:lang="en-US">
    <a name="execution-environment-and-memory-model" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#execution-environment-and-memory-model" name="execution-environment-and-memory-model" shape="rect">
      C.2. Execution Environment and Memory Model
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
     </ul>
    </div>
    <div class="topic concept nested3" id="execution-environment" xml:lang="en-US">
     <a name="execution-environment" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#execution-environment" name="execution-environment" shape="rect">
       C.2.1. Execution Environment
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The CUDA execution model is based on primitives of threads, thread blocks, and grids, with kernel functions defining the program executed by individual threads within a thread block and grid.
       </li>
       <li class="li">
        When a kernel function is invoked the grid's properties are described by an execution configuration, which has a special syntax in CUDA.
       </li>
       <li class="li">
        Support for dynamic parallelism in CUDA extends the ability to configure, launch, and synchronize upon new grids to threads that are running on the device.
       </li>
      </ul>
     </div>
     <div class="topic concept nested4" id="parent-and-child-grids" xml:lang="en-US">
      <a name="parent-and-child-grids" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#parent-and-child-grids" name="parent-and-child-grids" shape="rect">
        C.2.1.1. Parent and Child Grids
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         A device thread that configures and launches a new grid belongs to the parent grid, and the grid created by the invocation is a child grid.
        </li>
        <li class="li">
         The invocation and completion of child grids is properly nested, meaning that the parent grid is not considered complete until all child grids created by its threads have completed.
        </li>
        <li class="li">
         Even if the invoking threads do not explicitly synchronize on the child grids launched, the runtime guarantees an implicit synchronization between the parent and child.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="scope-of-cuda-primitives" xml:lang="en-US">
      <a name="scope-of-cuda-primitives" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#scope-of-cuda-primitives" name="scope-of-cuda-primitives" shape="rect">
        C.2.1.2. Scope of CUDA Primitives
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         On both host and device, the CUDA runtime offers an API for launching kernels, for waiting for launched work to complete, and for tracking dependencies between launches via streams and events.
        </li>
        <li class="li">
         On the host system, the state of launches and the CUDA primitives referencing streams and events are shared by all threads within a process; however processes execute independently and may not share CUDA objects.
        </li>
        <li class="li">
         A similar hierarchy exists on the device: launched kernels and CUDA objects are visible to all threads in a thread block, but are independent between thread blocks.
        </li>
        <li class="li">
         This means for example that a stream may be created by one thread and used by any other thread in the same thread block, but may not be shared with threads in any other thread block.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="synchronization" xml:lang="en-US">
      <a name="synchronization" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#synchronization" name="synchronization" shape="rect">
        C.2.1.3. Synchronization
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         CUDA runtime operations from any thread, including kernel launches, are visible across a thread block.
        </li>
        <li class="li">
         This means that an invoking thread in the parent grid may perform synchronization on the grids launched by that thread, by other threads in the thread block, or on streams created within the same thread block.
        </li>
        <li class="li">
         Execution of a thread block is not considered complete until all launches by all threads in the block have completed.
        </li>
        <li class="li">
         If all threads in a block exit before all child launches have completed, a synchronization operation will automatically be triggered.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="streams-and-events" xml:lang="en-US">
      <a name="streams-and-events" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#streams-and-events" name="streams-and-events" shape="rect">
        C.2.1.4. Streams and Events
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         CUDA Streams and Events allow control over dependencies between grid launches: grids launched into the same stream execute in-order, and events may be used to create dependencies between streams.
        </li>
        <li class="li">
         Streams and events created on the device serve this exact same purpose.
        </li>
        <li class="li">
         Streams and events created within a grid exist within thread block scope but have undefined behavior when used outside of the thread block where they were created.
        </li>
        <li class="li">
         As described above, all work launched by a thread block is implicitly synchronized when the block exits; work launched into streams is included in this, with all dependencies resolved appropriately.
        </li>
        <li class="li">
         The behavior of operations on a stream that has been modified outside of thread block scope is undefined.
        </li>
        <li class="li">
         Streams and events created on the host have undefined behavior when used within any kernel, just as streams and events created by a parent grid have undefined behavior if used within a child grid.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="ordering-and-concurrency" xml:lang="en-US">
      <a name="ordering-and-concurrency" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#ordering-and-concurrency" name="ordering-and-concurrency" shape="rect">
        C.2.1.5. Ordering and Concurrency
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The ordering of kernel launches from the device runtime follows CUDA Stream ordering semantics.
        </li>
        <li class="li">
         Within a thread block, all kernel launches into the same stream are executed in-order.
        </li>
        <li class="li">
         With multiple threads in the same thread block launching into the same stream, the ordering within the stream is dependent on the thread scheduling within the block, which may be controlled with synchronization primitives such as __syncthreads().
        </li>
        <li class="li">
         Note that because streams are shared by all threads within a thread block, the implicit NULL stream is also shared.
        </li>
        <li class="li">
         If multiple threads in a thread block launch into the implicit stream, then these launches will be executed in-order.
        </li>
        <li class="li">
         If concurrency is desired, explicit named streams should be used.
        </li>
        <li class="li">
         Dynamic Parallelism enables concurrency to be expressed more easily within a program; however, the device runtime introduces no new concurrency guarantees within the CUDA execution model.
        </li>
        <li class="li">
         There is no guarantee of concurrent execution between any number of different thread blocks on a device.
        </li>
        <li class="li">
         The lack of concurrency guarantee extends to parent thread blocks and their child grids.
        </li>
        <li class="li">
         When a parent thread block launches a child grid, the child is not guaranteed to begin execution until the parent thread block reaches an explicit synchronization point (e.g.
        </li>
        <li class="li">
         cudaDeviceSynchronize()).
        </li>
        <li class="li">
         While concurrency will often easily be achieved, it may vary as a function of deviceconfiguration, application workload, and runtime scheduling.
        </li>
        <li class="li">
         It is therefore unsafe to depend upon any concurrency between different thread blocks.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="device-management" xml:lang="en-US">
      <a name="device-management" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#device-management" name="device-management" shape="rect">
        C.2.1.6. Device Management
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         There is no multi-GPU support from the device runtime; the device runtime is only capable of operating on the device upon which it is currently executing.
        </li>
        <li class="li">
         It is permitted, however, to query properties for any CUDA capable device in the system.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="memory-model" xml:lang="en-US">
     <a name="memory-model" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#memory-model" name="memory-model" shape="rect">
       C.2.2. Memory Model
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Parent and child grids share the same global and constant memory storage, but have distinct local and shared memory.
       </li>
      </ul>
     </div>
     <div class="topic concept nested4" id="coherence-and-consistency" xml:lang="en-US">
      <a name="coherence-and-consistency" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#coherence-and-consistency" name="coherence-and-consistency" shape="rect">
        C.2.2.1. Coherence and Consistency
       </a>
      </h3>
      <div class="topic concept nested5" id="global-memory" xml:lang="en-US">
       <a name="global-memory" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#global-memory" name="global-memory" shape="rect">
         C.2.2.1.1. Global Memory
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          Parent and child grids have coherent access to global memory, with weak consistency guarantees between child and parent.
         </li>
         <li class="li">
          There are two points in the execution of a child grid when its view of memory is fully consistent with the parent thread: when the child grid is invoked by the parent, and when the child grid completes as signaled by a synchronization API invocation in the parent thread.
         </li>
         <li class="li">
          All global memory operations in the parent thread prior to the child grid's invocation are visible to the child grid.
         </li>
         <li class="li">
          All memory operations of the child grid are visible to the parent after the parent has synchronized on the child grid's completion.
         </li>
         <li class="li">
          In the following example, the child grid executing child_launch is only guaranteed to see the modifications to data made before the child grid was launched.
         </li>
         <li class="li">
          Since thread 0 of the parent is performing the launch, the child will be consistent with the memory seen by thread 0 of the parent.
         </li>
         <li class="li">
          Due to the first __syncthreads() call, the child will see data[0]=0, data[1]=1, ..., data[255]=255 (without the __syncthreads() call, only data[0] would be guaranteed to be seen by the child).
         </li>
         <li class="li">
          When the child grid returns, thread 0 is guaranteed to see modifications made by the threads in its child grid.
         </li>
         <li class="li">
          Those modifications become available to the other threads of the parent grid only after the second __syncthreads() call:
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="zero-copy-memory" xml:lang="en-US">
       <a name="zero-copy-memory" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#zero-copy-memory" name="zero-copy-memory" shape="rect">
         C.2.2.1.2. Zero Copy Memory
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          Zero-copy system memory has identical coherence and consistency guarantees to global memory, and follows the semantics detailed above.
         </li>
         <li class="li">
          A kernel may not allocate or free zero-copy memory, but may use pointers to zero-copy passed in from the host program.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="constant-memory" xml:lang="en-US">
       <a name="constant-memory" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#constant-memory" name="constant-memory" shape="rect">
         C.2.2.1.3. Constant Memory
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          Constants are immutable and may not be modified from the device, even between parent and child launches.
         </li>
         <li class="li">
          That is to say, the value of all __constant__ variables must be set from the host prior to launch.
         </li>
         <li class="li">
          Constant memory is inherited automatically by all child kernels from their respective parents.
         </li>
         <li class="li">
          Taking the address of a constant memory object from within a kernel thread has the same semantics as for all CUDA programs, and passing that pointer from parent to child or from a child to parent is naturally supported.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="shared-and-local-memory" xml:lang="en-US">
       <a name="shared-and-local-memory" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#shared-and-local-memory" name="shared-and-local-memory" shape="rect">
         C.2.2.1.4. Shared and Local Memory
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          Shared and Local memory is private to a thread block or thread, respectively, and is not visible or coherent between parent and child.
         </li>
         <li class="li">
          Behavior is undefined when an object in one of these locations is referenced outside of the scope within which it belongs, and may cause an error.
         </li>
         <li class="li">
          The NVIDIA compiler will attempt to warn if it can detect that a pointer to local or shared memory is being passed as an argument to a kernel launch.
         </li>
         <li class="li">
          At runtime, the programmer may use the __isGlobal() intrinsic to determine whether a pointer references global memory and so may safely be passed to a child launch.
         </li>
         <li class="li">
          Note that calls to cudaMemcpy*Async() or cudaMemset*Async() may invoke new child kernels on the device in order to preserve stream semantics.
         </li>
         <li class="li">
          As such, passing shared or local memory pointers to these APIs is illegal and will return an error.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="local-memory" xml:lang="en-US">
       <a name="local-memory" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#local-memory" name="local-memory" shape="rect">
         C.2.2.1.5. Local Memory
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          Local memory is private storage for an executing thread, and is not visible outside of that thread.
         </li>
         <li class="li">
          It is illegal to pass a pointer to local memory as a launch argument when launching a child kernel.
         </li>
         <li class="li">
          The result of dereferencing such a local memory pointer from a child will be undefined.
         </li>
         <li class="li">
          For example the following is illegal, with undefined behavior if x_array is accessed by child_launch: It is sometimes difficult for a programmer to be aware of when a variable is placed into local memory by the compiler.
         </li>
         <li class="li">
          As a general rule, all storage passed to a child kernel should be allocated explicitly from the global-memory heap, either with cudaMalloc(), new() or by declaring __device__ storage at global scope.
         </li>
         <li class="li">
          For example:
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="texture-memory-cdp" xml:lang="en-US">
       <a name="texture-memory-cdp" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#texture-memory-cdp" name="texture-memory-cdp" shape="rect">
         C.2.2.1.6. Texture Memory
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          Writes to the global memory region over which a texture is mapped are incoherent with respect to texture accesses.
         </li>
         <li class="li">
          Coherence for texture memory is enforced at the invocation of a child grid and when a child grid completes.
         </li>
         <li class="li">
          This means that writes to memory prior to a child kernel launch are reflected in texture memory accesses of the child.
         </li>
         <li class="li">
          Similarly, writes to memory by a child will be reflected in the texture memory accesses by a parent, but only after the parent synchronizes on the child's completion.
         </li>
         <li class="li">
          Concurrent accesses by parent and child may result in inconsistent data.
         </li>
        </ul>
       </div>
      </div>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="programming-interface-cdp" xml:lang="en-US">
    <a name="programming-interface-cdp" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#programming-interface-cdp" name="programming-interface-cdp" shape="rect">
      C.3. Programming Interface
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
     </ul>
    </div>
    <div class="topic concept nested3" id="cuda-c-cplusplus" xml:lang="en-US">
     <a name="cuda-c-cplusplus" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#cuda-c-cplusplus" name="cuda-c-cplusplus" shape="rect">
       C.3.1. CUDA C/C++ Reference
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        This section describes changes and additions to the CUDA C/C++ language extensions for supporting Dynamic Parallelism.
       </li>
       <li class="li">
        The language interface and API available to CUDA kernels using CUDA C/C++ for Dynamic Parallelism, referred to as the Device Runtime, is substantially like that of the CUDA Runtime API available on the host.
       </li>
       <li class="li">
        Where possible the syntax and semantics of the CUDA Runtime API have been retained in order to facilitate ease of code reuse for routines that may run in either the host or device environments.
       </li>
       <li class="li">
        As with all code in CUDA C/C++, the APIs and code outlined here is per-thread code.
       </li>
       <li class="li">
        This enables each thread to make unique, dynamic decisions regarding what kernel or operation to execute next.
       </li>
       <li class="li">
        There are no synchronization requirements between threads within a block to execute any of the provided device runtime APIs, which enables the device runtime API functions to be called in arbitrarily divergent kernel code without deadlock.
       </li>
      </ul>
     </div>
     <div class="topic concept nested4" id="device-side-kernel-launch" xml:lang="en-US">
      <a name="device-side-kernel-launch" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#device-side-kernel-launch" name="device-side-kernel-launch" shape="rect">
        C.3.1.1. Device-Side Kernel Launch
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Kernels may be launched from the device using the standard CUDA &lt;&lt;&lt; &gt;&gt;&gt; syntax: Dg is of type dim3 and specifies the dimensions and size of the grid Db is of type dim3 and specifies the dimensions and size of each thread block Ns is of type size_t and specifies the number of bytes of shared memory that is dynamically allocated per thread block for this call and addition to statically allocated memory.
        </li>
        <li class="li">
         Ns is an optional argument that defaults to 0.
        </li>
        <li class="li">
         S is of type cudaStream_t and specifies the stream associated with this call.
        </li>
        <li class="li">
         The stream must have been allocated in the same thread block where the call is being made.
        </li>
        <li class="li">
         S is an optional argument that defaults to 0.
        </li>
       </ul>
      </div>
      <div class="topic concept nested5" id="launches-are-asynchronous" xml:lang="en-US">
       <a name="launches-are-asynchronous" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#launches-are-asynchronous" name="launches-are-asynchronous" shape="rect">
         C.3.1.1.1. Launches are Asynchronous
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          Identical to host-side launches, all device-side kernel launches are asynchronous with respect to the launching thread.
         </li>
         <li class="li">
          That is to say, the &lt;&lt;&lt;&gt;&gt;&gt; launch command will return immediately and the launching thread will continue to execute until it hits an explicit launch-synchronization point such as cudaDeviceSynchronize().
         </li>
         <li class="li">
          The grid launch is posted to the device and will execute independently of the parent thread.
         </li>
         <li class="li">
          The child grid may begin execution at any time after launch, but is not guaranteed to begin execution until the launching thread reaches an explicit launch-synchronization point.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="launch-environment-configuration" xml:lang="en-US">
       <a name="launch-environment-configuration" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#launch-environment-configuration" name="launch-environment-configuration" shape="rect">
         C.3.1.1.2. Launch Environment Configuration
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          All global device configuration settings (e.g., shared memory and L1 cache size as returned from cudaDeviceGetCacheConfig(), and device limits returned from cudaDeviceGetLimit()) will be inherited from the parent.
         </li>
         <li class="li">
          That is to say if, when the parent is launched, execution is configured globally for 16k of shared memory and 48k of L1 cache, then the child's execution state will be configured identically.
         </li>
         <li class="li">
          Likewise, device limits such as stack size will remain as-configured.
         </li>
         <li class="li">
          For host-launched kernels, per-kernel configurations set from the host will take precedence over the global setting.
         </li>
         <li class="li">
          These configurations will be used when the kernel is launched from the device as well.
         </li>
         <li class="li">
          It is not possible to reconfigure a kernel's environment from the device.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="launch-from-host-device-functions" xml:lang="en-US">
       <a name="launch-from-host-device-functions" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#launch-from-host-device-functions" name="launch-from-host-device-functions" shape="rect">
         C.3.1.1.3. Launch from __host__ __device__ Functions
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          Although the device runtime enables kernel launches from either the host or device, kernel launches from __host__ __device__ functions are unsupported.
         </li>
         <li class="li">
          The compiler will fail to compile if a __host__ device__ function is used to launch a kernel.
         </li>
        </ul>
       </div>
      </div>
     </div>
     <div class="topic concept nested4" id="streams-cdp" xml:lang="en-US">
      <a name="streams-cdp" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#streams-cdp" name="streams-cdp" shape="rect">
        C.3.1.2. Streams
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Both named and unnamed (NULL) streams are available from the device runtime.
        </li>
        <li class="li">
         Named streams may be used by any thread within a thread-block, but stream handles may not be passed to other blocks or child/parent kernels.
        </li>
        <li class="li">
         In other words, a stream should be treated as private to the block in which it is created.
        </li>
        <li class="li">
         Stream handles are not guaranteed to be unique between blocks, so using a stream handle within a block that did not allocate it will result in undefined behavior.
        </li>
        <li class="li">
         Similar to host-side launch, work launched into separate streams may run concurrently, but actual concurrency is not guaranteed.
        </li>
        <li class="li">
         Programs that depend upon concurrency between child kernels are not supported by the CUDA programming model and will have undefined behavior.
        </li>
        <li class="li">
         The host-side NULL stream's cross-stream barrier semantic is not supported on the device (see below for details).
        </li>
        <li class="li">
         In order to retain semantic compatibility with the host runtime, all device streams must be created using the cudaStreamCreateWithFlags() API, passing the cudaStreamNonBlocking flag.
        </li>
        <li class="li">
         The cudaStreamCreate() call is a host-runtime- only API and will fail to compile for the device.
        </li>
        <li class="li">
         As cudaStreamSynchronize() and cudaStreamQuery() are unsupported by the device runtime, cudaDeviceSynchronize() should be used instead when the application needs to know that stream-launched child kernels have completed.
        </li>
       </ul>
      </div>
      <div class="topic concept nested5" id="implicit-null-stream" xml:lang="en-US">
       <a name="implicit-null-stream" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#implicit-null-stream" name="implicit-null-stream" shape="rect">
         C.3.1.2.1. The Implicit (NULL) Stream
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          Within a host program, the unnamed (NULL) stream has additional barrier synchronization semantics with other streams (see Default Stream for details).
         </li>
         <li class="li">
          The device runtime offers a single implicit, unnamed stream shared between all threads in a block, but as all named streams must be created with the cudaStreamNonBlocking flag, work launched into the NULL stream will not insert an implicit dependency on pending work in any other streams.
         </li>
        </ul>
       </div>
      </div>
     </div>
     <div class="topic concept nested4" id="events-cdp" xml:lang="en-US">
      <a name="events-cdp" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#events-cdp" name="events-cdp" shape="rect">
        C.3.1.3. Events
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Only the inter-stream synchronization capabilities of CUDA events are supported.
        </li>
        <li class="li">
         This means that cudaStreamWaitEvent() is supported, but cudaEventSynchronize(), cudaEventElapsedTime(), and cudaEventQuery() are not.
        </li>
        <li class="li">
         As cudaEventElapsedTime() is not supported, cudaEvents must be created via cudaEventCreateWithFlags(), passing the cudaEventDisableTiming flag.
        </li>
        <li class="li">
         As for all device runtime objects, event objects may be shared between all threads withinthe thread-block which created them but are local to that block and may not be passed to other kernels, or between blocks within the same kernel.
        </li>
        <li class="li">
         Event handles are not guaranteed to be unique between blocks, so using an event handle within a block that did not create it will result in undefined behavior.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="synchronization-programming-interface" xml:lang="en-US">
      <a name="synchronization-programming-interface" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#synchronization-programming-interface" name="synchronization-programming-interface" shape="rect">
        C.3.1.4. Synchronization
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The cudaDeviceSynchronize() function will synchronize on all work launched by any thread in the thread-block up to the point where cudaDeviceSynchronize() was called.
        </li>
        <li class="li">
         Note that cudaDeviceSynchronize() may be called from within divergent code (see Block Wide Synchronization).
        </li>
        <li class="li">
         It is up to the program to perform sufficient additional inter-thread synchronization, for example via a call to __syncthreads(), if the calling thread is intended to synchronize with child grids invoked from other threads.
        </li>
       </ul>
      </div>
      <div class="topic concept nested5" id="block-wide-synchronization" xml:lang="en-US">
       <a name="block-wide-synchronization" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#block-wide-synchronization" name="block-wide-synchronization" shape="rect">
         C.3.1.4.1. Block Wide Synchronization
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          The cudaDeviceSynchronize() function does not imply intra-block synchronization.
         </li>
         <li class="li">
          In particular, without explicit synchronization via a __syncthreads() directive the calling thread can make no assumptions about what work has been launched by any thread other than itself.
         </li>
         <li class="li">
          For example if multiple threads within a block are each launching work and synchronization is desired for all this work at once (perhaps because of event-based dependencies), it is up to the program to guarantee that this work is submitted by all threads before calling cudaDeviceSynchronize().
         </li>
         <li class="li">
          Because the implementation is permitted to synchronize on launches from any thread in the block, it is quite possible that simultaneous calls to cudaDeviceSynchronize() by multiple threads will drain all work in the first call and then have no effect for the later calls.
         </li>
        </ul>
       </div>
      </div>
     </div>
     <div class="topic concept nested4" id="device-management-programming" xml:lang="en-US">
      <a name="device-management-programming" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#device-management-programming" name="device-management-programming" shape="rect">
        C.3.1.5. Device Management
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Only the device on which a kernel is running will be controllable from that kernel.
        </li>
        <li class="li">
         This means that device APIs such as cudaSetDevice() are not supported by the device runtime.
        </li>
        <li class="li">
         The active device as seen from the GPU (returned from cudaGetDevice()) will have the same device number as seen from the host system.
        </li>
        <li class="li">
         The cudaGetDeviceProperty() call may request information about another device as this API allows specification of a device ID as a parameter of the call.
        </li>
        <li class="li">
         Note that the catch-all cudaGetDeviceProperties() API is not offered by the device runtime - properties must be queried individually.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="memory-declarations" xml:lang="en-US">
      <a name="memory-declarations" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#memory-declarations" name="memory-declarations" shape="rect">
        C.3.1.6. Memory Declarations
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
       </ul>
      </div>
      <div class="topic concept nested5" id="device-and-constant-memory" xml:lang="en-US">
       <a name="device-and-constant-memory" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#device-and-constant-memory" name="device-and-constant-memory" shape="rect">
         C.3.1.6.1. Device and Constant Memory
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          Memory declared at file scope with __device__ or __constant__ qualifiers behave identically when using the device runtime.
         </li>
         <li class="li">
          All kernels may read or write device variables, whether the kernel was initially launched by the host or device runtime.
         </li>
         <li class="li">
          Equivalently, all kernels will have the same view of __constant__s as declared at the module scope.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="textures-and-surfaces" xml:lang="en-US">
       <a name="textures-and-surfaces" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#textures-and-surfaces" name="textures-and-surfaces" shape="rect">
         C.3.1.6.2. Textures &amp; Surfaces
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          CUDA supports dynamically created texture and surface objects1, where a texture reference may be created on the host, passed to a kernel, used by that kernel, and then destroyed from the host.
         </li>
         <li class="li">
          The device runtime does not allow creation or destruction of texture or surface objects from within device code, but texture and surface objects created from the host may be used and passed around freely on the device.
         </li>
         <li class="li">
          Regardless of where they are created, dynamically created texture objects are always valid and may be passed to child kernels from a parent.
         </li>
         <li class="li">
          The device runtime does not support legacy module-scope (i.e., Fermi-style) textures and surfaces within a kernel launched from the device.
         </li>
         <li class="li">
          Module-scope (legacy) textures may be created from the host and used in device code as for any kernel, but may only be used by a top-level kernel (i.e., the one which is launched from the host).
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="shared-memory-variable-declarations" xml:lang="en-US">
       <a name="shared-memory-variable-declarations" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#shared-memory-variable-declarations" name="shared-memory-variable-declarations" shape="rect">
         C.3.1.6.3. Shared Memory Variable Declarations
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          In CUDA C/C++ shared memory can be declared either as a statically sized file-scope or function-scoped variable, or as an extern variable with the size determined at runtime by the kernel's caller via a launch configuration argument.
         </li>
         <li class="li">
          Both types of declarations are valid under the device runtime.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="symbol-addresses" xml:lang="en-US">
       <a name="symbol-addresses" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#symbol-addresses" name="symbol-addresses" shape="rect">
         C.3.1.6.4. Symbol Addresses
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          Device-side symbols (i.e., those marked __device__) may be referenced from within a kernel simply via the &amp; operator, as all global-scope device variables are in the kernel's visible address space.
         </li>
         <li class="li">
          This also applies to __constant__ symbols, although in this case the pointer will reference read-only data.
         </li>
         <li class="li">
          Given that device-side symbols can be referenced directly, those CUDA runtime APIs which reference symbols (e.g., cudaMemcpyToSymbol() or cudaGetSymbolAddress()) are redundant and hence not supported by the device runtime.
         </li>
         <li class="li">
          Note this implies that constant data cannot be altered from within a running kernel, even ahead of a child kernel launch, as references to __constant__ space are read-only.
         </li>
        </ul>
       </div>
      </div>
     </div>
     <div class="topic concept nested4" id="api-errors-and-launch-failures" xml:lang="en-US">
      <a name="api-errors-and-launch-failures" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#api-errors-and-launch-failures" name="api-errors-and-launch-failures" shape="rect">
        C.3.1.7. API Errors and Launch Failures
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         As usual for the CUDA runtime, any function may return an error code.
        </li>
        <li class="li">
         The last error code returned is recorded and may be retrieved via the cudaGetLastError() call.
        </li>
        <li class="li">
         Errors are recorded per-thread, so that each thread can identify the most recent error that it has generated.
        </li>
        <li class="li">
         The error code is of type cudaError_t.
        </li>
        <li class="li">
         Similar to a host-side launch, device-side launches may fail for many reasons (invalid arguments, etc).
        </li>
        <li class="li">
         The user must call cudaGetLastError() to determine if a launch generated an error, however lack of an error after launch does not imply the child kernel completed successfully.
        </li>
        <li class="li">
         For device-side exceptions, e.g., access to an invalid address, an error in a child grid will be returned to the host instead of being returned by the parent's call to cudaDeviceSynchronize().
        </li>
       </ul>
      </div>
      <div class="topic concept nested5" id="launch-setup-apis" xml:lang="en-US">
       <a name="launch-setup-apis" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#launch-setup-apis" name="launch-setup-apis" shape="rect">
         C.3.1.7.1. Launch Setup APIs
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          Kernel launch is a system-level mechanism exposed through the device runtime library, and as such is available directly from PTX via the underlying cudaGetParameterBuffer() and cudaLaunchDevice() APIs.
         </li>
         <li class="li">
          It is permitted for a CUDA application to call these APIs itself, with the same requirements as for PTX.
         </li>
         <li class="li">
          In both cases, the user is then responsible for correctly populating all necessary data structures in the correct format according to specification.
         </li>
         <li class="li">
          Backwards compatibility is guaranteed in these data structures.
         </li>
         <li class="li">
          As with host-side launch, the device-side operator &lt;&lt;&lt;&gt;&gt;&gt; maps to underlying kernel launch APIs.
         </li>
         <li class="li">
          This is so that users targeting PTX will be able to enact a launch, and so that the compiler front-end can translate &lt;&lt;&lt;&gt;&gt;&gt; into these calls.
         </li>
         <li class="li">
          The APIs for these launch functions are different to those of the CUDA Runtime API, and are defined as follows:
         </li>
        </ul>
       </div>
      </div>
     </div>
     <div class="topic concept nested4" id="api-reference" xml:lang="en-US">
      <a name="api-reference" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#api-reference" name="api-reference" shape="rect">
        C.3.1.8. API Reference
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The portions of the CUDA Runtime API supported in the device runtime are detailed here.
        </li>
        <li class="li">
         Host and device runtime APIs have identical syntax; semantics are the same except where indicated.
        </li>
        <li class="li">
         The table below provides an overview of the API relative to the version available from the host.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="device-side-launch-from-ptx" xml:lang="en-US">
     <a name="device-side-launch-from-ptx" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#device-side-launch-from-ptx" name="device-side-launch-from-ptx" shape="rect">
       C.3.2. Device-side Launch from PTX
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        This section is for the programming language and compiler implementers who target Parallel Thread Execution (PTX) and plan to support Dynamic Parallelism in their language.
       </li>
       <li class="li">
        It provides the low-level details related to supporting kernel launches at the PTX level.
       </li>
      </ul>
     </div>
     <div class="topic concept nested4" id="kernel-launch-apis" xml:lang="en-US">
      <a name="kernel-launch-apis" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#kernel-launch-apis" name="kernel-launch-apis" shape="rect">
        C.3.2.1. Kernel Launch APIs
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Device-side kernel launches can be implemented using the following two APIs accessible from PTX: cudaLaunchDevice() and cudaGetParameterBuffer().
        </li>
        <li class="li">
         cudaLaunchDevice() launches the specified kernel with the parameter buffer that is obtained by calling cudaGetParameterBuffer() and filled with the parameters to the launched kernel.
        </li>
        <li class="li">
         The parameter buffer can be NULL, i.e., no need to invoke cudaGetParameterBuffer(), if the launched kernel does not take any parameters.
        </li>
       </ul>
      </div>
      <div class="topic concept nested5" id="cudalaunchdevice" xml:lang="en-US">
       <a name="cudalaunchdevice" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#cudalaunchdevice" name="cudalaunchdevice" shape="rect">
         C.3.2.1.1. cudaLaunchDevice
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          At the PTX level, cudaLaunchDevice()needs to be declared in one of the two forms shown below before it is used.
         </li>
         <li class="li">
          The CUDA-level declaration below is mapped to one of the aforementioned PTX-level declarations and is found in the system header file cuda_device_runtime_api.h.
         </li>
         <li class="li">
          The function is defined in the cudadevrt system library, which must be linked with a program in order to use device-side kernel launch functionality.
         </li>
         <li class="li">
          The first parameter is a pointer to the kernel to be is launched, and the second parameter is the parameter buffer that holds the actual parameters to the launched kernel.
         </li>
         <li class="li">
          The layout of the parameter buffer is explained in Parameter Buffer Layout, below.
         </li>
         <li class="li">
          Other parameters specify the launch configuration, i.e., as grid dimension, block dimension, shared memory size, and the stream associated with the launch (please refer to Execution Configuration for the detailed description of launch configuration.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="cudagetparameterbuffer" xml:lang="en-US">
       <a name="cudagetparameterbuffer" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#cudagetparameterbuffer" name="cudagetparameterbuffer" shape="rect">
         C.3.2.1.2. cudaGetParameterBuffer
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          cudaGetParameterBuffer() needs to be declared at the PTX level before it's used.
         </li>
         <li class="li">
          The PTX-level declaration must be in one of the two forms given below, depending on address size: The following CUDA-level declaration of cudaGetParameterBuffer() is mapped to the aforementioned PTX-level declaration: The first parameter specifies the alignment requirement of the parameter buffer and the second parameter the size requirement in bytes.
         </li>
         <li class="li">
          In the current implementation, the parameter buffer returned by cudaGetParameterBuffer() is always guaranteed to be 64- byte aligned, and the alignment requirement parameter is ignored.
         </li>
         <li class="li">
          However, it is recommended to pass the correct alignment requirement value - which is the largest alignment of any parameter to be placed in the parameter buffer - to cudaGetParameterBuffer() to ensure portability in the future.
         </li>
        </ul>
       </div>
      </div>
     </div>
     <div class="topic concept nested4" id="parameter-buffer-layout" xml:lang="en-US">
      <a name="parameter-buffer-layout" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#parameter-buffer-layout" name="parameter-buffer-layout" shape="rect">
        C.3.2.2. Parameter Buffer Layout
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Parameter reordering in the parameter buffer is prohibited, and each individual parameter placed in the parameter buffer is required to be aligned.
        </li>
        <li class="li">
         That is, each parameter must be placed at the nth byte in the parameter buffer, where n is the smallest multiple of the parameter size that is greater than the offset of the last byte taken by the preceding parameter.
        </li>
        <li class="li">
         The maximum size of the parameter buffer is 4KB.
        </li>
        <li class="li">
         For a more detailed description of PTX code generated by the CUDA compiler, please refer to the PTX-3.5 specification.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="toolkit-support-for-dynamic-parallelism" xml:lang="en-US">
     <a name="toolkit-support-for-dynamic-parallelism" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#toolkit-support-for-dynamic-parallelism" name="toolkit-support-for-dynamic-parallelism" shape="rect">
       C.3.3. Toolkit Support for Dynamic Parallelism
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
      </ul>
     </div>
     <div class="topic concept nested4" id="including-device-runtime-api-in-cuda-code" xml:lang="en-US">
      <a name="including-device-runtime-api-in-cuda-code" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#including-device-runtime-api-in-cuda-code" name="including-device-runtime-api-in-cuda-code" shape="rect">
        C.3.3.1. Including Device Runtime API in CUDA Code
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Similar to the host-side runtime API, prototypes for the CUDA device runtime API are included automatically during program compilation.
        </li>
        <li class="li">
         There is no need to include cuda_device_runtime_api.h explicitly.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="compiling-and-linking" xml:lang="en-US">
      <a name="compiling-and-linking" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#compiling-and-linking" name="compiling-and-linking" shape="rect">
        C.3.3.2. Compiling and Linking
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         CUDA programs are automatically linked with the host runtime library when compiled with nvcc, but the device runtime is shipped as a static library which must explicitly be linked with a program which wishes to use it.
        </li>
        <li class="li">
         The device runtime is offered as a static library (cudadevrt.lib on Windows, libcudadevrt.a under Linux and MacOS), against which a GPU application that uses the device runtime must be linked.
        </li>
        <li class="li">
         Linking of device libraries can be accomplished through nvcc and/or nvlink.
        </li>
        <li class="li">
         Two simple examples are shown below.
        </li>
        <li class="li">
         A device runtime program may be compiled and linked in a single step, if all required source files can be specified from the command line: It is also possible to compile CUDA .cu source files first to object files, and then link these together in a two-stage process: Please see the Using Separate Compilation section of The CUDA Driver Compiler NVCC guide for more details.
        </li>
       </ul>
      </div>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="programming-guidelines" xml:lang="en-US">
    <a name="programming-guidelines" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#programming-guidelines" name="programming-guidelines" shape="rect">
      C.4. Programming Guidelines
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
     </ul>
    </div>
    <div class="topic concept nested3" id="basics" xml:lang="en-US">
     <a name="basics" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#basics" name="basics" shape="rect">
       C.4.1. Basics
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The device runtime is a functional subset of the host runtime.
       </li>
       <li class="li">
        API level device management, kernel launching, device memcpy, stream management, and event management are exposed from the device runtime.
       </li>
       <li class="li">
        Programming for the device runtime should be familiar to someone who already has experience with CUDA.
       </li>
       <li class="li">
        Device runtime syntax and semantics are largely the same as that of the host API, with any exceptions detailed earlier in this document.
       </li>
       <li class="li">
        The following example shows a simple Hello World program incorporating dynamic parallelism: This program may be built in a single step from the command line as follows:
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="performance" xml:lang="en-US">
     <a name="performance" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#performance" name="performance" shape="rect">
       C.4.2. Performance
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
      </ul>
     </div>
     <div class="topic concept nested4" id="synchronization-performance" xml:lang="en-US">
      <a name="synchronization-performance" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#synchronization-performance" name="synchronization-performance" shape="rect">
        C.4.2.1. Synchronization
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Synchronization by one thread may impact the performance of other threads in the same Thread Block, even when those other threads do not call cudaDeviceSynchronize() themselves.
        </li>
        <li class="li">
         This impact will depend upon the underlying implementation.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="dynamic-parallelism-enabled-kernel-overhead" xml:lang="en-US">
      <a name="dynamic-parallelism-enabled-kernel-overhead" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#dynamic-parallelism-enabled-kernel-overhead" name="dynamic-parallelism-enabled-kernel-overhead" shape="rect">
        C.4.2.2. Dynamic-parallelism-enabled Kernel Overhead
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         System software which is active when controlling dynamic launches may impose an overhead on any kernel which is running at the time, whether or not it invokes kernel launches of its own.
        </li>
        <li class="li">
         This overhead arises from the device runtime's execution tracking and management software and may result in decreased performance for e.g., library calls when made from the device compared to from the host side.
        </li>
        <li class="li">
         This overhead is, in general, incurred for applications that link against the device runtime library.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="implementation-restrictions-and-limitations" xml:lang="en-US">
     <a name="implementation-restrictions-and-limitations" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#implementation-restrictions-and-limitations" name="implementation-restrictions-and-limitations" shape="rect">
       C.4.3. Implementation Restrictions and Limitations
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Dynamic Parallelism guarantees all semantics described in this document, however, certain hardware and software resources are implementation-dependent and limit the scale, performance and other properties of a program which uses the device runtime.
       </li>
      </ul>
     </div>
     <div class="topic concept nested4" id="runtime" xml:lang="en-US">
      <a name="runtime" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#runtime" name="runtime" shape="rect">
        C.4.3.1. Runtime
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
       </ul>
      </div>
      <div class="topic concept nested5" id="memory-footprint" xml:lang="en-US">
       <a name="memory-footprint" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#memory-footprint" name="memory-footprint" shape="rect">
         C.4.3.1.1. Memory Footprint
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          The device runtime system software reserves memory for various management purposes, in particular one reservation which is used for saving parent-grid state during synchronization, and a second reservation for tracking pending grid launches.
         </li>
         <li class="li">
          Configuration controls are available to reduce the size of these reservations in exchange for certain launch limitations.
         </li>
         <li class="li">
          See Configuration Options, below, for details.
         </li>
         <li class="li">
          The majority of reserved memory is allocated as backing-store for parent kernel state, for use when synchronizing on a child launch.
         </li>
         <li class="li">
          Conservatively, this memory must support storing of state for the maximum number of live threads possible on the device.
         </li>
         <li class="li">
          This means that each parent generation at which cudaDeviceSynchronize() is callable may require up to 150MB of device memory, depending on the device configuration, which will be unavailable for program use even if it is not all consumed.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="nesting-and-synchronization-depth" xml:lang="en-US">
       <a name="nesting-and-synchronization-depth" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#nesting-and-synchronization-depth" name="nesting-and-synchronization-depth" shape="rect">
         C.4.3.1.2. Nesting and Synchronization Depth
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          Using the device runtime, one kernel may launch another kernel, and that kernel may launch another, and so on.
         </li>
         <li class="li">
          Each subordinate launch is considered a new nesting level, and the total number of levels is the nesting depth of the program.
         </li>
         <li class="li">
          The synchronization depth is defined as the deepest level at which the program will explicitly synchronize on a child launch.
         </li>
         <li class="li">
          Typically this is one less than the nesting depth of the program, but if the program does not need to call cudaDeviceSynchronize() at all levels then the synchronization depth might be substantially different to the nesting depth.
         </li>
         <li class="li">
          The overall maximum nesting depth is limited to 24, but practically speaking the real limit will be the amount of memory required by the system for each new level (see Memory Footprint above).
         </li>
         <li class="li">
          Any launch which would result in a kernel at a deeper level than the maximum will fail.
         </li>
         <li class="li">
          Note that this may also apply to cudaMemcpyAsync(), which might itself generate a kernel launch.
         </li>
         <li class="li">
          See Configuration Options for details.
         </li>
         <li class="li">
          By default, sufficient storage is reserved for two levels of synchronization.
         </li>
         <li class="li">
          This maximum synchronization depth (and hence reserved storage) may be controlled by calling cudaDeviceSetLimit() and specifying cudaLimitDevRuntimeSyncDepth.
         </li>
         <li class="li">
          The number of levels to be supported must be configured before the top-level kernel is launched from the host, in order to guarantee successful execution of a nested program.
         </li>
         <li class="li">
          Calling cudaDeviceSynchronize() at a depth greater than the specified maximum synchronization depth will return an error.
         </li>
         <li class="li">
          An optimization is permitted where the system detects that it need not reserve space for the parent's state in cases where the parent kernel never calls cudaDeviceSynchronize().
         </li>
         <li class="li">
          In this case, because explicit parent/child synchronization never occurs, the memory footprint required for a program will be much less than the conservative maximum.
         </li>
         <li class="li">
          Such a program could specify a shallower maximum synchronization depth to avoid over-allocation of backing store.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="pending-kernel-launches" xml:lang="en-US">
       <a name="pending-kernel-launches" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#pending-kernel-launches" name="pending-kernel-launches" shape="rect">
         C.4.3.1.3. Pending Kernel Launches
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          When a kernel is launched, all associated configuration and parameter data is tracked until the kernel completes.
         </li>
         <li class="li">
          This data is stored within a system-managed launch pool.
         </li>
         <li class="li">
          The launch pool is divided into a fixed-size pool and a virtualized pool with lower performance.
         </li>
         <li class="li">
          The device runtime system software will try to track launch data in the fixed-size pool first.
         </li>
         <li class="li">
          The virtualized pool will be used to track new launches when the fixed-size pool is full.
         </li>
         <li class="li">
          The size of the fixed-size launch pool is configurable by calling cudaDeviceSetLimit() from the host and specifying cudaLimitDevRuntimePendingLaunchCount.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="configuration-options" xml:lang="en-US">
       <a name="configuration-options" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#configuration-options" name="configuration-options" shape="rect">
         C.4.3.1.4. Configuration Options
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          Resource allocation for the device runtime system software is controlled via the cudaDeviceSetLimit() API from the host program.
         </li>
         <li class="li">
          Limits must be set before any kernel is launched, and may not be changed while the GPU is actively running programs.
         </li>
         <li class="li">
          The following named limits may be set:
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="memory-allocation-and-lifetime" xml:lang="en-US">
       <a name="memory-allocation-and-lifetime" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#memory-allocation-and-lifetime" name="memory-allocation-and-lifetime" shape="rect">
         C.4.3.1.5. Memory Allocation and Lifetime
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          cudaMalloc() and cudaFree() have distinct semantics between the host and device environments.
         </li>
         <li class="li">
          When invoked from the host, cudaMalloc() allocates a new region from unused device memory.
         </li>
         <li class="li">
          When invoked from the device runtime these functions map to device-side malloc() and free().
         </li>
         <li class="li">
          This implies that within the device environment the total allocatable memory is limited to the device malloc() heap size, which may be smaller than the available unused device memory.
         </li>
         <li class="li">
          Also, it is an error to invoke cudaFree() from the host program on a pointer which was allocated by cudaMalloc() on the device or vice-versa.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="sm-id-and-warp-id" xml:lang="en-US">
       <a name="sm-id-and-warp-id" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#sm-id-and-warp-id" name="sm-id-and-warp-id" shape="rect">
         C.4.3.1.6. SM Id and Warp Id
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          Note that in PTX %smid and %warpid are defined as volatile values.
         </li>
         <li class="li">
          The device runtime may reschedule thread blocks onto different SMs in order to more efficiently manage resources.
         </li>
         <li class="li">
          As such, it is unsafe to rely upon %smid or %warpid remaining unchanged across the lifetime of a thread or thread block.
         </li>
        </ul>
       </div>
      </div>
      <div class="topic concept nested5" id="ecc-errors" xml:lang="en-US">
       <a name="ecc-errors" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#ecc-errors" name="ecc-errors" shape="rect">
         C.4.3.1.7. ECC Errors
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          No notification of ECC errors is available to code within a CUDA kernel.
         </li>
         <li class="li">
          ECC errors are reported at the host side once the entire launch tree has completed.
         </li>
         <li class="li">
          Any ECC errors which arise during execution of a nested program will either generate an exception or continue execution (depending upon error and configuration).
         </li>
        </ul>
       </div>
      </div>
     </div>
    </div>
   </div>
  </div>
  <div class="topic concept nested1" id="mathematical-functions-appendix" xml:lang="en-US">
   <a name="mathematical-functions-appendix" shape="rect">
   </a>
   <h2 class="title topictitle1">
    <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#mathematical-functions-appendix" name="mathematical-functions-appendix" shape="rect">
     D. Mathematical Functions
    </a>
   </h2>
   <div class="body conbody">
    <ul class="ul">
     <li class="li">
      The reference manual lists, along with their description, all the functions of the C/C++ standard library mathematical functions that are supported in device code, as well as all intrinsic functions (that are only supported in device code).
     </li>
     <li class="li">
      This appendix provides accuracy information for some of these functions when applicable.
     </li>
    </ul>
   </div>
   <div class="topic concept nested2" id="standard-functions" xml:lang="en-US">
    <a name="standard-functions" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#standard-functions" name="standard-functions" shape="rect">
      D.1. Standard Functions
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       The functions from this section can be used in both host and device code.
      </li>
      <li class="li">
       This section specifies the error bounds of each function when executed on the device and also when executed on the host in the case where the host does not supply the function.
      </li>
      <li class="li">
       The error bounds are generated from extensive but not exhaustive tests, so they are not guaranteed bounds.
      </li>
      <li class="li">
       Addition and multiplication are IEEE-compliant, so have a maximum error of 0.5 ulp.
      </li>
      <li class="li">
       The recommended way to round a single-precision floating-point operand to an integer, with the result being a single-precision floating-point number is rintf(), not roundf().
      </li>
      <li class="li">
       The reason is that roundf() maps to an 8-instruction sequence on the device, whereas rintf() maps to a single instruction.
      </li>
      <li class="li">
       truncf(), ceilf(), and floorf() each map to a single instruction as well.
      </li>
      <li class="li">
       The recommended way to round a double-precision floating-point operand to an integer, with the result being a double-precision floating-point number is rint(), not round().
      </li>
      <li class="li">
       The reason is that round() maps to an 8-instruction sequence on the device, whereas rint() maps to a single instruction.
      </li>
      <li class="li">
       trunc(), ceil(), and floor() each map to a single instruction as well.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="intrinsic-functions" xml:lang="en-US">
    <a name="intrinsic-functions" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#intrinsic-functions" name="intrinsic-functions" shape="rect">
      D.2. Intrinsic Functions
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       The functions from this section can only be used in device code.
      </li>
      <li class="li">
       Among these functions are the less accurate, but faster versions of some of the functions of Standard Functions .They have the same name prefixed with __ (such as __sinf(x)).
      </li>
      <li class="li">
       They are faster as they map to fewer native instructions.
      </li>
      <li class="li">
       The compiler has an option (-use_fast_math) that forces each function in Table 8 to compile to its intrinsic counterpart.
      </li>
      <li class="li">
       In addition to reducing the accuracy of the affected functions, it may also cause some differences in special case handling.
      </li>
      <li class="li">
       A more robust approach is to selectively replace mathematical function calls by calls to intrinsic functions only where it is merited by the performance gains and where changed properties such as reduced accuracy and different special case handling can be tolerated.
      </li>
      <li class="li">
       Functions suffixed with _rn operate using the round to nearest even rounding mode.
      </li>
      <li class="li">
       Functions suffixed with _rz operate using the round towards zero rounding mode.
      </li>
      <li class="li">
       Functions suffixed with _ru operate using the round up (to positive infinity) rounding mode.
      </li>
      <li class="li">
       Functions suffixed with _rd operate using the round down (to negative infinity) rounding mode.
      </li>
      <li class="li">
       __fadd_[rn,rz,ru,rd]() and __fmul_[rn,rz,ru,rd]() map to addition and multiplication operations that the compiler never merges into FMADs.
      </li>
      <li class="li">
       By contrast, additions and multiplications generated from the '*' and '+' operators will frequently be combined into FMADs.
      </li>
      <li class="li">
       The accuracy of floating-point division varies depending on whether the code is compiled with -prec-div=false or -prec-div=true.
      </li>
      <li class="li">
       When the code is compiled with -prec-div=false, both the regular division / operator and __fdividef(x,y) have the same accuracy, but for 2126 &lt; y &lt; 2128, __fdividef(x,y) delivers a result of zero, whereas the / operator delivers the correct result to within the accuracy stated in Table 9.
      </li>
      <li class="li">
       Also, for 2126 &lt; y &lt; 2128, if x is infinity, __fdividef(x,y) delivers a NaN (as a result of multiplying infinity by zero), while the / operator returns infinity.
      </li>
      <li class="li">
       On the other hand, the / operator is IEEE-compliant when the code is compiled with -prec-div=true or without any -prec-div option at all since its default value is true.
      </li>
      <li class="li">
       __dadd_rn() and __dmul_rn() map to addition and multiplication operations that the compiler never merges into FMADs.
      </li>
      <li class="li">
       By contrast, additions and multiplications generated from the '*' and '+' operators will frequently be combined into FMADs.
      </li>
     </ul>
    </div>
   </div>
  </div>
  <div class="topic concept nested1" id="c-cplusplus-language-support" xml:lang="en-US">
   <a name="c-cplusplus-language-support" shape="rect">
   </a>
   <h2 class="title topictitle1">
    <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#c-cplusplus-language-support" name="c-cplusplus-language-support" shape="rect">
     E. C/C++ Language Support
    </a>
   </h2>
   <div class="body conbody">
    <ul class="ul">
     <li class="li">
      As described in Compilation with NVCC, CUDA source files compiled with nvcc can include a mix of host code and device code.
     </li>
     <li class="li">
      The CUDA frontend compiler aims to emulate the host compiler behavior with respect to C++ input code.
     </li>
     <li class="li">
      The input source code is processed according to the C++ ISO/IEC 14882:2003 or C++ ISO/IEC 14882:2011 specifications, and the CUDA frontend compiler aims to emulate any host compiler divergences from the ISO specification.
     </li>
     <li class="li">
      In addition, the supported language is extended with CUDA-specific constructs described in this document 8, and is subject to the restrictions described below.
     </li>
     <li class="li">
      C++11 Language Features provides a support matrix for the C++11 features.
     </li>
     <li class="li">
      Restrictions lists the language restrictions.
     </li>
     <li class="li">
      Polymorphic Function Wrappers and topics/c-cplusplus-language-support.html#device-lambda describe additional features.
     </li>
     <li class="li">
      Code Samples gives code samples.
     </li>
    </ul>
   </div>
   <div class="topic concept nested2" id="language-features" xml:lang="en-US">
    <a name="language-features" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#language-features" name="language-features" shape="rect">
      E.1. C++11 Language Features
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       The following table lists new language features that have been accepted into the C++11 standard.
      </li>
      <li class="li">
       The "Proposal" column provides a link to the ISO C++ committee proposal that describes the feature, while the "Available in nvcc (device code)" column indicates the first version of nvcc that contains an implementation of this feature (if it has been implemented) for device code.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="restrictions" xml:lang="en-US">
    <a name="restrictions" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#restrictions" name="restrictions" shape="rect">
      E.2. Restrictions
     </a>
    </h3>
    <div class="topic concept nested3" id="host-compiler-extensions" xml:lang="en-US">
     <a name="host-compiler-extensions" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#host-compiler-extensions" name="host-compiler-extensions" shape="rect">
       E.2.1. Host Compiler Extensions
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The use of host compiler specific language extensions in device code is unsupported.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="preprocessor-symbols" xml:lang="en-US">
     <a name="preprocessor-symbols" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#preprocessor-symbols" name="preprocessor-symbols" shape="rect">
       E.2.2. Preprocessor Symbols
      </a>
     </h3>
     <div class="topic concept nested4" id="cuda-arch-macro" xml:lang="en-US">
      <a name="cuda-arch-macro" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#cuda-arch-macro" name="cuda-arch-macro" shape="rect">
        E.2.2.1. __CUDA_ARCH__
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The type signature of the following entities shall not depend on whether __CUDA_ARCH__ is defined or not, or on a particular value of __CUDA_ARCH__: __global__ functions and function templates __device__ and __constant__ variables textures and surfaces Example: If a __global__ function template is instantiated and launched from the host, then the function template must be instantiated with the same template arguments irrespective of whether __CUDA_ARCH__ is defined and regardless of the value of __CUDA_ARCH__.
        </li>
        <li class="li">
         Example: In separate compilation mode, the presence or absence of a definition of a function or variable with external linkage shall not depend on whether __CUDA_ARCH__ is defined or on a particular value of __CUDA_ARCH__9.
        </li>
        <li class="li">
         Example: In separate compilation, __CUDA_ARCH__ must not be used in headers such that different objects could contain different behavior.
        </li>
        <li class="li">
         Or, it must be guaranteed that all objects will compile for the same compute_arch.
        </li>
        <li class="li">
         If a weak function or template function is defined in a header and its behavior depends on __CUDA_ARCH__, then the instances of that function in the objects could conflict if the objects are compiled for different compute arch.
        </li>
        <li class="li">
         For example, if an a.h contains: Then if a.cu and b.cu both include a.h and instantiate getptr for the same type, and b.cu expects a non-NULL address, and compile with: At link time only one version of the getptr is used, so the behavior would depend on which version is picked.
        </li>
        <li class="li">
         To avoid this, either a.cu and b.cu must be compiled for the same compute arch, or __CUDA_ARCH__ should not be used in the shared header function.
        </li>
        <li class="li">
         The compiler does not guarantee that a diagnostic will be generated for the unsupported uses of __CUDA_ARCH__ described above.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="qualifiers" xml:lang="en-US">
     <a name="qualifiers" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#qualifiers" name="qualifiers" shape="rect">
       E.2.3. Qualifiers
      </a>
     </h3>
     <div class="topic concept nested4" id="device-memory-qualifiers" xml:lang="en-US">
      <a name="device-memory-qualifiers" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#device-memory-qualifiers" name="device-memory-qualifiers" shape="rect">
        E.2.3.1. Device Memory Qualifiers
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The __device__, __shared__ and __constant__ qualifiers are not allowed on: class, struct, and union data members, formal parameters, local variables within a function that executes on the host.
        </li>
        <li class="li">
         __shared__ and __constant__ variables have implied static storage.
        </li>
        <li class="li">
         __device__ and __constant__ variable definitions are only allowed in namespace scope (including global namespace scope).
        </li>
        <li class="li">
         __device__, __constant__ and __shared__ variables defined in namespace scope, that are of class type, cannot have a non-empty constructor or a non-empty destructor.
        </li>
        <li class="li">
         A constructor for a class type is considered empty at a point in the translation unit, if it is either a trivial constructor or it satisfies all of the following conditions: The constructor function has been defined.
        </li>
        <li class="li">
         The constructor function has no parameters, the initializer list is empty and the function body is an empty compound statement.
        </li>
        <li class="li">
         Its class has no virtual functions and no virtual base classes.
        </li>
        <li class="li">
         The default constructors of all base classes of its class can be considered empty.
        </li>
        <li class="li">
         For all the nonstatic data members of its class that are of class type (or array thereof), the default constructors can be considered empty.
        </li>
        <li class="li">
         A destructor for a class is considered empty at a point in the translation unit, if it is either a trivial destructor or it satisfies all of the following conditions: The destructor function has been defined.
        </li>
        <li class="li">
         The destructor function body is an empty compound statement.
        </li>
        <li class="li">
         Its class has no virtual functions and no virtual base classes.
        </li>
        <li class="li">
         The destructors of all base classes of its class can be considered empty.
        </li>
        <li class="li">
         For all the nonstatic data members of its class that are of class type (or array thereof), the destructor can be considered empty.
        </li>
        <li class="li">
         When compiling in the whole program compilation mode (see the nvcc user manual for a description of this mode), __device__, __shared__, and __constant__ variables cannot be defined as external using the extern keyword.
        </li>
        <li class="li">
         The only exception is for dynamically allocated __shared__ variables as described in __shared__.
        </li>
        <li class="li">
         When compiling in the separate compilation mode (see the nvcc user manual for a description of this mode), __device__, __shared__, and __constant__ variables can be defined as external using the extern keyword.
        </li>
        <li class="li">
         nvlink will generate an error when it cannot find a definition for an external variable (unless it is a dynamically allocated __shared__ variable).
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="managed-qualifier" xml:lang="en-US">
      <a name="managed-qualifier" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#managed-qualifier" name="managed-qualifier" shape="rect">
        E.2.3.2. __managed__ Qualifier
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Variables marked with the __managed__ qualifier ("managed" variables) have the following restrictions: The address of a managed variable is not a constant expression.
        </li>
        <li class="li">
         A managed variable shall not have a const qualified type.
        </li>
        <li class="li">
         A managed variable shall not have a reference type.
        </li>
        <li class="li">
         The address or value of a managed variable shall not be used when the CUDA runtime may not be in a valid state, including the following cases: In static/dynamic initialization or destruction of an object with static or thread local storage duration.
        </li>
        <li class="li">
         In code that executes after exit() has been called (e.g., a function marked with gcc's "__attribute__((destructor))").
        </li>
        <li class="li">
         In code that executes when CUDA runtime may not be initialized (e.g., a function marked with gcc's "__attribute__((constructor))").
        </li>
        <li class="li">
         A managed variable cannot be used as an unparenthesized id-expression argument to a decltype() expression.
        </li>
        <li class="li">
         Managed variables have the same coherence and consistency behavior as specified for dynamically allocated managed memory.
        </li>
        <li class="li">
         When a CUDA program containing managed variables is run on an execution platform with multiple GPUs, the variables are allocated only once, and not per GPU.
        </li>
        <li class="li">
         Here are examples of legal and illegal uses of managed variables:
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="volatile-qualifier" xml:lang="en-US">
      <a name="volatile-qualifier" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#volatile-qualifier" name="volatile-qualifier" shape="rect">
        E.2.3.3. Volatile Qualifier
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The compiler is free to optimize reads and writes to global or shared memory (for example, by caching global reads into registers or L1 cache) as long as it respects the memory ordering semantics of memory fence functions (Memory Fence Functions) and memory visibility semantics of synchronization functions (Synchronization Functions).
        </li>
        <li class="li">
         These optimizations can be disabled using the volatile keyword: If a variable located in global or shared memory is declared as volatile, the compiler assumes that its value can be changed or used at any time by another thread and therefore any reference to this variable compiles to an actual memory read or write instruction.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="pointers" xml:lang="en-US">
     <a name="pointers" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#pointers" name="pointers" shape="rect">
       E.2.4. Pointers
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Dereferencing a pointer either to global or shared memory in code that is executed on the host, or to host memory in code that is executed on the device results in an undefined behavior, most often in a segmentation fault and application termination.
       </li>
       <li class="li">
        The address obtained by taking the address of a __device__, __shared__ or __constant__ variable can only be used in device code.
       </li>
       <li class="li">
        The address of a __device__ or __constant__ variable obtained through cudaGetSymbolAddress() as described in Device Memory can only be used in host code.
       </li>
       <li class="li">
        As a consequence of the use of C++ syntax rules, void pointers (e.g., returned by malloc()) cannot be assigned to non-void pointers without a typecast.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="operators" xml:lang="en-US">
     <a name="operators" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#operators" name="operators" shape="rect">
       E.2.5. Operators
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
      </ul>
     </div>
     <div class="topic concept nested4" id="assignment-operator" xml:lang="en-US">
      <a name="assignment-operator" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#assignment-operator" name="assignment-operator" shape="rect">
        E.2.5.1. Assignment Operator
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         __constant__ variables can only be assigned from the host code through runtime functions (Device Memory); they cannot be assigned from the device code.
        </li>
        <li class="li">
         __shared__ variables cannot have an initialization as part of their declaration.
        </li>
        <li class="li">
         It is not allowed to assign values to any of the built-in variables defined in Built-in Variables.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="address-operator" xml:lang="en-US">
      <a name="address-operator" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#address-operator" name="address-operator" shape="rect">
        E.2.5.2. Address Operator
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         It is not allowed to take the address of any of the built-in variables defined in Built-in Variables.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="rtti" xml:lang="en-US">
     <a name="rtti" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#rtti" name="rtti" shape="rect">
       E.2.6. Run Time Type Information (RTTI)
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The following RTTI-related features are supported in host code, but not in device code.
       </li>
       <li class="li">
        typeid operator std::type_info dynamic_cast operator
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="exception-handling" xml:lang="en-US">
     <a name="exception-handling" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#exception-handling" name="exception-handling" shape="rect">
       E.2.7. Exception Handling
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Exception handling is only supported in host code, but not in device code.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="standard-library" xml:lang="en-US">
     <a name="standard-library" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#standard-library" name="standard-library" shape="rect">
       E.2.8. Standard Library
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Standard libraries are only supported in host code, but not in device code, unless specified otherwise.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="functions" xml:lang="en-US">
     <a name="functions" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#functions" name="functions" shape="rect">
       E.2.9. Functions
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
      </ul>
     </div>
     <div class="topic concept nested4" id="external-linkage" xml:lang="en-US">
      <a name="external-linkage" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#external-linkage" name="external-linkage" shape="rect">
        E.2.9.1. External Linkage
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         A call within some device code of a function declared with the extern qualifier is only allowed if the function is defined within the same compilation unit as the device code, i.e., a single file or several files linked together with relocatable device code and nvlink.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="compiler-generated-functions" xml:lang="en-US">
      <a name="compiler-generated-functions" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#compiler-generated-functions" name="compiler-generated-functions" shape="rect">
        E.2.9.2. Compiler generated functions
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The execution space qualifiers (__host__, __device__) for a compiler generated function are the union of the execution space qualifiers of all the functions that invoke it (note that a __global__ caller will be treated as a __device__ caller for this analysis).
        </li>
        <li class="li">
         For example: Here, the compiler generated constructor function "Derived::Derived" will be treated as a __device__ function, since it is invoked only from the __device__ function "foo".
        </li>
        <li class="li">
         The compiler generated constructor function "Other::Other" will be treated as a __host__ __device__ function, since it is invoked both from a __device__ function "foo" and a __host__ function "bar".
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="function-parameters" xml:lang="en-US">
      <a name="function-parameters" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#function-parameters" name="function-parameters" shape="rect">
        E.2.9.3. Function Parameters
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         __global__ function parameters are passed to the device via constant memory and are limited to 4 KB.
        </li>
        <li class="li">
         __device__ and __global__ functions cannot have a variable number of arguments.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="static-variables-function" xml:lang="en-US">
      <a name="static-variables-function" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#static-variables-function" name="static-variables-function" shape="rect">
        E.2.9.4. Static Variables within Function
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Within the body of a __device__ or __global__ function, only __shared__ variables or variables without any device memory qualifiers may be declared with static storage class.
        </li>
        <li class="li">
         Within the body of a __device__ __host__ function, only unannotated static variables (i.e., without device memory qualifiers) may be declared with static storage class.
        </li>
        <li class="li">
         Unannotated function-scope static variables have the same restrictions as __device__ variables defined in namespace scope.
        </li>
        <li class="li">
         They cannot have a non-empty constructor or a non-empty destructor, if they are of class type (see Device Memory Qualifiers).
        </li>
        <li class="li">
         Examples of legal and illegal uses of function-scope static variables are shown below.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="function-pointers" xml:lang="en-US">
      <a name="function-pointers" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#function-pointers" name="function-pointers" shape="rect">
        E.2.9.5. Function Pointers
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The address of a __global__ function taken in host code cannot be used in device code (e.g.
        </li>
        <li class="li">
         to launch the kernel).
        </li>
        <li class="li">
         Similarly, the address of a __global__ function taken in device code 10 cannot be used in host code.
        </li>
        <li class="li">
         It is not allowed to take the address of a __device__ function in host code.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="function-recursion" xml:lang="en-US">
      <a name="function-recursion" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#function-recursion" name="function-recursion" shape="rect">
        E.2.9.6. Function Recursion
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         __global__ functions do not support recursion.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="classes" xml:lang="en-US">
     <a name="classes" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#classes" name="classes" shape="rect">
       E.2.10. Classes
      </a>
     </h3>
     <div class="topic concept nested4" id="data-members" xml:lang="en-US">
      <a name="data-members" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#data-members" name="data-members" shape="rect">
        E.2.10.1. Data Members
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Static data members are not supported.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="function-members" xml:lang="en-US">
      <a name="function-members" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#function-members" name="function-members" shape="rect">
        E.2.10.2. Function Members
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Static member functions cannot be __global__ functions.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="virtual-functions" xml:lang="en-US">
      <a name="virtual-functions" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#virtual-functions" name="virtual-functions" shape="rect">
        E.2.10.3. Virtual Functions
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         When a function in a derived class overrides a virtual function in a base class, the execution space qualifiers (i.e., __host__, __device__) on the overridden and overriding functions must match.
        </li>
        <li class="li">
         It is not allowed to pass as an argument to a __global__ function an object of a class with virtual functions.
        </li>
        <li class="li">
         The virtual function table is placed in global or constant memory by the compiler.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="virtual-base-classes" xml:lang="en-US">
      <a name="virtual-base-classes" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#virtual-base-classes" name="virtual-base-classes" shape="rect">
        E.2.10.4. Virtual Base Classes
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         It is not allowed to pass as an argument to a __global__ function an object of a class derived from virtual base classes.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="anon-union" xml:lang="en-US">
      <a name="anon-union" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#anon-union" name="anon-union" shape="rect">
        E.2.10.5. Anonymous Unions
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Member variables of a namespace scope anonymous union cannot be referenced in a __global__ or __device__ function.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="windows-specific" xml:lang="en-US">
      <a name="windows-specific" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#windows-specific" name="windows-specific" shape="rect">
        E.2.10.6. Windows-Specific
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The CUDA compiler follows the IA64 ABI for class layout, while the Microsoft host compiler does not.
        </li>
        <li class="li">
         This may cause the CUDA compiler to compute the class layout and size differently than the Microsoft host compiler, for a class type 'T' that satisfies any of the following conditions or for any class type that has T as a field type or as a base class type (direct or indirect): T has virtual functions.
        </li>
        <li class="li">
         T has a virtual base class.
        </li>
        <li class="li">
         T has multiple inheritance with more than one direct or indirect empty base class.
        </li>
        <li class="li">
         All direct and indirect base classes ('B') of T are empty and the type of the first field of T ('F') uses B in its definition, such that B is laid out at offset 0 in the definition of F. As long as affected class types are used exclusively in host or device code, the program should work correctly; do not pass objects of such class types between between host and device code (e.g., as arguments to __global__ functions or through cudaMemcpy*() calls) 11.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="templates" xml:lang="en-US">
     <a name="templates" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#templates" name="templates" shape="rect">
       E.2.11. Templates
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        A type or template cannot be used in the type, non-type or template template argument of a __global__ function template instantiation if either: The type or template is defined within a __host__ or __host__ __device__.
       </li>
       <li class="li">
        The type or template is a class member with private or protected access and its parent class is not defined within a __device__ or __global__ function.
       </li>
       <li class="li">
        Example:
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="trigraph-digraph" xml:lang="en-US">
     <a name="trigraph-digraph" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#trigraph-digraph" name="trigraph-digraph" shape="rect">
       E.2.12. Trigraphs and Digraphs
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Trigraphs are not supported on any platform.
       </li>
       <li class="li">
        Digraphs are not supported on Windows.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="const-variables" xml:lang="en-US">
     <a name="const-variables" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#const-variables" name="const-variables" shape="rect">
       E.2.13. Const-qualified variables
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Let 'V' denote a namespace scope variable or a class static member variable that has const qualified type and does not have execution space annotations (e.g., __device__, __constant__, __shared__).
       </li>
       <li class="li">
        V is considered to be a host code variable.
       </li>
       <li class="li">
        The value of V may be directly used in device code, if V has been initialized with a constant expression before the point of use, and it has one of the following types: builtin floating point type except when the Microsoft compiler is used as the host compiler, builtin integral type.
       </li>
       <li class="li">
        Device source code cannot contain a reference to V or take the address of V. Example:
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="cpp11" xml:lang="en-US">
     <a name="cpp11" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#cpp11" name="cpp11" shape="rect">
       E.2.14. C++11 Features
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        C++11 features that are enabled by default by the host compiler are also supported by nvcc, subject to the restrictions described in this document.
       </li>
       <li class="li">
        In addition, invoking nvcc with -std=c++11 flag turns on all C++11 features and also invokes the host preprocessor, compiler and linker with the corresponding C++11 dialect option 12.
       </li>
      </ul>
     </div>
     <div class="topic concept nested4" id="lambda-expressions" xml:lang="en-US">
      <a name="lambda-expressions" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#lambda-expressions" name="lambda-expressions" shape="rect">
        E.2.14.1. Lambda Expressions
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The execution space qualifiers for all member functions13 of the closure class associated with a lambda expression are derived by the compiler as follows.
        </li>
        <li class="li">
         As described in the C++11 standard, the compiler creates a closure type in the smallest block scope, class scope or namespace scope that contains the lambda expression.
        </li>
        <li class="li">
         The innermost function scope enclosing the closure type is computed, and the corresponding function's execution space qualifiers are assigned to the closure class member functions.
        </li>
        <li class="li">
         If there is no enclosing function scope, the execution space qualifier is __host__.
        </li>
        <li class="li">
         Examples of lambda expressions and computed execution space qualifiers are shown below (in comments).
        </li>
        <li class="li">
         The closure type of a lambda expression cannot be used in the type or non-type argument of a __global__ function template instantiation, unless the lambda is defined within a __device__ or __global__ function.
        </li>
        <li class="li">
         Example:
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="initializer-list" xml:lang="en-US">
      <a name="initializer-list" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#initializer-list" name="initializer-list" shape="rect">
        E.2.14.2. std::initializer_list
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         By default, the CUDA compiler will implicitly consider the member functions of std::initializer_list to have __host__ __device__ execution space qualifiers, and therefore they can be invoked directly from device code.
        </li>
        <li class="li">
         The nvcc flag --no-host-device-initializer-list will disable this behavior; member functions of std::initializer_list will then be considered as __host__ functions and will not be directly invokable from device code.
        </li>
        <li class="li">
         Example:
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="rvalue-references" xml:lang="en-US">
      <a name="rvalue-references" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#rvalue-references" name="rvalue-references" shape="rect">
        E.2.14.3. Rvalue references
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         By default, the CUDA compiler will implicitly consider std::move and std::forward function templates to have __host__ __device__ execution space qualifiers, and therefore they can be invoked directly from device code.
        </li>
        <li class="li">
         The nvcc flag --no-host-device-move-forward will disable this behavior; std::move and std::forward will then be considered as __host__ functions and will not be directly invokable from device code.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="constexpr-functions" xml:lang="en-US">
      <a name="constexpr-functions" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#constexpr-functions" name="constexpr-functions" shape="rect">
        E.2.14.4. Constexpr functions and function templates
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         By default, a constexpr function cannot be called from a function with incompatible execution space 14.
        </li>
        <li class="li">
         The experimental nvcc flag --expt-relaxed-constexpr removes this restriction.
        </li>
        <li class="li">
         When this flag is specified, host code can invoke a __device__ constexpr function and device code can invoke a __host__ constexpr function.
        </li>
        <li class="li">
         nvcc will define the macro __CUDACC_RELAXED_CONSTEXPR__ when --expt-relaxed-constexpr has been specified.
        </li>
        <li class="li">
         Note that a function template instantiation may not be a constexpr function even if the corresponding template is marked with the keyword constexpr (C++11 Standard Section [dcl.constexpr.p6]).
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="constexpr-variables" xml:lang="en-US">
      <a name="constexpr-variables" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#constexpr-variables" name="constexpr-variables" shape="rect">
        E.2.14.5. Constexpr variables
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Let 'V' denote a namespace scope variable or a class static member variable that has been marked constexpr and that does not have execution space annotations (e.g., __device__, __constant__, __shared__).
        </li>
        <li class="li">
         V is considered to be a host code variable.
        </li>
        <li class="li">
         If V is of scalar type 15 other than long double, the value of V can be directly used in device code.
        </li>
        <li class="li">
         In addition, the value of V can be used inside a constexpr __device__ or __host__ __device__ function, if the call to the function is a constant expression 16.
        </li>
        <li class="li">
         Device source code cannot contain a reference to V or take the address of V. Example:
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="inline-namespaces" xml:lang="en-US">
      <a name="inline-namespaces" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#inline-namespaces" name="inline-namespaces" shape="rect">
        E.2.14.6. Inline namespaces
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         For an input CUDA translation unit, the CUDA compiler may invoke the host compiler for compiling the host code within the translation unit.
        </li>
        <li class="li">
         In the code passed to the host compiler, the CUDA compiler will inject additional compiler generated code, if the input CUDA translation unit contained a definition of any of the following entities: __global__ function or function template instantiation __device__, __constant__ variables with surface or texture type The compiler generated code contains a reference to the defined entity.
        </li>
        <li class="li">
         If the entity is defined within an inline namespace and another entity of the same name and type signature is defined in an enclosing namespace, this reference may be considered ambiguous by the host compiler and host compilation will fail.
        </li>
        <li class="li">
         This limitation can be avoided by using unique names for such entities defined within an inline namespace.
        </li>
        <li class="li">
         Example:Example:
        </li>
       </ul>
      </div>
      <div class="topic concept nested5" id="inline-unnamed-namespaces" xml:lang="en-US">
       <a name="inline-unnamed-namespaces" shape="rect">
       </a>
       <h3 class="title topictitle2">
        <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#inline-unnamed-namespaces" name="inline-unnamed-namespaces" shape="rect">
         E.2.14.6.1. Inline unnamed namespaces
        </a>
       </h3>
       <div class="body conbody">
        <ul class="ul">
         <li class="li">
          The following entities cannot be declared in namespace scope within an inline unnamed namespace: __device__, __shared__ and __constant__ variables __global__ function and function templates variables with surface or texture type Example:
         </li>
        </ul>
       </div>
      </div>
     </div>
     <div class="topic concept nested4" id="thread-local" xml:lang="en-US">
      <a name="thread-local" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#thread-local" name="thread-local" shape="rect">
        E.2.14.7. thread_local
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The thread_local storage specifier is not allowed in device code.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="cpp11-global" xml:lang="en-US">
      <a name="cpp11-global" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#cpp11-global" name="cpp11-global" shape="rect">
        E.2.14.8. __global__ functions and function templates
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         If the closure type associated with a lambda expression is used in a template argument of a __global__ function template instantiation, the lambda expression must either be defined in the immediate or nested block scope of a __device__ or __global__ function, or must be an extended lambda.
        </li>
        <li class="li">
         Example: A __global__ function or function template cannot be declared as constexpr and cannot have trailing return type.
        </li>
        <li class="li">
         The following types are not allowed for a parameter of a __global__ function or function template: rvalue reference type std::initializer_list restrict qualified reference type A variadic __global__ function template has the following restrictions: Only a single pack parameter is allowed.
        </li>
        <li class="li">
         The pack parameter must be listed last in the template parameter list.
        </li>
        <li class="li">
         Example:
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="cpp11-device-variable" xml:lang="en-US">
      <a name="cpp11-device-variable" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#cpp11-device-variable" name="cpp11-device-variable" shape="rect">
        E.2.14.9. __device__/__constant__/__shared__ variables
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         __device__, __constant__ and __shared__ variables cannot be marked with the keyword constexpr and cannot have rvalue reference type.
        </li>
       </ul>
      </div>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="polymorphic-function-wrappers" xml:lang="en-US">
    <a name="polymorphic-function-wrappers" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#polymorphic-function-wrappers" name="polymorphic-function-wrappers" shape="rect">
      E.3. Polymorphic Function Wrappers
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       A polymorphic function wrapper class template nvstd::function is provided in the nvfunctional header.
      </li>
      <li class="li">
       Instances of this class template can be used to store, copy and invoke any callable target, e.g., lambda expressions.
      </li>
      <li class="li">
       nvstd::function can be used in both host and device code.
      </li>
      <li class="li">
       Example: Instances of nvstd::function in host code cannot be initialized with the address of a __device__ function or with a functor whose operator() is a __device__ function.
      </li>
      <li class="li">
       Instances of nvstd::function in device code cannot be initialized with the address of a __host__ function or with a functor whose operator() is a __host__ function.
      </li>
      <li class="li">
       nvstd::function instances cannot be passed from host code to device code (and vice versa) at run time.
      </li>
      <li class="li">
       nvstd::function cannot be used in the parameter type of a __global__ function, if the __global__ function is launched from host code.
      </li>
      <li class="li">
       Example:nvstd::function is defined in the nvfunctional header as follows:
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="extended-lambda" xml:lang="en-US">
    <a name="extended-lambda" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#extended-lambda" name="extended-lambda" shape="rect">
      E.4. Experimental Feature: Extended Lambdas
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       The nvcc flag '--expt-extended-lambda' allows explicit execution space annotations in a lambda expression.
      </li>
      <li class="li">
       The execution space annotations should be present after the 'lambda-introducer' and before the optional 'lambda-declarator'.
      </li>
      <li class="li">
       nvcc will define the macro __CUDACC_EXTENDED_LAMBDA__ when the '--expt-extended-lambda' flag has been specified.
      </li>
      <li class="li">
       An 'extended __device__ lambda' is a lambda expression that is annotated explicitly with '__device__', and is defined within the immediate or nested block scope of a __host__ or __host__ __device__ function.
      </li>
      <li class="li">
       An 'extended __host__ __device__ lambda' is a lambda expression that is annotated explicitly with both '__host__' and '__device__', and is defined within the immediate or nested block scope of a __host__ or __host__ __device__ function.
      </li>
      <li class="li">
       An 'extended lambda' denotes either an extended __device__ lambda or an extended __host__ __device__ lambda.
      </li>
      <li class="li">
       Extended lambdas can be used in the type arguments of __global__ function template instantiation.
      </li>
      <li class="li">
       If the execution space annotations are not explicitly specified, they are computed based on the scopes enclosing the closure class associated with the lambda, as described in the section on C++11 support.
      </li>
      <li class="li">
       The execution space annotations are applied to all methods of the closure class associated with the lambda.
      </li>
      <li class="li">
       Example:
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="extended-lambda-traits" xml:lang="en-US">
     <a name="extended-lambda-traits" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#extended-lambda-traits" name="extended-lambda-traits" shape="rect">
       E.4.1. Extended Lambda Type Traits
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The compiler provides type traits to detect closure types for extended lambdas at compile time: __nv_is_extended_device_lambda_closure_type(type): If 'type' is the closure class created for an extended __device__ lambda, then the trait is true, otherwise it is false.
       </li>
       <li class="li">
        __nv_is_extended_host_device_lambda_closure_type(type): If 'type' is the closure class created for an extended __host__ __device__ lambda, then the trait is true, otherwise it is false.
       </li>
       <li class="li">
        These traits can be used in all compilation modes, irrespective of whether lambdas or extended lambdas are enabled17.
       </li>
       <li class="li">
        Example:
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="extended-lambda-restrictions" xml:lang="en-US">
     <a name="extended-lambda-restrictions" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#extended-lambda-restrictions" name="extended-lambda-restrictions" shape="rect">
       E.4.2. Extended Lambda Restrictions
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        The CUDA compiler will replace an extended lambda expression with an instance of a placeholder type defined in namespace scope, before invoking the host compiler.
       </li>
       <li class="li">
        The template argument of the placeholder type requires the address of the function enclosing the original extended lambda expression ('enclosing function').
       </li>
       <li class="li">
        This is required for the correct execution of any __global__ function template whose template argument involves the closure type of an extended lambda.
       </li>
       <li class="li">
        This transformation requires certain restrictions on extended lambdas, described below.
       </li>
       <li class="li">
        The enclosing function must be named and its address can be taken.
       </li>
       <li class="li">
        If the enclosing function is a class member, then the following conditions must be satisfied: All classes enclosing the member function must have a name.
       </li>
       <li class="li">
        The member function must not have private or protected access within its parent class.
       </li>
       <li class="li">
        All enclosing classes must not have private or protected access within their respective parent classes.
       </li>
       <li class="li">
        Example: An extended lambda cannot be defined in a class that is local to a function.
       </li>
       <li class="li">
        Example: If the enclosing function is an instantiation of a function template or a member function template, and/or the function is a member of a class template, the template(s) must satisfy the following constraints: The template must have at most one variadic parameter, and it must be listed last in the template parameter list.
       </li>
       <li class="li">
        The template parameters must be named.
       </li>
       <li class="li">
        The template instantiation argument types cannot involve types that are either local to a function (except for closure types for extended lambdas), or are private or protected class members.
       </li>
       <li class="li">
        Example:Example: With Visual Studio 2013 and later Visual Studio host compilers, the enclosing function must have external linkage.
       </li>
       <li class="li">
        The restriction is present because this host compiler does not support using the address of non-extern linkage functions as template arguments, which is needed by the CUDA compiler transformations to support extended lambdas.
       </li>
       <li class="li">
        An extended lambda has the following restrictions on captured variables: Variables can only be captured by value.
       </li>
       <li class="li">
        Variables of array type cannot be captured.
       </li>
       <li class="li">
        A function parameter that is an element of a variadic argument pack cannot be captured.
       </li>
       <li class="li">
        The type of the captured variable cannot involve types that are either local to a function (except for closure types of extended lambdas), or are private or protected class members.
       </li>
       <li class="li">
        For a __host__ __device__ extended lambda, the types used in the return or parameter types of the lambda expression's operator() cannot involve types that are either local to a function (except for closure types of extended lambdas), or are private or protected class members.
       </li>
       <li class="li">
        When parsing a function, the CUDA compiler assigns a counter value to each extended lambda within that function.
       </li>
       <li class="li">
        This counter value is used in the substituted named type passed to the host compiler.
       </li>
       <li class="li">
        Hence, whether or not an extended lambda is defined within a function should not depend on a particular value of __CUDA_ARCH__, or on __CUDA_ARCH__ being undefined.
       </li>
       <li class="li">
        Example As described above, the CUDA compiler replaces a __device__ extended lambda defined in a host function with a placeholder type defined in namespace scope.
       </li>
       <li class="li">
        This placeholder type does not define a operator() function equivalent to the original lambda declaration.
       </li>
       <li class="li">
        An attempt to determine the return type or parameter types of the operator() function may therefore work incorrectly in host code, as the code processed by the host compiler will be semantically different than the input code processed by the CUDA compiler.
       </li>
       <li class="li">
        However, it is ok to introspect the return type or parameter types of the operator() function within device code.
       </li>
       <li class="li">
        Note that this restriction does not apply to __host__ __device__ extended lambdas.
       </li>
       <li class="li">
        Example If the functor object represented by an extended lambda is passed from host to device code (e.g., as the argument of a __global__ function), then any expression in the body of the lambda expression that captures variables must be remain unchanged irrespective of whether the __CUDA_ARCH__ macro is defined, and whether the macro has a particular value.
       </li>
       <li class="li">
        This restriction arises because the lambda's closure class layout depends on the order in which captured variables are encountered when the compiler processes the lambda expression; the program may execute incorrectly if the closure class layout differs in device and host compilation.
       </li>
       <li class="li">
        Example As described previously, the CUDA compiler replaces an extended __host__ __device__ lambda expression with an instance of a placeholder type in the code sent to the host compiler.
       </li>
       <li class="li">
        For an extended __host__ __device__ lambda that did not specify a capture default, or which did not capture any variables, the placeholder type provides a pointer-to-function conversion operator, but only when g++ is the host compiler.
       </li>
       <li class="li">
        Thus, attempting to convert such an extended __host__ __device__ lambda into a function pointer in host code will cause host compilation failure when the host compiler is not g++.
       </li>
       <li class="li">
        Example The CUDA compiler will generate compiler diagnostics for a subset of cases described in 1-5; no diagnostic will be generated for cases 6-9, but the host compiler may fail to compile the generated code.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="host-device-lambda-notes" xml:lang="en-US">
     <a name="host-device-lambda-notes" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#host-device-lambda-notes" name="host-device-lambda-notes" shape="rect">
       E.4.3. Notes on __host__ __device__  lambdas
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Unlike __device__ lambdas, __host__ __device__ lambdas can be called from host code.
       </li>
       <li class="li">
        As described earlier, the CUDA compiler replaces an extended lambda expression defined in host code with an instance of a named placeholder type.
       </li>
       <li class="li">
        The placeholder type for an extended __host__ __device__ lambda stores the original lambda expression in an instance of std::function; the operator() of the placeholder type forwards its arguments to the the std::function instance.
       </li>
       <li class="li">
        The use of std::function may cause an extended __host__ __device__ lambda to be less optimized by the host compiler than lambdas that are implicitly or explicitly __host__ only.
       </li>
       <li class="li">
        In the latter case, the host compiler can easily inline the body of the lambda into the calling context.
       </li>
       <li class="li">
        But in case of an extended __host__ __device__ lambda, the host compiler encounters a call through std::function and may not be able to easily inline the original __host__ __device__ lambda body.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="star-this-capture" xml:lang="en-US">
     <a name="star-this-capture" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#star-this-capture" name="star-this-capture" shape="rect">
       E.4.4. *this Capture By Value
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        When a lambda is defined within a non-static class member function, and the body of the lambda refers to a class member variable, C++11/C++14 rules require that the this pointer of the class is captured by value, instead of the referenced member variable.
       </li>
       <li class="li">
        If the lambda is an extended __device__ or __host____device__ lambda defined in a host function, and the lambda is executed on the GPU, accessing the referenced member variable on the GPU will cause a run time error if the this pointer points to host memory.
       </li>
       <li class="li">
        Example: C++17 solves this problem by adding a new "*this" capture mode.
       </li>
       <li class="li">
        In this mode, the compiler makes a copy of the object denoted by "*this" instead of capturing the pointer this by value.
       </li>
       <li class="li">
        The "*this" capture mode is described in more detail here: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0018r3.html .
       </li>
       <li class="li">
        The CUDA compiler supports the "*this" capture mode for lambdas defined within __device__ and __global__ functions and for extended __device__ lambdas defined in host code, when the --expt-extended-lambda nvcc flag is used.
       </li>
       <li class="li">
        Here's the above example modified to use "*this" capture mode: "*this" capture mode is not allowed for unannotated lambdas defined in host code, or for extended __host____device__ lambdas.
       </li>
       <li class="li">
        Examples of supported and unsupported usage:
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="extended-lambda-notes" xml:lang="en-US">
     <a name="extended-lambda-notes" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#extended-lambda-notes" name="extended-lambda-notes" shape="rect">
       E.4.5. Additional Notes
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        ADL Lookup: As described earlier, the CUDA compiler will replace an extended lambda expression with an instance of a placeholder type, before invoking the host compiler.
       </li>
       <li class="li">
        One template argument of the placeholder type uses the address of the function enclosing the original lambda expression.
       </li>
       <li class="li">
        This may cause additional namespaces to participate in argument dependent lookup (ADL), for any host function call whose argument types involve the closure type of the extended lambda expression.
       </li>
       <li class="li">
        This may cause an incorrect function to be selected by the host compiler.
       </li>
       <li class="li">
        Example: In the example above, the CUDA compiler replaced the extended lambda with a placeholder type that involves the N1 namespace.
       </li>
       <li class="li">
        As a result, the namespace N1 participates in the ADL lookup for foo(in) in the body of N2::doit, and host compilation fails because multiple overload candidates N1::foo and N2::foo are found.
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="code-samples" xml:lang="en-US">
    <a name="code-samples" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#code-samples" name="code-samples" shape="rect">
      E.5. Code Samples
     </a>
    </h3>
    <div class="topic concept nested3" id="data-aggregation-class" xml:lang="en-US">
     <a name="data-aggregation-class" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#data-aggregation-class" name="data-aggregation-class" shape="rect">
       E.5.1. Data Aggregation Class
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="derived-class" xml:lang="en-US">
     <a name="derived-class" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#derived-class" name="derived-class" shape="rect">
       E.5.2. Derived Class
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="class-template" xml:lang="en-US">
     <a name="class-template" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#class-template" name="class-template" shape="rect">
       E.5.3. Class Template
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="function-template" xml:lang="en-US">
     <a name="function-template" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#function-template" name="function-template" shape="rect">
       E.5.4. Function Template
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="functor-class" xml:lang="en-US">
     <a name="functor-class" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#functor-class" name="functor-class" shape="rect">
       E.5.5. Functor Class
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
      </ul>
     </div>
    </div>
   </div>
  </div>
  <div class="topic concept nested1" id="texture-fetching" xml:lang="en-US">
   <a name="texture-fetching" shape="rect">
   </a>
   <h2 class="title topictitle1">
    <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#texture-fetching" name="texture-fetching" shape="rect">
     F. Texture Fetching
    </a>
   </h2>
   <div class="body conbody">
    <ul class="ul">
     <li class="li">
      This appendix gives the formula used to compute the value returned by the texture functions of Texture Functions depending on the various attributes of the texture reference (see Texture and Surface Memory).
     </li>
     <li class="li">
      The texture bound to the texture reference is represented as an array T of N texels for a one-dimensional texture, N x M texels for a two-dimensional texture, N x M x L texels for a three-dimensional texture.
     </li>
     <li class="li">
      It is fetched using non-normalized texture coordinates x, y, and z, or the normalized texture coordinates x/N, y/M, and z/L as described in Texture Memory.
     </li>
     <li class="li">
      In this appendix, the coordinates are assumed to be in the valid range.
     </li>
     <li class="li">
      Texture Memory explained how out-of-range coordinates are remapped to the valid range based on the addressing mode.
     </li>
    </ul>
   </div>
   <div class="topic concept nested2" id="nearest-point-sampling" xml:lang="en-US">
    <a name="nearest-point-sampling" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#nearest-point-sampling" name="nearest-point-sampling" shape="rect">
      F.1. Nearest-Point Sampling
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       In this filtering mode, the value returned by the texture fetch is tex(x)=T[i] for a one-dimensional texture, tex(x,y)=T[i,j] for a two-dimensional texture, tex(x,y,z)=T[i,j,k] for a three-dimensional texture, where i=floor(x), j=floor(y), and k=floor(z).
      </li>
      <li class="li">
       Figure 13 illustrates nearest-point sampling for a one-dimensional texture with N=4.
      </li>
      <li class="li">
       For integer textures, the value returned by the texture fetch can be optionally remapped to [0.0, 1.0] (see Texture Memory).
      </li>
      <li class="li">
       .
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="linear-filtering" xml:lang="en-US">
    <a name="linear-filtering" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#linear-filtering" name="linear-filtering" shape="rect">
      F.2. Linear Filtering
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       In this filtering mode, which is only available for floating-point textures, the value returned by the texture fetch is tex(x)=(1−α)T[i]+αT[i+1] for a one-dimensional texture, tex(x,y)=(1−α)(1−β)T[i,j]+α(1−β)T[i+1,j]+(1−α)βT[i,j+1]+αβT[i+1,j+1] for a two-dimensional texture, tex(x,y,z) = (1−α)(1−β)(1−γ)T[i,j,k]+α(1−β)(1−γ)T[i+1,j,k]+ (1−α)β(1−γ)T[i,j+1,k]+αβ(1−γ)T[i+1,j+1,k]+ (1−α)(1−β)γT[i,j,k+1]+α(1−β)γT[i+1,j,k+1]+ (1−α)βγT[i,j+1,k+1]+αβγT[i+1,j+1,k+1] for a three-dimensional texture, where: i=floor(xB), α=frac(xB), xB=x-0.5, j=floor(yB), β=frac(yB), yB=y-0.5, k=floor(zB), γ=frac(zB), zB= z-0.5, α, β, and γ are stored in 9-bit fixed point format with 8 bits of fractional value (so 1.0 is exactly represented).
      </li>
      <li class="li">
       Figure 14 illustrates linear filtering of a one-dimensional texture with N=4.
      </li>
      <li class="li">
       .
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="table-lookup" xml:lang="en-US">
    <a name="table-lookup" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#table-lookup" name="table-lookup" shape="rect">
      F.3. Table Lookup
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       A table lookup TL(x) where x spans the interval [0,R] can be implemented as TL(x)=tex((N-1)/R)x+0.5) in order to ensure that TL(0)=T[0] and TL(R)=T[N-1].
      </li>
      <li class="li">
       Figure 15 illustrates the use of texture filtering to implement a table lookup with R=4 or R=1 from a one-dimensional texture with N=4.
      </li>
     </ul>
    </div>
   </div>
  </div>
  <div class="topic concept nested1" id="compute-capabilities" xml:lang="en-US">
   <a name="compute-capabilities" shape="rect">
   </a>
   <h2 class="title topictitle1">
    <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#compute-capabilities" name="compute-capabilities" shape="rect">
     G. Compute Capabilities
    </a>
   </h2>
   <div class="body conbody">
    <ul class="ul">
     <li class="li">
      The general specifications and features of a compute device depend on its compute capability (see Compute Capability).
     </li>
     <li class="li">
      Table 12 gives the features and technical specifications associated to each compute capability.
     </li>
     <li class="li">
      Floating-Point Standard reviews the compliance with the IEEE floating-point standard.
     </li>
     <li class="li">
      Sections Compute Capability 2.x, Compute Capability 3.x, Compute Capability 5.x, and Compute Capability 6.x give more details on the architecture of devices of compute capability 2.x, 3.x, 5.x, and 6.x respectively.
     </li>
    </ul>
   </div>
   <div class="topic concept nested2" id="features-and-technical-specifications" xml:lang="en-US">
    <a name="features-and-technical-specifications" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#features-and-technical-specifications" name="features-and-technical-specifications" shape="rect">
      G.1. Features and Technical Specifications
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="floating-point-standard" xml:lang="en-US">
    <a name="floating-point-standard" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#floating-point-standard" name="floating-point-standard" shape="rect">
      G.2. Floating-Point Standard
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       All compute devices follow the IEEE 754-2008 standard for binary floating-point arithmetic with the following deviations: There is no dynamically configurable rounding mode; however, most of the operations support multiple IEEE rounding modes, exposed via device intrinsics; There is no mechanism for detecting that a floating-point exception has occurred and all operations behave as if the IEEE-754 exceptions are always masked, and deliver the masked response as defined by IEEE-754 if there is an exceptional event; for the same reason, while SNaN encodings are supported, they are not signaling and are handled as quiet; The result of a single-precision floating-point operation involving one or more input NaNs is the quiet NaN of bit pattern 0x7fffffff; Double-precision floating-point absolute value and negation are not compliant with IEEE-754 with respect to NaNs; these are passed through unchanged; Code must be compiled with -ftz=false, -prec-div=true, and -prec-sqrt=true to ensure IEEE compliance (this is the default setting; see the nvcc user manual for description of these compilation flags).
      </li>
      <li class="li">
       Regardless of the setting of the compiler flag -ftz, Atomic single-precision floating-point adds on global memory always operate in flush-to-zero mode, i.e., behave equivalent to FADD.F32.FTZ.RN, Atomic single-precision floating-point adds on shared memory always operate with denormal support, i.e., behave equivalent to FADD.F32.RN.
      </li>
      <li class="li">
       In accordance to the IEEE-754R standard, if one of the input parameters to fminf(), fmin(), fmaxf(), or fmax() is NaN, but not the other, the result is the non-NaN parameter.
      </li>
      <li class="li">
       The conversion of a floating-point value to an integer value in the case where the floating-point value falls outside the range of the integer format is left undefined by IEEE-754.
      </li>
      <li class="li">
       For compute devices, the behavior is to clamp to the end of the supported range.
      </li>
      <li class="li">
       This is unlike the x86 architecture behavior.
      </li>
      <li class="li">
       The behavior of integer division by zero and integer overflow is left undefined by IEEE-754.
      </li>
      <li class="li">
       For compute devices, there is no mechanism for detecting that such integer operation exceptions have occurred.
      </li>
      <li class="li">
       Integer division by zero yields an unspecified, machine-specific value.
      </li>
      <li class="li">
       http://developer.nvidia.com/content/precision-performance-floating-point-and-ieee-754-compliance-nvidia-gpus includes more information on the floating point accuracy and compliance of NVIDIA GPUs.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="compute-capability-2-x" xml:lang="en-US">
    <a name="compute-capability-2-x" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#compute-capability-2-x" name="compute-capability-2-x" shape="rect">
      G.3. Compute Capability 2.x
     </a>
    </h3>
    <div class="topic concept nested3" id="architecture-2-x" xml:lang="en-US">
     <a name="architecture-2-x" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#architecture-2-x" name="architecture-2-x" shape="rect">
       G.3.1. Architecture
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        For devices of compute capability 2.x, a multiprocessor consists of: For devices of compute capability 2.0: 32 CUDA cores for arithmetic operations (see Arithmetic Instructions for throughputs of arithmetic operations), 4 special function units for single-precision floating-point transcendental functions, For devices of compute capability 2.1: 48 CUDA cores for arithmetic operations (see Arithmetic Instructions for throughputs of arithmetic operations), 8 special function units for single-precision floating-point transcendental functions, 2 warp schedulers.
       </li>
       <li class="li">
        At every instruction issue time, each scheduler issues: One instruction for devices of compute capability 2.0, Two independent instructions for devices of compute capability 2.1, for some warp that is ready to execute, if any.
       </li>
       <li class="li">
        The first scheduler is in charge of the warps with an odd ID and the second scheduler is in charge of the warps with an even ID.
       </li>
       <li class="li">
        Note that when a scheduler issues a double-precision floating-point instruction, the other scheduler cannot issue any instruction.
       </li>
       <li class="li">
        A warp scheduler can issue an instruction to only half of the CUDA cores.
       </li>
       <li class="li">
        To execute an instruction for all threads of a warp, a warp scheduler must therefore issue the instruction over two clock cycles for an integer or floating-point arithmetic instruction.
       </li>
       <li class="li">
        A multiprocessor also has a read-only constant cache that is shared by all functional units and speeds up reads from the constant memory space, which resides in device memory.
       </li>
       <li class="li">
        There is an L1 cache for each multiprocessor and an L2 cache shared by all multiprocessors, both of which are used to cache accesses to local or global memory, including temporary register spills.
       </li>
       <li class="li">
        The cache behavior (e.g., whether reads are cached in both L1 and L2 or in L2 only) can be partially configured on a per-access basis using modifiers to the load or store instruction.
       </li>
       <li class="li">
        The same on-chip memory is used for both L1 and shared memory: It can be configured as 48 KB of shared memory and 16 KB of L1 cache or as 16 KB of shared memory and 48 KB of L1 cache, using cudaFuncSetCacheConfig()/cuFuncSetCacheConfig(): The default cache configuration is "prefer none," meaning "no preference."
       </li>
       <li class="li">
        If a kernel is configured to have no preference, then it will default to the preference of the current thread/context, which is set using cudaDeviceSetCacheConfig()/cuCtxSetCacheConfig() (see the reference manual for details).
       </li>
       <li class="li">
        If the current thread/context also has no preference (which is again the default setting), then whichever cache configuration was most recently used for any kernel will be the one that is used, unless a different cache configuration is required to launch the kernel (e.g., due to shared memory requirements).
       </li>
       <li class="li">
        The initial configuration is 48 KB of shared memory and 16 KB of L1 cache.
       </li>
       <li class="li">
        Applications may query the L2 cache size by checking the l2CacheSize device property (see Device Enumeration).
       </li>
       <li class="li">
        The maximum L2 cache size is 768 KB.
       </li>
       <li class="li">
        Each multiprocessor has a read-only texture cache to speed up reads from the texture memory space, which resides in device memory.
       </li>
       <li class="li">
        It accesses the texture cache via a texture unit that implements the various addressing modes and data filtering mentioned in Texture and Surface Memory.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="global-memory-2-x" xml:lang="en-US">
     <a name="global-memory-2-x" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#global-memory-2-x" name="global-memory-2-x" shape="rect">
       G.3.2. Global Memory
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Global memory accesses are cached.
       </li>
       <li class="li">
        Using the -dlcm compilation flag, they can be configured at compile time to be cached in both L1 and L2 (-Xptxas -dlcm=ca) (this is the default setting) or in L2 only (-Xptxas -dlcm=cg).
       </li>
       <li class="li">
        A cache line is 128 bytes and maps to a 128 byte aligned segment in device memory.
       </li>
       <li class="li">
        Memory accesses that are cached in both L1 and L2 are serviced with 128-byte memory transactions whereas memory accesses that are cached in L2 only are serviced with 32-byte memory transactions.
       </li>
       <li class="li">
        Caching in L2 only can therefore reduce over-fetch, for example, in the case of scattered memory accesses.
       </li>
       <li class="li">
        If the size of the words accessed by each thread is more than 4 bytes, a memory request by a warp is first split into separate 128-byte memory requests that are issued independently: Two memory requests, one for each half-warp, if the size is 8 bytes, Four memory requests, one for each quarter-warp, if the size is 16 bytes.
       </li>
       <li class="li">
        Each memory request is then broken down into cache line requests that are issued independently.
       </li>
       <li class="li">
        A cache line request is serviced at the throughput of L1 or L2 cache in case of a cache hit, or at the throughput of device memory, otherwise.
       </li>
       <li class="li">
        Note that threads can access any words in any order, including the same words.
       </li>
       <li class="li">
        If a non-atomic instruction executed by a warp writes to the same location in global memory for more than one of the threads of the warp, only one thread performs a write and which thread does it is undefined.
       </li>
       <li class="li">
        Figure 16 shows some examples of global memory accesses and corresponding memory transactions.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="shared-memory-2-x" xml:lang="en-US">
     <a name="shared-memory-2-x" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#shared-memory-2-x" name="shared-memory-2-x" shape="rect">
       G.3.3. Shared Memory
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Shared memory has 32 banks that are organized such that successive 32-bit words map to successive banks.
       </li>
       <li class="li">
        Each bank has a bandwidth of 32 bits per two clock cycles.
       </li>
       <li class="li">
        A shared memory request for a warp does not generate a bank conflict between two threads that access any address within the same 32-bit word (even though the two addresses fall in the same bank): In that case, for read accesses, the word is broadcast to the requesting threads (multiple words can be broadcast in a single transaction) and for write accesses, each address is written by only one of the threads (which thread performs the write is undefined).
       </li>
       <li class="li">
        This means, in particular, that there are no bank conflicts if an array of char is accessed as follows, for example: Figure 18 shows some examples of memory read accesses that involve the broadcast mechanism for devices of compute capability 3.x.
       </li>
       <li class="li">
        The same examples apply for devices of compute capability 2.x.
       </li>
       <li class="li">
        A common access pattern is for each thread to access a 32-bit word from an array indexed by the thread ID tid and with some stride s: In this case, threads tid and tid+n access the same bank whenever s*n is a multiple of the number of banks (i.e., 32) or, equivalently, whenever n is a multiple of 32/d where d is the greatest common divisor of 32 and s. As a consequence, there will be no bank conflict only if the warp size (i.e., 32) is less than or equal to 32/d, i.e., only if d is equal to 1, i.e., s is odd.
       </li>
       <li class="li">
        Figure 17 shows some examples of strided access for devices of compute capability 3.x.
       </li>
       <li class="li">
        The same examples apply for devices of compute capability 2.x.
       </li>
       <li class="li">
        However, the access pattern for the example in the middle generates 2-way bank conflicts for devices of compute capability 2.x.
       </li>
       <li class="li">
        64-bit and 128-bit accesses are specifically handled to minimize bank conflicts as described below.
       </li>
       <li class="li">
        Other accesses larger than 32-bit are split into 32-bit, 64-bit, or 128-bit accesses.
       </li>
       <li class="li">
        The following code, for example: results in three separate 32-bit reads without bank conflicts since each member is accessed with a stride of three 32-bit words.
       </li>
       <li class="li">
        64-Bit Accesses: For 64-bit accesses, a bank conflict only occurs if two threads in either of the half-warps access different addresses belonging to the same bank.
       </li>
       <li class="li">
        128-Bit Accesses: The majority of 128-bit accesses will cause 2-way bank conflicts, even if no two threads in a quarter-warp access different addresses belonging to the same bank.
       </li>
       <li class="li">
        Therefore, to determine the ways of bank conflicts, one must add 1 to the maximum number of threads in a quarter-warp that access different addresses belonging to the same bank.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="constant-memory-2-x" xml:lang="en-US">
     <a name="constant-memory-2-x" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#constant-memory-2-x" name="constant-memory-2-x" shape="rect">
       G.3.4. Constant Memory
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        In addition to the constant memory space supported by devices of all compute capabilities (where __constant__ variables reside), devices of compute capability 2.x support the LDU (LoaD Uniform) instruction that the compiler uses to load any variable that is: pointing to global memory, read-only in the kernel (programmer can enforce this using the const keyword), not dependent on thread ID.
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="compute-capability-3-0" xml:lang="en-US">
    <a name="compute-capability-3-0" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#compute-capability-3-0" name="compute-capability-3-0" shape="rect">
      G.4. Compute Capability 3.x
     </a>
    </h3>
    <div class="topic concept nested3" id="architecture-3-0" xml:lang="en-US">
     <a name="architecture-3-0" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#architecture-3-0" name="architecture-3-0" shape="rect">
       G.4.1. Architecture
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        A multiprocessor consists of: 192 CUDA cores for arithmetic operations (see Arithmetic Instructions for throughputs of arithmetic operations), 32 special function units for single-precision floating-point transcendental functions, 4 warp schedulers.
       </li>
       <li class="li">
        When a multiprocessor is given warps to execute, it first distributes them among the four schedulers.
       </li>
       <li class="li">
        Then, at every instruction issue time, each scheduler issues two independent instructions for one of its assigned warps that is ready to execute, if any.
       </li>
       <li class="li">
        A multiprocessor has a read-only constant cache that is shared by all functional units and speeds up reads from the constant memory space, which resides in device memory.
       </li>
       <li class="li">
        There is an L1 cache for each multiprocessor and an L2 cache shared by all multiprocessors.
       </li>
       <li class="li">
        The L1 cache is used to cache accesses to local memory, including temporary register spills.
       </li>
       <li class="li">
        The L2 cache is used to cache accesses to local and global memory.
       </li>
       <li class="li">
        The cache behavior (e.g., whether reads are cached in both L1 and L2 or in L2 only) can be partially configured on a per-access basis using modifiers to the load or store instruction.
       </li>
       <li class="li">
        Some devices of compute capability 3.5 and devices of compute capability 3.7 allow opt-in to caching of global memory in both L1 and L2 via compiler options.
       </li>
       <li class="li">
        The same on-chip memory is used for both L1 and shared memory: It can be configured as 48 KB of shared memory and 16 KB of L1 cache or as 16 KB of shared memory and 48 KB of L1 cache or as 32 KB of shared memory and 32 KB of L1 cache, using cudaFuncSetCacheConfig()/cuFuncSetCacheConfig(): The default cache configuration is "prefer none," meaning "no preference."
       </li>
       <li class="li">
        If a kernel is configured to have no preference, then it will default to the preference of the current thread/context, which is set using cudaDeviceSetCacheConfig()/cuCtxSetCacheConfig() (see the reference manual for details).
       </li>
       <li class="li">
        If the current thread/context also has no preference (which is again the default setting), then whichever cache configuration was most recently used for any kernel will be the one that is used, unless a different cache configuration is required to launch the kernel (e.g., due to shared memory requirements).
       </li>
       <li class="li">
        The initial configuration is 48 KB of shared memory and 16 KB of L1 cache.
       </li>
       <li class="li">
        Devices of compute capability 3.7 add an additional 64 KB of shared memory to each of the above configurations, yielding 112 KB, 96 KB, and 80 KB shared memory per multiprocessor, respectively.
       </li>
       <li class="li">
        However, the maximum shared memory per thread block remains 48 KB.
       </li>
       <li class="li">
        Applications may query the L2 cache size by checking the l2CacheSize device property (see Device Enumeration).
       </li>
       <li class="li">
        The maximum L2 cache size is 1.5 MB.
       </li>
       <li class="li">
        Each multiprocessor has a read-only data cache of 48 KB to speed up reads from device memory.
       </li>
       <li class="li">
        It accesses this cache either directly (for devices of compute capability 3.5 or 3.7), or via a texture unit that implements the various addressing modes and data filtering mentioned in Texture and Surface Memory.
       </li>
       <li class="li">
        When accessed via the texture unit, the read-only data cache is also referred to as texture cache.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="global-memory-3-0" xml:lang="en-US">
     <a name="global-memory-3-0" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#global-memory-3-0" name="global-memory-3-0" shape="rect">
       G.4.2. Global Memory
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Global memory accesses for devices of compute capability 3.x are cached in L2 and for devices of compute capability 3.5 or 3.7, may also be cached in the read-only data cache described in the previous section; they are normally not cached in L1.
       </li>
       <li class="li">
        Some devices of compute capability 3.5 and devices of compute capability 3.7 allow opt-in to caching of global memory accesses in L1 via the -Xptxas -dlcm=ca option to nvcc.
       </li>
       <li class="li">
        Caching in L2 behaves in the same way as for devices of compute capability 2.x (see Global Memory).
       </li>
       <li class="li">
        Data that is read-only for the entire lifetime of the kernel can also be cached in the read-only data cache described in the previous section by reading it using the __ldg() function (see Read-Only Data Cache Load Function).
       </li>
       <li class="li">
        When the compiler detects that the read-only condition is satisfied for some data, it will use __ldg() to read it.
       </li>
       <li class="li">
        The compiler might not always be able to detect that the read-only condition is satisfied for some data.
       </li>
       <li class="li">
        Marking pointers used for loading such data with both the const and __restrict__ qualifiers increases the likelihood that the compiler will detect the read-only condition.
       </li>
       <li class="li">
        Figure 16 shows some examples of global memory accesses and corresponding memory transactions.
       </li>
       <li class="li">
        .
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="shared-memory-3-0" xml:lang="en-US">
     <a name="shared-memory-3-0" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#shared-memory-3-0" name="shared-memory-3-0" shape="rect">
       G.4.3. Shared Memory
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Shared memory has 32 banks with two addressing modes that are described below.
       </li>
       <li class="li">
        The addressing mode can be queried using cudaDeviceGetSharedMemConfig() and set using cudaDeviceSetSharedMemConfig() (see reference manual for more details).
       </li>
       <li class="li">
        Each bank has a bandwidth of 64 bits per clock cycle.
       </li>
       <li class="li">
        Figure 17 shows some examples of strided access.
       </li>
       <li class="li">
        Figure 18 shows some examples of memory read accesses that involve the broadcast mechanism.
       </li>
       <li class="li">
        Successive 64-bit words map to successive banks.
       </li>
       <li class="li">
        A shared memory request for a warp does not generate a bank conflict between two threads that access any sub-word within the same 64-bit word (even though the addresses of the two sub-words fall in the same bank): In that case, for read accesses, the 64-bit word is broadcast to the requesting threads and for write accesses, each sub-word is written by only one of the threads (which thread performs the write is undefined).
       </li>
       <li class="li">
        In this mode, the same access pattern generates fewer bank conflicts than on devices of compute capability 2.x for 64-bit accesses and as many or fewer for 32-bit accesses.
       </li>
       <li class="li">
        Successive 32-bit words map to successive banks.
       </li>
       <li class="li">
        A shared memory request for a warp does not generate a bank conflict between two threads that access any sub-word within the same 32-bit word or within two 32-bit words whose indices i and j are in the same 64-word aligned segment (i.e., a segment whose first index is a multiple of 64) and such that j=i+32 (even though the addresses of the two sub-words fall in the same bank): In that case, for read accesses, the 32-bit words are broadcast to the requesting threads and for write accesses, each sub-word is written by only one of the threads (which thread performs the write is undefined).
       </li>
       <li class="li">
        In this mode, the same access pattern generates as many or fewer bank conflicts than on devices of compute capability 2.x.
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="compute-capability-5-x" xml:lang="en-US">
    <a name="compute-capability-5-x" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#compute-capability-5-x" name="compute-capability-5-x" shape="rect">
      G.5. Compute Capability 5.x
     </a>
    </h3>
    <div class="topic concept nested3" id="architecture-5-x" xml:lang="en-US">
     <a name="architecture-5-x" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#architecture-5-x" name="architecture-5-x" shape="rect">
       G.5.1. Architecture
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        A multiprocessor consists of: 128 CUDA cores for arithmetic operations (see Arithmetic Instructions for throughputs of arithmetic operations), 32 special function units for single-precision floating-point transcendental functions, 4 warp schedulers.
       </li>
       <li class="li">
        When a multiprocessor is given warps to execute, it first distributes them among the four schedulers.
       </li>
       <li class="li">
        Then, at every instruction issue time, each scheduler issues one instruction for one of its assigned warps that is ready to execute, if any.
       </li>
       <li class="li">
        A multiprocessor has: a read-only constant cache that is shared by all functional units and speeds up reads from the constant memory space, which resides in device memory, a unified L1/texture cache of 24 KB used to cache reads from global memory, 64 KB of shared memory for devices of compute capability 5.0 or 96 KB of shared memory for devices of compute capability 5.2.
       </li>
       <li class="li">
        The unified L1/texture cache is also used by the texture unit that implements the various addressing modes and data filtering mentioned in Texture and Surface Memory.
       </li>
       <li class="li">
        There is also an L2 cache shared by all multiprocessors that is used to cache accesses to local or global memory, including temporary register spills.
       </li>
       <li class="li">
        Applications may query the L2 cache size by checking the l2CacheSize device property (see Device Enumeration).
       </li>
       <li class="li">
        The cache behavior (e.g., whether reads are cached in both the unified L1/texture cache and L2 or in L2 only) can be partially configured on a per-access basis using modifiers to the load instruction.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="global-memory-5-x" xml:lang="en-US">
     <a name="global-memory-5-x" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#global-memory-5-x" name="global-memory-5-x" shape="rect">
       G.5.2. Global Memory
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Global memory accesses are always cached in L2 and caching in L2 behaves in the same way as for devices of compute capability 2.x (see Global Memory).
       </li>
       <li class="li">
        Data that is read-only for the entire lifetime of the kernel can also be cached in the unified L1/texture cache described in the previous section by reading it using the __ldg() function (see Read-Only Data Cache Load Function).
       </li>
       <li class="li">
        When the compiler detects that the read-only condition is satisfied for some data, it will use __ldg() to read it.
       </li>
       <li class="li">
        The compiler might not always be able to detect that the read-only condition is satisfied for some data.
       </li>
       <li class="li">
        Marking pointers used for loading such data with both the const and __restrict__ qualifiers increases the likelihood that the compiler will detect the read-only condition.
       </li>
       <li class="li">
        Data that is not read-only for the entire lifetime of the kernel cannot be cached in the unified L1/texture cache for devices of compute capability 5.0.
       </li>
       <li class="li">
        For devices of compute capability 5.2, it is, by default, not cached in the unified L1/texture cache, but caching may be enabled using the following mechanisms: Perform the read using inline assembly with the appropriate modifier as described in the PTX reference manual; Compile with the -Xptxas -dlcm=ca compilation flag, in which case all reads are cached, except reads that are performed using inline assembly with a modifier that disables caching; Compile with the -Xptxas -fscm=ca compilation flag, in which case all reads are cached, including reads that are performed using inline assembly regardless of the modifier used.
       </li>
       <li class="li">
        When caching is enabled using some the three mechanisms listed above, devices of compute capability 5.2 will cache global memory reads in the unified L1/texture cache for all kernel launches except for the kernel launches for which thread blocks consume too much of the multiprocessor's resources.
       </li>
       <li class="li">
        These exceptions are reported by the profiler.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="shared-memory-5-x" xml:lang="en-US">
     <a name="shared-memory-5-x" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#shared-memory-5-x" name="shared-memory-5-x" shape="rect">
       G.5.3. Shared Memory
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Shared memory has 32 banks that are organized such that successive 32-bit words map to successive banks.
       </li>
       <li class="li">
        Each bank has a bandwidth of 32 bits per clock cycle.
       </li>
       <li class="li">
        A shared memory request for a warp does not generate a bank conflict between two threads that access any address within the same 32-bit word (even though the two addresses fall in the same bank): In that case, for read accesses, the word is broadcast to the requesting threads and for write accesses, each address is written by only one of the threads (which thread performs the write is undefined).
       </li>
       <li class="li">
        Figure 17 shows some examples of strided access.
       </li>
       <li class="li">
        Figure 18 shows some examples of memory read accesses that involve the broadcast mechanism.
       </li>
       <li class="li">
        .
       </li>
       <li class="li">
        Left Linear addressing with a stride of one 32-bit word (no bank conflict).
       </li>
       <li class="li">
        Middle Linear addressing with a stride of two 32-bit words (two-way bank conflict).
       </li>
       <li class="li">
        Right Linear addressing with a stride of three 32-bit words (no bank conflict).
       </li>
       <li class="li">
        .
       </li>
       <li class="li">
        Left Conflict-free access via random permutation.
       </li>
       <li class="li">
        Middle Conflict-free access since threads 3, 4, 6, 7, and 9 access the same word within bank 5.
       </li>
       <li class="li">
        Right Conflict-free broadcast access (threads access the same word within a bank).
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="compute-capability-6-x" xml:lang="en-US">
    <a name="compute-capability-6-x" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#compute-capability-6-x" name="compute-capability-6-x" shape="rect">
      G.6. Compute Capability 6.x
     </a>
    </h3>
    <div class="topic concept nested3" id="architecture-6-x" xml:lang="en-US">
     <a name="architecture-6-x" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#architecture-6-x" name="architecture-6-x" shape="rect">
       G.6.1. Architecture
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        A multiprocessor consists of: 64 (compute capablity 6.0) or 128 (6.1 and 6.2) CUDA cores for arithmetic operations, 16 (6.0) or 32 (6.1 and 6.2) special function units for single-precision floating-point transcendental functions, 2 (6.0) or 4 (6.1 and 6.2) warp schedulers.
       </li>
       <li class="li">
        When a multiprocessor is given warps to execute, it first distributes them among its schedulers.
       </li>
       <li class="li">
        Then, at every instruction issue time, each scheduler issues one instruction for one of its assigned warps that is ready to execute, if any.
       </li>
       <li class="li">
        A multiprocessor has: a read-only constant cache that is shared by all functional units and speeds up reads from the constant memory space, which resides in device memory, a unified L1/texture cache for reads from global memory of size 24 KB (6.0 and 6.2) or 48 KB (6.1), a shared memory of size 64 KB (6.0 and 6.2) or 96 KB (6.1).
       </li>
       <li class="li">
        The unified L1/texture cache is also used by the texture unit that implements the various addressing modes and data filtering mentioned in Texture and Surface Memory.
       </li>
       <li class="li">
        There is also an L2 cache shared by all multiprocessors that is used to cache accesses to local or global memory, including temporary register spills.
       </li>
       <li class="li">
        Applications may query the L2 cache size by checking the l2CacheSize device property (see Device Enumeration).
       </li>
       <li class="li">
        The cache behavior (e.g., whether reads are cached in both the unified L1/texture cache and L2 or in L2 only) can be partially configured on a per-access basis using modifiers to the load instruction.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="global-memory-6-x" xml:lang="en-US">
     <a name="global-memory-6-x" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#global-memory-6-x" name="global-memory-6-x" shape="rect">
       G.6.2. Global Memory
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Global memory behaves the same way as devices of compute capability 5.x (See Global Memory).
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="shared-memory-6-x" xml:lang="en-US">
     <a name="shared-memory-6-x" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#shared-memory-6-x" name="shared-memory-6-x" shape="rect">
       G.6.3. Shared Memory
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Shared memory behaves the same way as devices of compute capability 5.x (See Shared Memory).
       </li>
      </ul>
     </div>
    </div>
   </div>
  </div>
  <div class="topic concept nested1" id="driver-api" xml:lang="en-US">
   <a name="driver-api" shape="rect">
   </a>
   <h2 class="title topictitle1">
    <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#driver-api" name="driver-api" shape="rect">
     H. Driver API
    </a>
   </h2>
   <div class="body conbody">
    <ul class="ul">
     <li class="li">
      This appendix assumes knowledge of the concepts described in CUDA C Runtime.
     </li>
     <li class="li">
      The driver API is implemented in the cuda dynamic library (cuda.dll or cuda.so) which is copied on the system during the installation of the device driver.
     </li>
     <li class="li">
      All its entry points are prefixed with cu.
     </li>
     <li class="li">
      It is a handle-based, imperative API: Most objects are referenced by opaque handles that may be specified to functions to manipulate the objects.
     </li>
     <li class="li">
      The objects available in the driver API are summarized in Table 14.
     </li>
     <li class="li">
      The driver API must be initialized with cuInit() before any function from the driver API is called.
     </li>
     <li class="li">
      A CUDA context must then be created that is attached to a specific device and made current to the calling host thread as detailed in Context.
     </li>
     <li class="li">
      Within a CUDA context, kernels are explicitly loaded as PTX or binary objects by the host code as described in Module.
     </li>
     <li class="li">
      Kernels written in C must therefore be compiled separately into PTX or binary objects.
     </li>
     <li class="li">
      Kernels are launched using API entry points as described in Kernel Execution.
     </li>
     <li class="li">
      Any application that wants to run on future device architectures must load PTX, not binary code.
     </li>
     <li class="li">
      This is because binary code is architecture-specific and therefore incompatible with future architectures, whereas PTX code is compiled to binary code at load time by the device driver.
     </li>
     <li class="li">
      Here is the host code of the sample from Kernels written using the driver API: Full code can be found in the vectorAddDrv CUDA sample.
     </li>
    </ul>
   </div>
   <div class="topic concept nested2" id="context" xml:lang="en-US">
    <a name="context" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#context" name="context" shape="rect">
      H.1. Context
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       A CUDA context is analogous to a CPU process.
      </li>
      <li class="li">
       All resources and actions performed within the driver API are encapsulated inside a CUDA context, and the system automatically cleans up these resources when the context is destroyed.
      </li>
      <li class="li">
       Besides objects such as modules and texture or surface references, each context has its own distinct address space.
      </li>
      <li class="li">
       As a result, CUdeviceptr values from different contexts reference different memory locations.
      </li>
      <li class="li">
       A host thread may have only one device context current at a time.
      </li>
      <li class="li">
       When a context is created with cuCtxCreate(), it is made current to the calling host thread.
      </li>
      <li class="li">
       CUDA functions that operate in a context (most functions that do not involve device enumeration or context management) will return CUDA_ERROR_INVALID_CONTEXT if a valid context is not current to the thread.
      </li>
      <li class="li">
       Each host thread has a stack of current contexts.
      </li>
      <li class="li">
       cuCtxCreate() pushes the new context onto the top of the stack.
      </li>
      <li class="li">
       cuCtxPopCurrent() may be called to detach the context from the host thread.
      </li>
      <li class="li">
       The context is then "floating" and may be pushed as the current context for any host thread.
      </li>
      <li class="li">
       cuCtxPopCurrent() also restores the previous current context, if any.
      </li>
      <li class="li">
       A usage count is also maintained for each context.
      </li>
      <li class="li">
       cuCtxCreate() creates a context with a usage count of 1. cuCtxAttach() increments the usage count and cuCtxDetach() decrements it.
      </li>
      <li class="li">
       A context is destroyed when the usage count goes to 0 when calling cuCtxDetach() or cuCtxDestroy().
      </li>
      <li class="li">
       Usage count facilitates interoperability between third party authored code operating in the same context.
      </li>
      <li class="li">
       For example, if three libraries are loaded to use the same context, each library would call cuCtxAttach() to increment the usage count and cuCtxDetach() to decrement the usage count when the library is done using the context.
      </li>
      <li class="li">
       For most libraries, it is expected that the application will have created a context before loading or initializing the library; that way, the application can create the context using its own heuristics, and the library simply operates on the context handed to it.
      </li>
      <li class="li">
       Libraries that wish to create their own contexts - unbeknownst to their API clients who may or may not have created contexts of their own - would use cuCtxPushCurrent() and cuCtxPopCurrent() as illustrated in Figure 19.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="module" xml:lang="en-US">
    <a name="module" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#module" name="module" shape="rect">
      H.2. Module
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       Modules are dynamically loadable packages of device code and data, akin to DLLs in Windows, that are output by nvcc (see Compilation with NVCC).
      </li>
      <li class="li">
       The names for all symbols, including functions, global variables, and texture or surface references, are maintained at module scope so that modules written by independent third parties may interoperate in the same CUDA context.
      </li>
      <li class="li">
       This code sample loads a module and retrieves a handle to some kernel:This code sample compiles and loads a new module from PTX code and parses compilation errors:This code sample compiles, links, and loads a new module from multiple PTX codes and parses link and compilation errors: Full code can be found in the ptxjit CUDA sample.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="kernel-execution" xml:lang="en-US">
    <a name="kernel-execution" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#kernel-execution" name="kernel-execution" shape="rect">
      H.3. Kernel Execution
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       cuLaunchKernel() launches a kernel with a given execution configuration.
      </li>
      <li class="li">
       Parameters are passed either as an array of pointers (next to last parameter of cuLaunchKernel()) where the nth pointer corresponds to the nth parameter and points to a region of memory from which the parameter is copied, or as one of the extra options (last parameter of cuLaunchKernel()).
      </li>
      <li class="li">
       When parameters are passed as an extra option (the CU_LAUNCH_PARAM_BUFFER_POINTER option), they are passed as a pointer to a single buffer where parameters are assumed to be properly offset with respect to each other by matching the alignment requirement for each parameter type in device code.
      </li>
      <li class="li">
       Alignment requirements in device code for the built-in vector types are listed in Table 3.
      </li>
      <li class="li">
       For all other basic types, the alignment requirement in device code matches the alignment requirement in host code and can therefore be obtained using __alignof().
      </li>
      <li class="li">
       The only exception is when the host compiler aligns double and long long (and long on a 64-bit system) on a one-word boundary instead of a two-word boundary (for example, using gcc's compilation flag -mno-align-double) since in device code these types are always aligned on a two-word boundary.
      </li>
      <li class="li">
       CUdeviceptr is an integer, but represents a pointer, so its alignment requirement is __alignof(void*).
      </li>
      <li class="li">
       The following code sample uses a macro (ALIGN_UP()) to adjust the offset of each parameter to meet its alignment requirement and another macro (ADD_TO_PARAM_BUFFER()) to add each parameter to the parameter buffer passed to the CU_LAUNCH_PARAM_BUFFER_POINTER option.
      </li>
      <li class="li">
       The alignment requirement of a structure is equal to the maximum of the alignment requirements of its fields.
      </li>
      <li class="li">
       The alignment requirement of a structure that contains built-in vector types, CUdeviceptr, or non-aligned double and long long, might therefore differ between device code and host code.
      </li>
      <li class="li">
       Such a structure might also be padded differently.
      </li>
      <li class="li">
       The following structure, for example, is not padded at all in host code, but it is padded in device code with 12 bytes after field f since the alignment requirement for field f4 is 16.
      </li>
     </ul>
    </div>
   </div>
   <div class="topic concept nested2" id="interoperability-between-runtime-and-driver-apis" xml:lang="en-US">
    <a name="interoperability-between-runtime-and-driver-apis" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#interoperability-between-runtime-and-driver-apis" name="interoperability-between-runtime-and-driver-apis" shape="rect">
      H.4. Interoperability between Runtime and Driver APIs
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       An application can mix runtime API code with driver API code.
      </li>
      <li class="li">
       If a context is created and made current via the driver API, subsequent runtime calls will pick up this context instead of creating a new one.
      </li>
      <li class="li">
       If the runtime is initialized (implicitly as mentioned in CUDA C Runtime), cuCtxGetCurrent() can be used to retrieve the context created during initialization.
      </li>
      <li class="li">
       This context can be used by subsequent driver API calls.
      </li>
      <li class="li">
       Device memory can be allocated and freed using either API.
      </li>
      <li class="li">
       CUdeviceptr can be cast to regular pointers and vice-versa: In particular, this means that applications written using the driver API can invoke libraries written using the runtime API (such as cuFFT, cuBLAS, ...).
      </li>
      <li class="li">
       All functions from the device and version management sections of the reference manual can be used interchangeably.
      </li>
     </ul>
    </div>
   </div>
  </div>
  <div class="topic concept nested1" id="env-vars" xml:lang="en-US">
   <a name="env-vars" shape="rect">
   </a>
   <h2 class="title topictitle1">
    <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#env-vars" name="env-vars" shape="rect">
     I. CUDA Environment Variables
    </a>
   </h2>
   <div class="body conbody">
    <ul class="ul">
     <li class="li">
      Environment variables related to the Multi-Process Service are documented in the Multi-Process Service section of the GPU Deployment and Management guide.
     </li>
    </ul>
   </div>
  </div>
  <div class="topic concept nested1" id="um-unified-memory-programming-hd" xml:lang="en-US">
   <a name="um-unified-memory-programming-hd" shape="rect">
   </a>
   <h2 class="title topictitle1">
    <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-unified-memory-programming-hd" name="um-unified-memory-programming-hd" shape="rect">
     J. Unified Memory Programming
    </a>
   </h2>
   <div class="topic concept nested2" id="um-introduction" xml:lang="en-US">
    <a name="um-introduction" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-introduction" name="um-introduction" shape="rect">
      J.1. Unified Memory Introduction
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       Unified Memory is a component of the CUDA programming model, first introduced in CUDA 6.0, that defines a managed memory space in which all processors see a single coherent memory image with a common address space.
      </li>
      <li class="li">
       A processor refers to any independent execution unit with a dedicated MMU.
      </li>
      <li class="li">
       This includes both CPUs and GPUs of any type and architecture.
      </li>
      <li class="li">
       The underlying system manages data access and locality within a CUDA program without need for explicit memory copy calls.
      </li>
      <li class="li">
       This benefits GPU programming in two primary ways: GPU programming is simplified by unifying memory spaces coherently across all GPUs and CPUs in the system and by providing tighter and more straightforward language integration for CUDA programmers.
      </li>
      <li class="li">
       Data access speed is maximized by transparently migrating data towards the processor using it.
      </li>
      <li class="li">
       In simple terms, Unified Memory eliminates the need for explicit data movement via the cudaMemcpy*() routines without the performance penalty incurred by placing all data into zero-copy memory.
      </li>
      <li class="li">
       Data movement, of course, still takes place, so a program’s run time typically does not decrease; Unified Memory instead enables the writing of simpler and more maintainable code.
      </li>
      <li class="li">
       Unified Memory offers a “single-pointer-to-data” model that is conceptually similar to CUDA’s zero-copy memory.
      </li>
      <li class="li">
       One key difference between the two is that with zero-copy allocations the physical location of memory is pinned in CPU system memory such that a program may have fast or slow access to it depending on where it is being accessed from.
      </li>
      <li class="li">
       Unified Memory, on the other hand, decouples memory and execution spaces so that all data accesses are fast.
      </li>
      <li class="li">
       The term Unified Memory describes a system that provides memory management services to a wide range of programs, from those targeting the Runtime API down to those using the Virtual ISA (PTX).
      </li>
      <li class="li">
       Part of this system defines the managed memory space that opts in to Unified Memory services.
      </li>
      <li class="li">
       Managed memory is interoperable and interchangeable with device-specific allocations, such as those created using the cudaMalloc() routine.
      </li>
      <li class="li">
       All CUDA operations that are valid on device memory are also valid on managed memory; the primary difference is that the host portion of a program is able to reference and access the memory as well.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="um-simplifying" xml:lang="en-US">
     <a name="um-simplifying" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-simplifying" name="um-simplifying" shape="rect">
       J.1.1. Simplifying GPU Programming
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Unification of memory spaces means that there is no longer any need for explicit memory transfers between host and device.
       </li>
       <li class="li">
        Any allocation created in the managed memory space is automatically migrated to where it is needed.
       </li>
       <li class="li">
        A program allocates managed memory in one of two ways: via the cudaMallocManaged() routine, which is semantically similar to cudaMalloc(); or by defining a global __managed__ variable, which is semantically similar to a __device__ variable.
       </li>
       <li class="li">
        Precise definitions of these are found later in this document.
       </li>
       <li class="li">
        On supporting platforms with devices of compute capability 6.x, Unified Memory will enable applications to allocate and share data using the default system allocator.
       </li>
       <li class="li">
        This allows the GPU to access the entire system virtual memory without using a special allocator.
       </li>
       <li class="li">
        The following code examples illustrate how the use of managed memory can change the way in which host code is written.
       </li>
       <li class="li">
        First, a simple program written without the benefit of unified memory: This first example combines two numbers together on the GPU with a per-thread ID and returns the values in an array.
       </li>
       <li class="li">
        Without managed memory, both host- and device-side storage for the return values is required (host_ret and ret in the example), as is an explicit copy between the two using cudaMemcpy().
       </li>
       <li class="li">
        Compare this with the Unified Memory version of the program, which allows direct access of GPU data from the host.
       </li>
       <li class="li">
        Notice the cudaMallocManaged() routine, which returns a pointer valid from both host and device code.
       </li>
       <li class="li">
        This allows ret to be used without a separate host_ret copy, greatly simplifying and reducing the size of the program.
       </li>
       <li class="li">
        Finally, language integration allows direct reference of a GPU-declared __managed__ variable and simplifies a program further when global variables are used.
       </li>
       <li class="li">
        Note the absence of explicit cudaMemcpy() commands and the fact that the return array ret is visible on both CPU and GPU.
       </li>
       <li class="li">
        It is worth a comment on the synchronization between host and device.
       </li>
       <li class="li">
        Notice how in the non-managed example, the synchronous cudaMemcpy() routine is used both to synchronize the kernel (that is, to wait for it to finish running), and to transfer the data to the host.
       </li>
       <li class="li">
        The Unified Memory examples do not call cudaMemcpy() and so require an explicit cudaDeviceSynchronize() before the host program can safely use the output from the GPU.
       </li>
       <li class="li">
        An alternative here would be to set the environment variable CUDA_LAUNCH_BLOCKING=1, ensuring that all kernel launches complete synchronously.
       </li>
       <li class="li">
        This simplifies the code by eliminating all explicit synchronization, but obviously has broader impact on execution behavior as a whole.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="um-data-migration" xml:lang="en-US">
     <a name="um-data-migration" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-data-migration" name="um-data-migration" shape="rect">
       J.1.2. Data Migration and Coherency
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Unified Memory attempts to optimize memory performance by migrating data towards the device where it is being accessed (that is, moving data to host memory if the CPU is accessing it and to device memory if the GPU will access it).
       </li>
       <li class="li">
        Data migration is fundamental to Unified Memory, but is transparent to a program.
       </li>
       <li class="li">
        The system will try to place data in the location where it can most efficiently be accessed without violating coherency.
       </li>
       <li class="li">
        The physical location of data is invisible to a program and may be changed at any time, but accesses to the data’s virtual address will remain valid and coherent from any processor regardless of locality.
       </li>
       <li class="li">
        Note that maintaining coherence is the primary requirement, ahead of performance; within the constraints of the host operating system, the system is permitted to either fail accesses or move data in order to maintain global coherence between processors.
       </li>
       <li class="li">
        GPU architectures of compute capability lower than 6.x do not support fine-grained movement of the managed data to GPU on-demand.
       </li>
       <li class="li">
        Whenever a GPU kernel is launched all managed memory generally has to be transfered to GPU memory to avoid faulting on memory access.
       </li>
       <li class="li">
        With compute capability 6.x a new GPU page faulting mechanism is introduced that provides more seamless Unified Memory functionality.
       </li>
       <li class="li">
        Combined with the system-wide virtual address space, page faulting provides several benefits.
       </li>
       <li class="li">
        First, page faulting means that the CUDA system software doesn’t need to synchronize all managed memory allocations to the GPU before each kernel launch.
       </li>
       <li class="li">
        If a kernel running on the GPU accesses a page that is not resident in its memory, it faults, allowing the page to be automatically migrated to the GPU memory on-demand.
       </li>
       <li class="li">
        Alternatively, the page may be mapped into the GPU address space for access over the PCIe or NVLink interconnects (mapping on access can sometimes be faster than migration).
       </li>
       <li class="li">
        Note that Unified Memory is system-wide: GPUs (and CPUs) can fault on and migrate memory pages either from CPU memory or from the memory of other GPUs in the system.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="um-oversubscription" xml:lang="en-US">
     <a name="um-oversubscription" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-oversubscription" name="um-oversubscription" shape="rect">
       J.1.3. GPU Memory Oversubscription
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Devices of compute capability lower than 6.x cannot allocate more managed memory than the physical size of GPU memory.
       </li>
       <li class="li">
        Devices of compute capability 6.x extend addressing mode to support 49-bit virtual addressing.
       </li>
       <li class="li">
        This is large enough to cover the 48-bit virtual address spaces of modern CPUs, as well as the GPU’s own memory.
       </li>
       <li class="li">
        The large virtual address space and page faulting capability enable applications to access the entire system virtual memory, not limited by the physical memory size of any one processor.
       </li>
       <li class="li">
        This means that applications can oversubscribe the memory system: in other words they can allocate, access, and share arrays larger than the total physical capacity of the system, enabling out-of-core processing of very large datasets.
       </li>
       <li class="li">
        cudaMallocManaged will not run out of memory as long as there is enough system memory available for the allocation.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="um-multi-gpu" xml:lang="en-US">
     <a name="um-multi-gpu" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-multi-gpu" name="um-multi-gpu" shape="rect">
       J.1.4. Multi-GPU Support
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        For devices of compute capability lower than 6.x managed memory allocation behaves identically to unmanaged memory allocated using cudaMalloc(): the current active device is the home for the physical allocation, and all other GPUs receive peer mappings to the memory.
       </li>
       <li class="li">
        This means that other GPUs in the system will access the memory at reduced bandwidth over the PCIe bus.
       </li>
       <li class="li">
        Note that if peer mappings are not supported between the GPUs in the system, then the managed memory pages are placed in CPU system memory (“zero-copy” memory), and all GPUs will experience PCIe bandwidth restrictions.
       </li>
       <li class="li">
        See Managed Memory with Multi-GPU Programs on pre-6.x Architectures for details.
       </li>
       <li class="li">
        Managed allocations on systems with devices of compute capability 6.x are visible to all GPUs and can migrate to any processor on-demand.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="um-requirements" xml:lang="en-US">
     <a name="um-requirements" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-requirements" name="um-requirements" shape="rect">
       J.1.5. System Requirements
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Unified Memory has three basic requirements: a GPU with SM architecture 3.0 or higher (Kepler class or newer) a 64-bit host application and operating system, except Android Linux or Windows Devices with SM architecture 6.x provide additional Unified Memory features outlined throughout this document.
       </li>
       <li class="li">
        Note that some of these features also require operating system support.
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="um-programming-model-hd" xml:lang="en-US">
    <a name="um-programming-model-hd" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-programming-model-hd" name="um-programming-model-hd" shape="rect">
      J.2. Programming Model
     </a>
    </h3>
    <div class="topic concept nested3" id="um-opt-in" xml:lang="en-US">
     <a name="um-opt-in" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-opt-in" name="um-opt-in" shape="rect">
       J.2.1. Managed Memory Opt In
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Most platforms require a program to opt in to automatic data management by either annotating a __device__ variable with the __managed__ keyword (see the Language Integration section) or by using a new cudaMallocManaged() call to allocate data.
       </li>
       <li class="li">
        Devices of compute capability lower than 6.x must always allocate managed memory on the heap, either with an allocator or by declaring global storage.
       </li>
       <li class="li">
        It is not possible either to associate previously allocated memory with Unified Memory, or to have the Unified Memory system manage a CPU or a GPU stack pointer.
       </li>
       <li class="li">
        Starting with CUDA 8.0 and on supporting systems with devices of compute capability 6.x, memory allocated with the default OS allocator (e.g.
       </li>
       <li class="li">
        malloc or new) can be accessed from both GPU code and CPU code using the same pointer.
       </li>
       <li class="li">
        On these systems, Unified Memory is the default: there is no need to use a special allocator or the creation of a specially managed memory pool.
       </li>
      </ul>
     </div>
     <div class="topic concept nested4" id="um-explicit-allocation" xml:lang="en-US">
      <a name="um-explicit-allocation" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-explicit-allocation" name="um-explicit-allocation" shape="rect">
        J.2.1.1. Explicit Allocation Using cudaMallocManaged()
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Unified memory is most commonly created using an allocation function that is semantically and syntactically similar to the standard CUDA allocator, cudaMalloc().
        </li>
        <li class="li">
         The function description is as follows: The cudaMallocManaged() function allocates size bytes of managed memory on the GPU and returns a pointer in devPtr.
        </li>
        <li class="li">
         The pointer is valid on all GPUs and the CPU in the system, although program accesses to this pointer must obey the concurrency rules of the Unified Memory programming model (see Coherency and Concurrency).
        </li>
        <li class="li">
         Below is a simple example, showing the use of cudaMallocManaged(): A program’s behavior is functionally unchanged when cudaMalloc() is replaced with cudaMallocManaged(); however, the program should go on to eliminate explicit memory copies and take advantage of automatic migration.
        </li>
        <li class="li">
         Additionally, dual pointers (one to host and one to device memory) can be eliminated.
        </li>
        <li class="li">
         Device code is not able to call cudaMallocManaged().
        </li>
        <li class="li">
         All managed memory must be allocated from the host or at global scope (see the next section).
        </li>
        <li class="li">
         Allocations on the device heap using malloc() in a kernel will not be created in the managed memory space, and so will not be accessible to CPU code.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="um-global-scope" xml:lang="en-US">
      <a name="um-global-scope" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-global-scope" name="um-global-scope" shape="rect">
        J.2.1.2. Global-Scope Managed Variables Using __managed__
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         File-scope and global-scope CUDA __device__ variables may also opt-in to Unified Memory management by adding a new __managed__ annotation to the declaration.
        </li>
        <li class="li">
         These may then be referenced directly from either host or device code, as follows: All semantics of the original __device__ memory space, along with some additional unified-memory-specific constraints, are inherited by the managed variable.
        </li>
        <li class="li">
         See Compilation with NVCC) in the CUDA C Programming Guide for details.
        </li>
        <li class="li">
         Note that variables marked __constant__ may not also be marked as __managed__; this annotation is reserved for __device__ variables only.
        </li>
        <li class="li">
         Constant memory must be set either statically at compile time or by using cudaMemcpyToSymbol() as usual in CUDA.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="um-coherency-hd" xml:lang="en-US">
     <a name="um-coherency-hd" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-coherency-hd" name="um-coherency-hd" shape="rect">
       J.2.2. Coherency and Concurrency
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Simultaneous access to managed memory on devices of compute capability lower than 6.x is not possible, because coherence could not be guaranteed if the CPU accessed a Unified Memory allocation while a GPU kernel was active.
       </li>
       <li class="li">
        However, devices of compute capability 6.x on supporting operating systems allow the CPUs and GPUs to access Unified Memory allocations simultaneously via the new page faulting mechanism.
       </li>
       <li class="li">
        A program can query whether a device supports concurrent access to managed memory by checking a new concurrentManagedAccess property.
       </li>
       <li class="li">
        Note, as with any parallel application, developers need to ensure correct synchronization to avoid data hazards between processors.
       </li>
      </ul>
     </div>
     <div class="topic concept nested4" id="um-gpu-exclusive" xml:lang="en-US">
      <a name="um-gpu-exclusive" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-gpu-exclusive" name="um-gpu-exclusive" shape="rect">
        J.2.2.1. GPU Exclusive Access To Managed Memory
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         To ensure coherency on pre-6.x GPU architectures, the Unified Memory programming model puts constraints on data accesses while both the CPU and GPU are executing concurrently.
        </li>
        <li class="li">
         In effect, the GPU has exclusive access to all managed data while any kernel operation is executing, regardless of whether the specific kernel is actively using the data.
        </li>
        <li class="li">
         When managed data is used with cudaMemcpy*() or cudaMemset*(), the system may choose to access the source or destination from the host or the device, which will put constraints on concurrent CPU access to that data while the cudaMemcpy*() or cudaMemset*() is executing.
        </li>
        <li class="li">
         See Memcpy()/Memset() Behavior With Managed Memory for further details.
        </li>
        <li class="li">
         It is not permitted for the CPU to access any managed allocations or variables while the GPU is active for devices with concurrentManagedAccess property set to 0.
        </li>
        <li class="li">
         On these systems concurrent CPU/GPU accesses, even to different managed memory allocations, will cause a segmentation fault because the page is considered inaccessible to the CPU.
        </li>
        <li class="li">
         In example above, the GPU program kernel is still active when the CPU touches y.
        </li>
        <li class="li">
         (Note how it occurs before cudaDeviceSynchronize().)
        </li>
        <li class="li">
         The code runs successfully on devices of compute capability 6.x due to the GPU page faulting capability which lifts all restrictions on simultaneous access.
        </li>
        <li class="li">
         However, such memory access is invalid on pre-6.x architectures even though the CPU is accessing different data than the GPU.
        </li>
        <li class="li">
         The program must explicitly synchronize with the GPU before accessing y: As this example shows, on systems with pre-6.x GPU architectures, a CPU thread may not access any managed data in between performing a kernel launch and a subsequent synchronization call, regardless of whether the GPU kernel actually touches that same data (or any managed data at all).
        </li>
        <li class="li">
         The mere potential for concurrent CPU and GPU access is sufficient for a process-level exception to be raised.
        </li>
        <li class="li">
         Note that if memory is dynamically allocated with cudaMallocManaged() or cuMemAllocManaged() while the GPU is active, the behavior of the memory is unspecified until additional work is launched or the GPU is synchronized.
        </li>
        <li class="li">
         Attempting to access the memory on the CPU during this time may or may not cause a segmentation fault.
        </li>
        <li class="li">
         This does not apply to memory allocated using the flag cudaMemAttachHost or CU_MEM_ATTACH_HOST.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="um-explicit-synchronization" xml:lang="en-US">
      <a name="um-explicit-synchronization" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-explicit-synchronization" name="um-explicit-synchronization" shape="rect">
        J.2.2.2. Explicit Synchronization and Logical GPU Activity
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Note that explicit synchronization is required even if kernel runs quickly and finishes before the CPU touches y in the above example.
        </li>
        <li class="li">
         Unified Memory uses logical activity to determine whether the GPU is idle.
        </li>
        <li class="li">
         This aligns with the CUDA programming model, which specifies that a kernel can run at any time following a launch and is not guaranteed to have finished until the host issues a synchronization call.
        </li>
        <li class="li">
         Any function call that logically guarantees the GPU completes its work is valid.
        </li>
        <li class="li">
         This includes cudaDeviceSynchronize(); cudaStreamSynchronize() and cudaStreamQuery() (provided it returns cudaSuccess and not cudaErrorNotReady) where the specified stream is the only stream still executing on the GPU; cudaEventSynchronize() and cudaEventQuery() in cases where the specified event is not followed by any device work; as well as uses of cudaMemcpy() and cudaMemset() that are documented as being fully synchronous with respect to the host.
        </li>
        <li class="li">
         Dependencies created between streams will be followed to infer completion of other streams by synchronizing on a stream or event.
        </li>
        <li class="li">
         Dependencies can be created via cudaStreamWaitEvent() or implicitly when using the default (NULL) stream.
        </li>
        <li class="li">
         It is legal for the CPU to access managed data from within a stream callback, provided no other stream that could potentially be accessing managed data is active on the GPU.
        </li>
        <li class="li">
         In addition, a callback that is not followed by any device work can be used for synchronization: for example, by signaling a condition variable from inside the callback; otherwise, CPU access is valid only for the duration of the callback(s).
        </li>
        <li class="li">
         There are several important points of note: It is always permitted for the CPU to access non-managed zero-copy data while the GPU is active.
        </li>
        <li class="li">
         The GPU is considered active when it is running any kernel, even if that kernel does not make use of managed data.
        </li>
        <li class="li">
         If a kernel might use data, then access is forbidden, unless device property concurrentManagedAccess is 1.
        </li>
        <li class="li">
         There are no constraints on concurrent inter-GPU access of managed memory, other than those that apply to multi-GPU access of non-managed memory.
        </li>
        <li class="li">
         There are no constraints on concurrent GPU kernels accessing managed data.
        </li>
        <li class="li">
         Note how the last point allows for races between GPU kernels, as is currently the case for non-managed GPU memory.
        </li>
        <li class="li">
         As mentioned previously, managed memory functions identically to non-managed memory from the perspective of the GPU.
        </li>
        <li class="li">
         The following code example illustrates these points:
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="um-managing-data" xml:lang="en-US">
      <a name="um-managing-data" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-managing-data" name="um-managing-data" shape="rect">
        J.2.2.3. Managing Data Visibility and Concurrent CPU + GPU Access with Streams
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Until now it was assumed that for SM architectures before 6.x: 1) any active kernel may use any managed memory, and 2) it was invalid to use managed memory from the CPU while a kernel is active.
        </li>
        <li class="li">
         Here we present a system for finer-grained control of managed memory designed to work on all devices supporting managed memory, including older architectures with concurrentManagedAccess equal to 0.
        </li>
        <li class="li">
         The CUDA programming model provides streams as a mechanism for programs to indicate dependence and independence among kernel launches.
        </li>
        <li class="li">
         Kernels launched into the same stream are guaranteed to execute consecutively, while kernels launched into different streams are permitted to execute concurrently.
        </li>
        <li class="li">
         Streams describe independence between work items and hence allow potentially greater efficiency through concurrency.
        </li>
        <li class="li">
         Unified Memory builds upon the stream-independence model by allowing a CUDA program to explicitly associate managed allocations with a CUDA stream.
        </li>
        <li class="li">
         In this way, the programmer indicates the use of data by kernels based on whether they are launched into a specified stream or not.
        </li>
        <li class="li">
         This enables opportunities for concurrency based on program-specific data access patterns.
        </li>
        <li class="li">
         The function to control this behaviour is: The cudaStreamAttachMemAsync() function associates length bytes of memory starting from ptr with the specified stream.
        </li>
        <li class="li">
         (Currently, length must always be 0 to indicate that the entire region should be attached.)
        </li>
        <li class="li">
         Because of this association, the Unified Memory system allows CPU access to this memory region so long as all operations in stream have completed, regardless of whether other streams are active.
        </li>
        <li class="li">
         In effect, this constrains exclusive ownership of the managed memory region by an active GPU to per-stream activity instead of whole-GPU activity.
        </li>
        <li class="li">
         Most importantly, if an allocation is not associated with a specific stream, it is visible to all running kernels regardless of their stream.
        </li>
        <li class="li">
         This is the default visibility for a cudaMallocManaged() allocation or a __managed__ variable; hence, the simple-case rule that the CPU may not touch the data while any kernel is running.
        </li>
        <li class="li">
         By associating an allocation with a specific stream, the program makes a guarantee that only kernels launched into that stream will touch that data.
        </li>
        <li class="li">
         No error checking is performed by the Unified Memory system: it is the programmer’s responsibility to ensure that guarantee is honored.
        </li>
        <li class="li">
         In addition to allowing greater concurrency, the use of cudaStreamAttachMemAsync() can (and typically does) enable data transfer optimizations within the Unified Memory system that may affect latencies and other overhead.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="um-stream-association" xml:lang="en-US">
      <a name="um-stream-association" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-stream-association" name="um-stream-association" shape="rect">
        J.2.2.4. Stream Association Examples
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Associating data with a stream allows fine-grained control over CPU + GPU concurrency, but what data is visible to which streams must be kept in mind when using devices of compute capability lower than 6.x.
        </li>
        <li class="li">
         Looking at the earlier synchronization example: Here we explicitly associate y with host accessibility, thus enabling access at all times from the CPU.
        </li>
        <li class="li">
         (As before, note the absence of cudaDeviceSynchronize() before the access.)
        </li>
        <li class="li">
         Accesses to y by the GPU running kernel will now produce undefined results.
        </li>
        <li class="li">
         Note that associating a variable with a stream does not change the associating of any other variable.
        </li>
        <li class="li">
         E.g.
        </li>
        <li class="li">
         associating x with stream1 does not ensure that only x is accessed by kernels launched in stream1, thus an error is caused by this code: Note how the access to y will cause an error because, even though x has been associated with a stream, we have told the system nothing about who can see y.
        </li>
        <li class="li">
         The system therefore conservatively assumes that kernel might access it and prevents the CPU from doing so.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="um-stream-attach" xml:lang="en-US">
      <a name="um-stream-attach" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-stream-attach" name="um-stream-attach" shape="rect">
        J.2.2.5. Stream Attach With Multithreaded Host Programs
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The primary use for cudaStreamAttachMemAsync() is to enable independent task parallelism using CPU threads.
        </li>
        <li class="li">
         Typically in such a program, a CPU thread creates its own stream for all work that it generates because using CUDA’s NULL stream would cause dependencies between threads.
        </li>
        <li class="li">
         The default global visibility of managed data to any GPU stream can make it difficult to avoid interactions between CPU threads in a multi-threaded program.
        </li>
        <li class="li">
         Function cudaStreamAttachMemAsync() is therefore used to associate a thread’s managed allocations with that thread’s own stream, and the association is typically not changed for the life of the thread.
        </li>
        <li class="li">
         Such a program would simply add a single call to cudaStreamAttachMemAsync() to use unified memory for its data accesses: In this example, the allocation-stream association is established just once, and then data is used repeatedly by both the host and device.
        </li>
        <li class="li">
         The result is much simpler code than occurs with explicitly copying data between host and device, although the result is the same.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="um-advanced-modular" xml:lang="en-US">
      <a name="um-advanced-modular" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-advanced-modular" name="um-advanced-modular" shape="rect">
        J.2.2.6. Advanced Topic: Modular Programs and Data Access Constraints
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         In the previous example cudaMallocManaged() specifies the cudaMemAttachHost flag, which creates an allocation that is initially invisible to device-side execution.
        </li>
        <li class="li">
         (The default allocation would be visible to all GPU kernels on all streams.)
        </li>
        <li class="li">
         This ensures that there is no accidental interaction with another thread’s execution in the interval between the data allocation and when the data is acquired for a specific stream.
        </li>
        <li class="li">
         Without this flag, a new allocation would be considered in-use on the GPU if a kernel launched by another thread happens to be running.
        </li>
        <li class="li">
         This might impact the thread’s ability to access the newly allocated data from the CPU (for example, within a base-class constructor) before it is able to explicitly attach it to a private stream.
        </li>
        <li class="li">
         To enable safe independence between threads, therefore, allocations should be made specifying this flag.
        </li>
        <li class="li">
         An alternative would be to place a process-wide barrier across all threads after the allocation has been attached to the stream.
        </li>
        <li class="li">
         This would ensure that all threads complete their data/stream associations before any kernels are launched, avoiding the hazard.
        </li>
        <li class="li">
         A second barrier would be needed before the stream is destroyed because stream destruction causes allocations to revert to their default visibility.
        </li>
        <li class="li">
         The cudaMemAttachHost flag exists both to simplify this process, and because it is not always possible to insert global barriers where required.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="um-memcpy-memset" xml:lang="en-US">
      <a name="um-memcpy-memset" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-memcpy-memset" name="um-memcpy-memset" shape="rect">
        J.2.2.7. Memcpy()/Memset() Behavior With Managed Memory
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Since managed memory can be accessed from either the host or the device, cudaMemcpy*() relies on the type of transfer, specified using cudaMemcpyKind, to determine whether the data should be accessed as a host pointer or a device pointer.
        </li>
        <li class="li">
         If cudaMemcpyHostTo* is specified and the source data is managed, then it will be accessed from the device if it has global visibility or if it’s associated with the stream being used for the copy operation; otherwise, it will be accessed from the host.
        </li>
        <li class="li">
         Similar rules apply to the destination when cudaMemcpy*ToHost is specified and the destination is managed memory.
        </li>
        <li class="li">
         Note that a segmentation fault can occur during the copy operation if data is being accessed from the host and its associated stream is active on the GPU.
        </li>
        <li class="li">
         If cudaMemcpyDeviceTo* is specified and the source data is managed, then it will be accessed from the device.
        </li>
        <li class="li">
         The source must either have global visibility or it must be associated with the copy stream; otherwise, an error is returned.
        </li>
        <li class="li">
         Similar rules apply to the destination when cudaMemcpy*ToDevice is specified and the destination is managed memory.
        </li>
        <li class="li">
         If cudaMemcpyDefault is specified, then managed data will be accessed from the device if it has global visibility or if it’s associated with the copy stream; otherwise, it will be accessed from the host.
        </li>
        <li class="li">
         When using cudaMemset*() with managed memory, the data is always accessed from the device.
        </li>
        <li class="li">
         The data must either have global visibility, or it must be associated with the stream being used for the cudaMemset() operation; otherwise, an error is returned.
        </li>
        <li class="li">
         When data is accessed from the device either by cudaMemcpy*() or cudaMemset*(), the stream of operation is considered to be active on the GPU.
        </li>
        <li class="li">
         During this time, any CPU access of data that is associated with that stream or data that has global visibility, will result in a segmentation fault.
        </li>
        <li class="li">
         The program must synchronize appropriately to ensure the operation has completed before accessing any associated data from the CPU.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="um-language-integration" xml:lang="en-US">
     <a name="um-language-integration" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-language-integration" name="um-language-integration" shape="rect">
       J.2.3. Language Integration
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Users of the CUDA Runtime API who compile their host code using nvcc have access to additional language integration features, such as shared symbol names and inline kernel launch via the &lt;&lt;&lt;...&gt;&gt;&gt; operator.
       </li>
       <li class="li">
        Unified Memory adds one additional element to CUDA’s language integration: variables annotated with the __managed__ keyword can be referenced directly from both host and device code.
       </li>
       <li class="li">
        The following example, seen earlier in Simplifying GPU Programming, illustrates a simple use of __managed__ global declarations: The capability available with __managed__ variables is that the symbol is available in both device code and in host code without the need to dereference a pointer, and the data is shared by all.
       </li>
       <li class="li">
        This makes it particularly easy to exchange data between host and device programs without the need for explicit allocations or copying.
       </li>
       <li class="li">
        Semantically, the behavior of __managed__ variables is identical to that of storage allocated via cudaMallocManaged().
       </li>
       <li class="li">
        Data is hosted in physical GPU storage and is visible to all GPUs in the system as well as the CPU.
       </li>
       <li class="li">
        Stream visibility defaults to cudaMemAttachGlobal, but may be constrained using cudaStreamAttachMemAsync().
       </li>
       <li class="li">
        A valid CUDA context is necessary for the correct operation of __managed__ variables.
       </li>
       <li class="li">
        Accessing __managed__ variables can trigger CUDA context creation if a context for the current device hasn’t already been created.
       </li>
       <li class="li">
        In the example above, accessing x before the kernel launch triggers context creation on device 0.
       </li>
       <li class="li">
        In the absence of that access, the kernel launch would have triggered context creation.
       </li>
       <li class="li">
        C++ objects declared as __managed__ are subject to certain specific constraints, particularly where static initializers are concerned.
       </li>
       <li class="li">
        Please refer to C/C++ Language Support in the CUDA C Programming Guide for a list of these constraints.
       </li>
      </ul>
     </div>
     <div class="topic concept nested4" id="um-host-program-errors" xml:lang="en-US">
      <a name="um-host-program-errors" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-host-program-errors" name="um-host-program-errors" shape="rect">
        J.2.3.1. Host Program Errors with __managed__ Variables
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The use of __managed__ variables depends upon the underlying Unified Memory system functioning correctly.
        </li>
        <li class="li">
         Incorrect functioning can occur if, for example, the CUDA installation failed or if the CUDA context creation was unsuccessful.
        </li>
        <li class="li">
         When CUDA-specific operations fail, typically an error is returned that indicates the source of the failure.
        </li>
        <li class="li">
         Using __managed__ variables introduces a new failure mode whereby a non-CUDA operation (for example, CPU access to what should be a valid host memory address) can fail if the Unified Memory system is not operating correctly.
        </li>
        <li class="li">
         Such invalid memory accesses cannot easily be attributed to the underlying CUDA subsystem, although a debugger such as cuda-gdb will indicate that a managed memory address is the source of the failure.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="um-querying-um-hd" xml:lang="en-US">
     <a name="um-querying-um-hd" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-querying-um-hd" name="um-querying-um-hd" shape="rect">
       J.2.4. Querying Unified Memory Support
      </a>
     </h3>
     <div class="topic concept nested4" id="um-device-properties" xml:lang="en-US">
      <a name="um-device-properties" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-device-properties" name="um-device-properties" shape="rect">
        J.2.4.1. Device Properties
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         Unified Memory is supported only on devices with compute capability 3.0 or higher.
        </li>
        <li class="li">
         A program may query whether a GPU device supports managed memory by using cudaGetDeviceProperties() and checking the new managedMemory property.
        </li>
        <li class="li">
         The capability can also be determined using the individual attribute query function cudaDeviceGetAttribute() with the attribute cudaDevAttrManagedMemory.
        </li>
        <li class="li">
         Either property will be set to 1 if managed memory allocations are permitted on the GPU and under the current operating system.
        </li>
        <li class="li">
         Note that Unified Memory is not supported for 32-bit applications (unless on Android), even if a GPU is of sufficient capability.
        </li>
        <li class="li">
         Devices of compute capability 6.x on supporting platforms can access pageable memory without calling cudaHostRegister on it.
        </li>
        <li class="li">
         An application can query whether the device supports coherently accessing pageable memory by checking the new pageableMemoryAccess property.
        </li>
        <li class="li">
         With the new page fault mechanism, global data coherency is guaranteed with Unified Memory.
        </li>
        <li class="li">
         This means that the CPUs and GPUs can access Unified Memory allocations simultaneously.
        </li>
        <li class="li">
         This was illegal on devices of compute capability lower than 6.x, because coherence could not be guaranteed if the CPU accessed a Unified Memory allocation while a GPU kernel was active.
        </li>
        <li class="li">
         A program can query concurrent access support by checking concurrentManagedAccess property.
        </li>
        <li class="li">
         See Coherency and Concurrency for details.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="um-pointer-attributes" xml:lang="en-US">
      <a name="um-pointer-attributes" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-pointer-attributes" name="um-pointer-attributes" shape="rect">
        J.2.4.2. Pointer Attributes
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         To determine if a given pointer refers to managed memory, a program can call cudaPointerGetAttributes() and check the value of the isManaged attribute.
        </li>
        <li class="li">
         This attribute is set to 1 if the pointer refers to managed memory and to 0 if not.
        </li>
       </ul>
      </div>
     </div>
    </div>
    <div class="topic concept nested3" id="um-advanced-topics-hd" xml:lang="en-US">
     <a name="um-advanced-topics-hd" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-advanced-topics-hd" name="um-advanced-topics-hd" shape="rect">
       J.2.5. Advanced Topics
      </a>
     </h3>
     <div class="topic concept nested4" id="um-managed-memory" xml:lang="en-US">
      <a name="um-managed-memory" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-managed-memory" name="um-managed-memory" shape="rect">
        J.2.5.1. Managed Memory with Multi-GPU Programs on pre-6.x Architectures
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         On systems with devices of compute capabilities lower than 6.x managed allocations are automatically visible to all GPUs in a system via the peer-to-peer capabilities of the GPUs.
        </li>
        <li class="li">
         On Linux the managed memory is allocated in GPU memory as long as all GPUs that are actively being used by a program have the peer-to-peer support.
        </li>
        <li class="li">
         If at any time the application starts using a GPU that doesn’t have peer-to-peer support with any of the other GPUs that have managed allocations on them, then the driver will migrate all managed allocations to system memory.
        </li>
        <li class="li">
         On Windows if peer mappings are not available (for example, between GPUs of different architectures), then the system will automatically fall back to using zero-copy memory, regardless of whether both GPUs are actually used by a program.
        </li>
        <li class="li">
         If only one GPU is actually going to be used, it is necessary to set the CUDA_VISIBLE_DEVICES environment variable before launching the program.
        </li>
        <li class="li">
         This constrains which GPUs are visible and allows managed memory to be allocated in GPU memory.
        </li>
        <li class="li">
         Alternatively, on Windows users can also set CUDA_MANAGED_FORCE_DEVICE_ALLOC to a non-zero value to force the driver to always use device memory for physical storage.
        </li>
        <li class="li">
         When this environment variable is set to a non-zero value, all devices used in that process that support managed memory have to be peer-to-peer compatible with each other.
        </li>
        <li class="li">
         The error ::cudaErrorInvalidDevice will be returned if a device that supports managed memory is used and it is not peer-to-peer compatible with any of the other managed memory supporting devices that were previously used in that process, even if ::cudaDeviceReset has been called on those devices.
        </li>
        <li class="li">
         These environment variables are described in Appendix CUDA Environment Variables.
        </li>
        <li class="li">
         Note that starting from CUDA 8.0 CUDA_MANAGED_FORCE_DEVICE_ALLOC has no effect on Linux operating systems.
        </li>
       </ul>
      </div>
     </div>
     <div class="topic concept nested4" id="um-fork-managed-memory" xml:lang="en-US">
      <a name="um-fork-managed-memory" shape="rect">
      </a>
      <h3 class="title topictitle2">
       <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-fork-managed-memory" name="um-fork-managed-memory" shape="rect">
        J.2.5.2. Using fork() with Managed Memory
       </a>
      </h3>
      <div class="body conbody">
       <ul class="ul">
        <li class="li">
         The Unified Memory system does not allow sharing of managed memory pointers between processes.
        </li>
        <li class="li">
         It will not correctly manage memory handles that have been duplicated via a fork() operation.
        </li>
        <li class="li">
         Results will be undefined if either the child or parent accesses managed data following a fork().
        </li>
        <li class="li">
         It is safe, however, to fork() a child process that then immediately exits via an exec() call, because the child drops the memory handles and the parent becomes the sole owner once again.
        </li>
        <li class="li">
         It is not safe for the parent to exit and leave the child to access the handles.
        </li>
       </ul>
      </div>
     </div>
    </div>
   </div>
   <div class="topic concept nested2" id="um-performance-tuning" xml:lang="en-US">
    <a name="um-performance-tuning" shape="rect">
    </a>
    <h3 class="title topictitle2">
     <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-performance-tuning" name="um-performance-tuning" shape="rect">
      J.3. Performance Tuning
     </a>
    </h3>
    <div class="body conbody">
     <ul class="ul">
      <li class="li">
       In order to achieve good performance with Unified Memory, the following objectives must be met: Faults should be avoided: While replayable faults are fundamental to enabling a simpler programming model, they can be severely detrimental to application performance.
      </li>
      <li class="li">
       Fault handling can take tens of microseconds because it may involve TLB invalidates, data migrations and page table updates.
      </li>
      <li class="li">
       All the while, execution in certain portions of the application will be halted, thereby potentially impacting overall performance.
      </li>
      <li class="li">
       Data should be local to the accessing processor: As mentioned before, memory access latencies and bandwidth are significantly better when the data is placed local to the processor accessing it.
      </li>
      <li class="li">
       Therefore, data should be suitably migrated to take advantage of lower latencies and higher bandwidth.
      </li>
      <li class="li">
       Memory thrashing should be prevented: If data is frequently accessed by multiple processors and has to be constantly migrated around to achieve data locality, then the overhead of migration may exceed the benefits of locality.
      </li>
      <li class="li">
       Memory thrashing should be prevented to the extent possible.
      </li>
      <li class="li">
       If it cannot be prevented, it must be detected and resolved appropriately.
      </li>
      <li class="li">
       To achieve the same level of performance as what's possible without using Unified Memory, the application has to guide the Unified Memory driver subsystem into avoiding the aforementioned pitfalls.
      </li>
      <li class="li">
       It is worthy to note that the Unified Memory driver subsystem can detect common data access patterns and achieve some of these objectives automatically without application participation.
      </li>
      <li class="li">
       But when the data access patterns are non-obvious, explicit guidance from the application is crucial.
      </li>
      <li class="li">
       CUDA 8.0 introduces useful APIs for providing the runtime with memory usage hints (cudaMemAdvise()) and for explicit prefetching (cudaMemPrefetchAsync()).
      </li>
      <li class="li">
       These tools allow the same capabilities as explicit memory copy and pinning APIs without reverting to the limitations of explicit GPU memory allocation.
      </li>
     </ul>
    </div>
    <div class="topic concept nested3" id="um-tuning-prefetch" xml:lang="en-US">
     <a name="um-tuning-prefetch" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-tuning-prefetch" name="um-tuning-prefetch" shape="rect">
       J.3.1. Data Prefetching
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Data prefetching means migrating data to a processor’s memory and mapping it in that processor’s page tables before the processor begins accessing that data.
       </li>
       <li class="li">
        The intent of data prefetching is to avoid faults while also establishing data locality.
       </li>
       <li class="li">
        This is most valuable for applications that access data primarily from a single processor at any given time.
       </li>
       <li class="li">
        As the accessing processor changes during the lifetime of the application, the data can be prefetched accordingly to follow the execution flow of the application.
       </li>
       <li class="li">
        Since work is launched in streams in CUDA, it is expected of data prefetching to also be a streamed operation as shown in the following API: where the memory region specified by devPtr pointer and count number of bytes, with ptr rounded down to the nearest page boundary and count rounded up to the nearest page boundary, is migrated to the dstDevice by enqueueing a migration operation in stream.
       </li>
       <li class="li">
        Passing in cudaCpuDeviceId for dstDevice will cause data to be migrated to CPU memory.
       </li>
       <li class="li">
        Consider a simple code example below:Without performance hints the kernel mykernel will fault on first access to data which creates additional overhead of the fault processing and generally slows down the application.
       </li>
       <li class="li">
        By prefetching data in advance it is possible to avoid page faults and achieve better performance.
       </li>
       <li class="li">
        This API follows stream ordering semantics, i.e.
       </li>
       <li class="li">
        the migration does not begin until all prior operations in the stream have completed, and any subsequent operation in the stream does not begin until the migration has completed.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="um-tuning-usage" xml:lang="en-US">
     <a name="um-tuning-usage" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-tuning-usage" name="um-tuning-usage" shape="rect">
       J.3.2. Data Usage Hints
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        Data prefetching alone is insufficient when multiple processors need to simultaneously access the same data.
       </li>
       <li class="li">
        In such scenarios, it's useful for the application to provide hints on how the data will actually be used.
       </li>
       <li class="li">
        The following advisory API can be used to specify data usage: where advice, specified for data contained in region starting from devPtr address and with the length of count bytes, rounded to the nearest page boundary, can take the following values: cudaMemAdviseSetReadMostly: This implies that the data is mostly going to be read from and only occasionally written to.
       </li>
       <li class="li">
        This allows the driver to create read-only copies of the data in a processor's memory when that processor accesses it.
       </li>
       <li class="li">
        Similarly, if cudaMemPrefetchAsync is called on this region, it will create a read-only copy of the data on the destination processor.
       </li>
       <li class="li">
        When a processor writes to this data, all copies of the corresponding page are invalidated except for the one where the write occurred.
       </li>
       <li class="li">
        The device argument is ignored for this advice.
       </li>
       <li class="li">
        This advice allows multiple processors to simultaneously access the same data at maximal bandwidth as illustrated in the following code snippet: cudaMemAdviseSetPreferredLocation: This advice sets the preferred location for the data to be the memory belonging to device.
       </li>
       <li class="li">
        Passing in a value of cudaCpuDeviceId for device sets the preferred location as CPU memory.
       </li>
       <li class="li">
        Setting the preferred location does not cause data to migrate to that location immediately.
       </li>
       <li class="li">
        Instead, it guides the migration policy when a fault occurs on that memory region.
       </li>
       <li class="li">
        If the data is already in its preferred location and the faulting processor can establish a mapping without requiring the data to be migrated, then the migration will be avoided.
       </li>
       <li class="li">
        On the other hand, if the data is not in its preferred location or if a direct mapping cannot be established, then it will be migrated to the processor accessing it.
       </li>
       <li class="li">
        It is important to note that setting the preferred location does not prevent data prefetching done using cudaMemPrefetchAsync.
       </li>
       <li class="li">
        cudaMemAdviseSetAccessedBy: This advice implies that the data will be accessed by device.
       </li>
       <li class="li">
        This does not cause data migration and has no impact on the location of the data per se.
       </li>
       <li class="li">
        Instead, it causes the data to always be mapped in the specified processor’s page tables, as long as the location of the data permits a mapping to be established.
       </li>
       <li class="li">
        If the data gets migrated for any reason, the mappings are updated accordingly.
       </li>
       <li class="li">
        This advice is useful in scenarios where data locality is not important, but avoiding faults is.
       </li>
       <li class="li">
        Consider for example a system containing multiple GPUs with peer-to-peer access enabled, where the data located on one GPU is occasionally accessed by other GPUs.
       </li>
       <li class="li">
        In such scenarios, migrating data over to the other GPUs is not as important because the accesses are infrequent and the overhead of migration may be too high.
       </li>
       <li class="li">
        But preventing faults can still help improve performance, and so having a mapping set up in advance is useful.
       </li>
       <li class="li">
        Note that on CPU access of this data, the data may be migrated to CPU memory because the CPU cannot access GPU memory directly.
       </li>
       <li class="li">
        Any GPU that had the cudaMemAdviceSetAccessedBy flag set for this data will now have its mapping updated to point to the page in CPU memory.
       </li>
       <li class="li">
        Each advice can be also unset by using one of the following values: cudaMemAdviseUnsetReadMostly, cudaMemAdviseUnsetPreferredLocation and cudaMemAdviseUnsetAccessedBy.
       </li>
      </ul>
     </div>
    </div>
    <div class="topic concept nested3" id="um-querying-usage" xml:lang="en-US">
     <a name="um-querying-usage" shape="rect">
     </a>
     <h3 class="title topictitle2">
      <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-querying-usage" name="um-querying-usage" shape="rect">
       J.3.3. Querying Usage Attributes
      </a>
     </h3>
     <div class="body conbody">
      <ul class="ul">
       <li class="li">
        A program can query memory range attributes assigned through cudaMemAdvise or cudaMemPrefetchAsync by using the following API: This function queries an attribute of the memory range starting at devPtr with a size of count bytes.
       </li>
       <li class="li">
        The memory range must refer to managed memory allocated via cudaMallocManaged or declared via __managed__ variables.
       </li>
       <li class="li">
        It is possible to query the following attributes: cudaMemRangeAttributeReadMostly: the result returned will be 1 if all pages in the given memory range have read-duplication enabled, or 0 otherwise.
       </li>
       <li class="li">
        cudaMemRangeAttributePreferredLocation: the result returned will be a GPU device id or cudaCpuDeviceId if all pages in the memory range have the corresponding processor as their preferred location, otherwise cudaInvalidDeviceId will be returned.
       </li>
       <li class="li">
        An application can use this query API to make decision about staging data through CPU or GPU depending on the preferred location attribute of the managed pointer.
       </li>
       <li class="li">
        Note that the actual location of the pages in the memory range at the time of the query may be different from the preferred location.
       </li>
       <li class="li">
        cudaMemRangeAttributeAccessedBy: will return the list of devices that have that advise set for that memory range.
       </li>
       <li class="li">
        cudaMemRangeAttributeLastPrefetchLocation: will return the last location to which all pages in the memory range were prefetched explicitly using cudaMemPrefetchAsync.
       </li>
       <li class="li">
        Note that this simply returns the last location that the application requested to prefetch the memory range to.
       </li>
       <li class="li">
        It gives no indication as to whether the prefetch operation to that location has completed or even begun.
       </li>
       <li class="li">
        Additionally, multiple attributes can be queried by using corresponding cudaMemRangeGetAttributes function.
       </li>
      </ul>
     </div>
    </div>
   </div>
  </div>
 </article>
</div>
 {% endblock %} 
